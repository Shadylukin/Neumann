"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import abc as _abc_1
import sys
import typing as _typing
from collections import abc as _abc

import grpc as _grpc
import neumann_pb2 as _neumann_pb2
from grpc import aio as _aio

if sys.version_info >= (3, 11):
    from typing import Self as _Self
else:
    from typing_extensions import Self as _Self

_T = _typing.TypeVar("_T")

class _MaybeAsyncIterator(_abc.AsyncIterator[_T], _abc.Iterator[_T], metaclass=_abc_1.ABCMeta): ...
class _ServicerContext(_grpc.ServicerContext, _aio.ServicerContext):  # type: ignore[misc]
    ...

GRPC_GENERATED_VERSION: str
GRPC_VERSION: str

class QueryServiceStub:
    """Query service for executing Neumann queries."""

    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> QueryServiceAsyncStub: ...  # type: ignore[overload-cannot-match]
    Execute: _grpc.UnaryUnaryMultiCallable[_neumann_pb2.QueryRequest, _neumann_pb2.QueryResponse]
    """Execute a single query."""
    ExecuteStream: _grpc.UnaryStreamMultiCallable[
        _neumann_pb2.QueryRequest, _neumann_pb2.QueryResponseChunk
    ]
    """Execute a query with streaming results (for large result sets)."""
    ExecuteBatch: _grpc.UnaryUnaryMultiCallable[
        _neumann_pb2.BatchQueryRequest, _neumann_pb2.BatchQueryResponse
    ]
    """Execute multiple queries in a batch."""
    ExecutePaginated: _grpc.UnaryUnaryMultiCallable[
        _neumann_pb2.PaginatedQueryRequest, _neumann_pb2.PaginatedQueryResponse
    ]
    """Execute a paginated query with cursor-based navigation."""
    CloseCursor: _grpc.UnaryUnaryMultiCallable[
        _neumann_pb2.CloseCursorRequest, _neumann_pb2.CloseCursorResponse
    ]
    """Close a cursor to free server resources."""

@_typing.type_check_only
class QueryServiceAsyncStub(QueryServiceStub):
    """Query service for executing Neumann queries."""

    def __init__(self, channel: _aio.Channel) -> None: ...
    Execute: _aio.UnaryUnaryMultiCallable[_neumann_pb2.QueryRequest, _neumann_pb2.QueryResponse]
    """Execute a single query."""
    ExecuteStream: _aio.UnaryStreamMultiCallable[
        _neumann_pb2.QueryRequest, _neumann_pb2.QueryResponseChunk
    ]
    """Execute a query with streaming results (for large result sets)."""
    ExecuteBatch: _aio.UnaryUnaryMultiCallable[
        _neumann_pb2.BatchQueryRequest, _neumann_pb2.BatchQueryResponse
    ]
    """Execute multiple queries in a batch."""
    ExecutePaginated: _aio.UnaryUnaryMultiCallable[
        _neumann_pb2.PaginatedQueryRequest, _neumann_pb2.PaginatedQueryResponse
    ]
    """Execute a paginated query with cursor-based navigation."""
    CloseCursor: _aio.UnaryUnaryMultiCallable[
        _neumann_pb2.CloseCursorRequest, _neumann_pb2.CloseCursorResponse
    ]
    """Close a cursor to free server resources."""

class QueryServiceServicer(metaclass=_abc_1.ABCMeta):
    """Query service for executing Neumann queries."""

    @_abc_1.abstractmethod
    def Execute(
        self,
        request: _neumann_pb2.QueryRequest,
        context: _ServicerContext,
    ) -> _neumann_pb2.QueryResponse | _abc.Awaitable[_neumann_pb2.QueryResponse]:
        """Execute a single query."""

    @_abc_1.abstractmethod
    def ExecuteStream(
        self,
        request: _neumann_pb2.QueryRequest,
        context: _ServicerContext,
    ) -> _abc.Iterator[_neumann_pb2.QueryResponseChunk] | _abc.AsyncIterator[_neumann_pb2.QueryResponseChunk]:
        """Execute a query with streaming results (for large result sets)."""

    @_abc_1.abstractmethod
    def ExecuteBatch(
        self,
        request: _neumann_pb2.BatchQueryRequest,
        context: _ServicerContext,
    ) -> _neumann_pb2.BatchQueryResponse | _abc.Awaitable[_neumann_pb2.BatchQueryResponse]:
        """Execute multiple queries in a batch."""

    @_abc_1.abstractmethod
    def ExecutePaginated(
        self,
        request: _neumann_pb2.PaginatedQueryRequest,
        context: _ServicerContext,
    ) -> _neumann_pb2.PaginatedQueryResponse | _abc.Awaitable[_neumann_pb2.PaginatedQueryResponse]:
        """Execute a paginated query with cursor-based navigation."""

    @_abc_1.abstractmethod
    def CloseCursor(
        self,
        request: _neumann_pb2.CloseCursorRequest,
        context: _ServicerContext,
    ) -> _neumann_pb2.CloseCursorResponse | _abc.Awaitable[_neumann_pb2.CloseCursorResponse]:
        """Close a cursor to free server resources."""

def add_QueryServiceServicer_to_server(
    servicer: QueryServiceServicer, server: _grpc.Server | _aio.Server
) -> None: ...

class BlobServiceStub:
    """Blob service for artifact storage."""

    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> BlobServiceAsyncStub: ...  # type: ignore[overload-cannot-match]
    Upload: _grpc.StreamUnaryMultiCallable[
        _neumann_pb2.BlobUploadRequest, _neumann_pb2.BlobUploadResponse
    ]
    """Upload a blob with streaming chunks."""
    Download: _grpc.UnaryStreamMultiCallable[
        _neumann_pb2.BlobDownloadRequest, _neumann_pb2.BlobDownloadChunk
    ]
    """Download a blob with streaming chunks."""
    Delete: _grpc.UnaryUnaryMultiCallable[
        _neumann_pb2.BlobDeleteRequest, _neumann_pb2.BlobDeleteResponse
    ]
    """Delete a blob."""
    GetMetadata: _grpc.UnaryUnaryMultiCallable[
        _neumann_pb2.BlobMetadataRequest, _neumann_pb2.ArtifactInfo
    ]
    """Get artifact metadata."""

@_typing.type_check_only
class BlobServiceAsyncStub(BlobServiceStub):
    """Blob service for artifact storage."""

    def __init__(self, channel: _aio.Channel) -> None: ...
    Upload: _aio.StreamUnaryMultiCallable[
        _neumann_pb2.BlobUploadRequest, _neumann_pb2.BlobUploadResponse
    ]
    """Upload a blob with streaming chunks."""
    Download: _aio.UnaryStreamMultiCallable[
        _neumann_pb2.BlobDownloadRequest, _neumann_pb2.BlobDownloadChunk
    ]
    """Download a blob with streaming chunks."""
    Delete: _aio.UnaryUnaryMultiCallable[
        _neumann_pb2.BlobDeleteRequest, _neumann_pb2.BlobDeleteResponse
    ]
    """Delete a blob."""
    GetMetadata: _aio.UnaryUnaryMultiCallable[
        _neumann_pb2.BlobMetadataRequest, _neumann_pb2.ArtifactInfo
    ]
    """Get artifact metadata."""

class BlobServiceServicer(metaclass=_abc_1.ABCMeta):
    """Blob service for artifact storage."""

    @_abc_1.abstractmethod
    def Upload(
        self,
        request_iterator: _MaybeAsyncIterator[_neumann_pb2.BlobUploadRequest],
        context: _ServicerContext,
    ) -> _neumann_pb2.BlobUploadResponse | _abc.Awaitable[_neumann_pb2.BlobUploadResponse]:
        """Upload a blob with streaming chunks."""

    @_abc_1.abstractmethod
    def Download(
        self,
        request: _neumann_pb2.BlobDownloadRequest,
        context: _ServicerContext,
    ) -> _abc.Iterator[_neumann_pb2.BlobDownloadChunk] | _abc.AsyncIterator[_neumann_pb2.BlobDownloadChunk]:
        """Download a blob with streaming chunks."""

    @_abc_1.abstractmethod
    def Delete(
        self,
        request: _neumann_pb2.BlobDeleteRequest,
        context: _ServicerContext,
    ) -> _neumann_pb2.BlobDeleteResponse | _abc.Awaitable[_neumann_pb2.BlobDeleteResponse]:
        """Delete a blob."""

    @_abc_1.abstractmethod
    def GetMetadata(
        self,
        request: _neumann_pb2.BlobMetadataRequest,
        context: _ServicerContext,
    ) -> _neumann_pb2.ArtifactInfo | _abc.Awaitable[_neumann_pb2.ArtifactInfo]:
        """Get artifact metadata."""

def add_BlobServiceServicer_to_server(
    servicer: BlobServiceServicer, server: _grpc.Server | _aio.Server
) -> None: ...

class HealthStub:
    """Health check service."""

    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> HealthAsyncStub: ...  # type: ignore[overload-cannot-match]
    Check: _grpc.UnaryUnaryMultiCallable[
        _neumann_pb2.HealthCheckRequest, _neumann_pb2.HealthCheckResponse
    ]
    """Check server health."""

@_typing.type_check_only
class HealthAsyncStub(HealthStub):
    """Health check service."""

    def __init__(self, channel: _aio.Channel) -> None: ...
    Check: _aio.UnaryUnaryMultiCallable[
        _neumann_pb2.HealthCheckRequest, _neumann_pb2.HealthCheckResponse
    ]
    """Check server health."""

class HealthServicer(metaclass=_abc_1.ABCMeta):
    """Health check service."""

    @_abc_1.abstractmethod
    def Check(
        self,
        request: _neumann_pb2.HealthCheckRequest,
        context: _ServicerContext,
    ) -> _neumann_pb2.HealthCheckResponse | _abc.Awaitable[_neumann_pb2.HealthCheckResponse]:
        """Check server health."""

def add_HealthServicer_to_server(
    servicer: HealthServicer, server: _grpc.Server | _aio.Server
) -> None: ...
