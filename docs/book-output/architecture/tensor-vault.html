<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tensor Vault - Neumann</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Unified tensor-based runtime for relational, graph, and vector data">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neumann</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann/edit/main/docs/book/src/architecture/tensor-vault.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tensor-vault"><a class="header" href="#tensor-vault">Tensor Vault</a></h1>
<p>Tensor Vault provides secure secret storage with AES-256-GCM encryption and
graph-based access control. Designed for multi-agent environments, it implements
a zero-trust architecture where access is determined by graph topology rather
than traditional ACLs.</p>
<p>All secrets are encrypted at rest with authenticated encryption. The vault
maintains a permanent audit trail of all operations and supports features like
rate limiting, TTL-based grants, and namespace isolation for multi-tenant
deployments.</p>
<h2 id="when-to-use-tensor-vault"><a class="header" href="#when-to-use-tensor-vault">When to Use Tensor Vault</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>How Tensor Vault Helps</th></tr></thead><tbody>
<tr><td>Multiple agents need access to shared secrets</td><td>Graph-based access control with per-agent permission levels</td></tr>
<tr><td>You need to audit who accessed what and when</td><td>Tamper-evident audit log with HMAC integrity and AEAD encryption</td></tr>
<tr><td>Temporary access to secrets</td><td>TTL-based grants and secret expiration auto-revoke access</td></tr>
<tr><td>Agent delegation chains</td><td>Delegation with ceiling model, depth limits, and cascading revocation</td></tr>
<tr><td>Security posture review</td><td>Graph intelligence: blast radius, privilege analysis, role inference</td></tr>
<tr><td>Incident response</td><td>Break-glass emergency access with justification and auto-expiry</td></tr>
<tr><td>Application-level encryption</td><td>Transit encryption lets agents encrypt data without holding keys</td></tr>
<tr><td>Regulatory compliance</td><td>Immutable audit trail, key rotation, and anomaly detection</td></tr>
</tbody></table>
</div>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Principle</th><th>Description</th></tr></thead><tbody>
<tr><td>Encryption at Rest</td><td>All secrets encrypted with AES-256-GCM</td></tr>
<tr><td>Topological Access Control</td><td>Access determined by graph path, not ACLs</td></tr>
<tr><td>Zero Trust</td><td>No bypass mode; <code>node:root</code> is the only universal accessor</td></tr>
<tr><td>Memory Safety</td><td>Keys zeroized on drop via <code>zeroize</code> crate</td></tr>
<tr><td>Tamper-Evident Graph</td><td>All permission edges HMAC-signed; tampering detected on traversal</td></tr>
<tr><td>Distance Attenuation</td><td>Permissions degrade with graph distance from the secret</td></tr>
<tr><td>Least Privilege Delegation</td><td>Agents delegate subsets of their own access with ceiling model</td></tr>
<tr><td>Behavioral Monitoring</td><td>Per-agent anomaly detection flags spikes, bulk ops, and dormancy</td></tr>
<tr><td>Permanent Audit Trail</td><td>All operations logged with HMAC integrity and AEAD encryption</td></tr>
<tr><td>Defense in Depth</td><td>Multiple obfuscation layers hide patterns</td></tr>
<tr><td>Multi-Tenant Ready</td><td>Namespace isolation and rate limiting for agent systems</td></tr>
</tbody></table>
</div>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<h3 id="core-types"><a class="header" href="#core-types">Core Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Vault</code></td><td>Main API for encrypted secret storage with graph-based access control</td></tr>
<tr><td><code>VaultConfig</code></td><td>Configuration for key derivation, rate limiting, and versioning</td></tr>
<tr><td><code>VaultError</code></td><td>Error types (AccessDenied, NotFound, CryptoError, etc.)</td></tr>
<tr><td><code>Permission</code></td><td>Access levels: Read, Write, Admin</td></tr>
<tr><td><code>VersionInfo</code></td><td>Metadata about a secret version (version number, timestamp)</td></tr>
<tr><td><code>ScopedVault</code></td><td>Entity-bound view for simplified API usage</td></tr>
<tr><td><code>NamespacedVault</code></td><td>Namespace-prefixed view for multi-tenant isolation</td></tr>
</tbody></table>
</div>
<h3 id="cryptographic-types"><a class="header" href="#cryptographic-types">Cryptographic Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>MasterKey</code></td><td>Derived encryption key with zeroize-on-drop (32 bytes)</td></tr>
<tr><td><code>Cipher</code></td><td>AES-256-GCM encryption wrapper</td></tr>
<tr><td><code>Obfuscator</code></td><td>HMAC-based key obfuscation and AEAD metadata encryption</td></tr>
<tr><td><code>PaddingSize</code></td><td>Padding buckets for length hiding (256B to 64KB)</td></tr>
</tbody></table>
</div>
<h3 id="access-control-types"><a class="header" href="#access-control-types">Access Control Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AccessController</code></td><td>BFS-based graph path verification</td></tr>
<tr><td><code>GrantTTLTracker</code></td><td>Min-heap tracking grant expirations with persistence</td></tr>
<tr><td><code>RateLimiter</code></td><td>Sliding window rate limiting per entity</td></tr>
<tr><td><code>RateLimitConfig</code></td><td>Configurable limits per operation type</td></tr>
</tbody></table>
</div>
<h3 id="edge-signing-types"><a class="header" href="#edge-signing-types">Edge Signing Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>EdgeSigner</code></td><td>HMAC-BLAKE2b signer for graph edge integrity</td></tr>
</tbody></table>
</div>
<h3 id="attenuation-types"><a class="header" href="#attenuation-types">Attenuation Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AttenuationPolicy</code></td><td>Distance-based permission degradation policy</td></tr>
</tbody></table>
</div>
<h3 id="delegation-types"><a class="header" href="#delegation-types">Delegation Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>DelegationManager</code></td><td>Agent-to-agent delegation with depth limits and ceiling model</td></tr>
<tr><td><code>DelegationRecord</code></td><td>Single delegation grant (parent, child, secrets, ceiling, TTL)</td></tr>
</tbody></table>
</div>
<h3 id="anomaly-detection-types"><a class="header" href="#anomaly-detection-types">Anomaly Detection Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AnomalyMonitor</code></td><td>Real-time per-agent behavioral anomaly tracker</td></tr>
<tr><td><code>AnomalyThresholds</code></td><td>Configurable limits for spike, bulk, and inactivity detection</td></tr>
<tr><td><code>AgentProfile</code></td><td>Per-agent access history (known secrets, counts, timestamps)</td></tr>
<tr><td><code>AnomalyEvent</code></td><td>Event variants: FrequencySpike, BulkOperation, InactiveAgentResumed, FirstSecretAccess</td></tr>
</tbody></table>
</div>
<h3 id="audit-types"><a class="header" href="#audit-types">Audit Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AuditLog</code></td><td>Query interface for audit entries with optional HMAC/AEAD protection</td></tr>
<tr><td><code>AuditEntry</code></td><td>Single operation record (entity, key, operation, timestamp)</td></tr>
<tr><td><code>AuditOperation</code></td><td>Operation types: Get, Set, Delete, Rotate, Grant, Revoke, List</td></tr>
</tbody></table>
</div>
<h3 id="graph-intelligence-types"><a class="header" href="#graph-intelligence-types">Graph Intelligence Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AccessExplanation</code></td><td>Path-level explanation of why access was granted or denied</td></tr>
<tr><td><code>BlastRadius</code></td><td>All secrets reachable by an entity with permission and hop detail</td></tr>
<tr><td><code>SimulationResult</code></td><td>Dry-run impact analysis of a hypothetical grant</td></tr>
<tr><td><code>SecurityAuditReport</code></td><td>SCC cycles, single points of failure, over-privileged entities</td></tr>
<tr><td><code>CriticalEntity</code></td><td>Articulation-point analysis with PageRank and dependency counts</td></tr>
<tr><td><code>PrivilegeAnalysisReport</code></td><td>PageRank-weighted reachability scores per entity</td></tr>
<tr><td><code>DelegationAnomalyScore</code></td><td>Jaccard and Adamic-Adar similarity for delegation edges</td></tr>
<tr><td><code>RoleInferenceResult</code></td><td>Louvain community detection mapped to inferred roles</td></tr>
<tr><td><code>TrustTransitivityReport</code></td><td>Triangle counting and clustering coefficients</td></tr>
<tr><td><code>RiskPropagationReport</code></td><td>Eigenvector centrality weighted by admin reachability</td></tr>
</tbody></table>
</div>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre class="mermaid">flowchart TB
    subgraph &quot;Tensor Vault&quot;
        API[Vault API]
        AC[AccessController]
        Cipher[Cipher&lt;br/&gt;AES-256-GCM]
        KDF[MasterKey&lt;br/&gt;Argon2id + HKDF]
        Obf[Obfuscator&lt;br/&gt;HMAC + Padding]
        Sign[EdgeSigner&lt;br/&gt;HMAC-BLAKE2b]
        Atten[Attenuation&lt;br/&gt;Distance Policy]
        Deleg[DelegationManager&lt;br/&gt;Ceiling Model]
        Anomaly[AnomalyMonitor&lt;br/&gt;Behavior Tracking]
        Transit[Transit Cipher&lt;br/&gt;Encrypt-as-a-Service]
        Audit[AuditLog&lt;br/&gt;HMAC + AEAD]
        TTL[GrantTTLTracker]
        RL[RateLimiter]
        GI[GraphIntel&lt;br/&gt;Security Analytics]
    end

    subgraph &quot;Storage&quot;
        TS[TensorStore]
        GE[GraphEngine]
    end

    API --&gt; AC
    API --&gt; Cipher
    API --&gt; Obf
    API --&gt; Sign
    API --&gt; Audit
    API --&gt; TTL
    API --&gt; RL
    API --&gt; Deleg
    API --&gt; Anomaly
    API --&gt; Transit
    API --&gt; GI

    AC --&gt; GE
    AC --&gt; Atten
    AC --&gt; Sign
    Cipher --&gt; KDF
    Obf --&gt; KDF
    Transit --&gt; KDF
    Audit --&gt; KDF
    GI --&gt; GE

    API --&gt; TS
    Audit --&gt; TS
    Deleg --&gt; TS
    Anomaly --&gt; TS
</pre>
<h3 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h3>
<ol>
<li><strong>Set Operation</strong>: Plaintext is padded, encrypted with random nonce, metadata
obfuscated, stored via TensorStore</li>
<li><strong>Get Operation</strong>: Rate limit check, access path verified via BFS, ciphertext
decrypted, padding removed, audit logged</li>
<li><strong>Grant Operation</strong>: Permission edge created in GraphEngine, TTL tracked if
specified</li>
<li><strong>Revoke Operation</strong>: Permission edge deleted, expired grants cleaned up</li>
</ol>
<h3 id="set-operation-flow"><a class="header" href="#set-operation-flow">Set Operation Flow</a></h3>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant V as Vault
    participant RL as RateLimiter
    participant AC as AccessController
    participant O as Obfuscator
    participant Ci as Cipher
    participant TS as TensorStore
    participant GE as GraphEngine
    participant A as AuditLog

    C-&gt;&gt;V: set(requester, key, value)
    V-&gt;&gt;RL: check_rate_limit(requester, Set)
    alt Rate Limited
        RL--&gt;&gt;V: RateLimited error
        V--&gt;&gt;C: Error
    end

    alt New Secret
        V-&gt;&gt;V: Check requester == ROOT
        alt Not Root
            V--&gt;&gt;C: AccessDenied
        end
    else Update
        V-&gt;&gt;AC: check_path_with_permission(Write)
    end

    V-&gt;&gt;O: pad_plaintext(value)
    O--&gt;&gt;V: padded_value
    V-&gt;&gt;Ci: encrypt(padded_value)
    Ci--&gt;&gt;V: (ciphertext, nonce)

    V-&gt;&gt;O: generate_storage_id(key, nonce)
    O--&gt;&gt;V: blob_key
    V-&gt;&gt;TS: put(blob_key, ciphertext)

    V-&gt;&gt;O: obfuscate_key(key)
    O--&gt;&gt;V: obfuscated_key
    V-&gt;&gt;O: encrypt_metadata(creator)
    V-&gt;&gt;O: encrypt_metadata(timestamp)
    V-&gt;&gt;TS: put(_vk:obfuscated_key, metadata)

    alt New Secret
        V-&gt;&gt;GE: add_entity_edge(ROOT, secret_node, VAULT_ACCESS_ADMIN)
    end

    V-&gt;&gt;A: record(requester, key, Set)
    V--&gt;&gt;C: Ok(())
</pre>
<h2 id="access-control-model"><a class="header" href="#access-control-model">Access Control Model</a></h2>
<p>Access is determined by graph topology using BFS traversal:</p>
<pre><code class="language-text">node:root ──VAULT_ACCESS_ADMIN──&gt; vault_secret:api_key
                                          ^
user:alice ──VAULT_ACCESS_READ───────────┘
                                          ^
team:devs ──VAULT_ACCESS_WRITE───────────┘
      ^
user:bob ──MEMBER────────────────────────┘
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Requester</th><th>Path</th><th>Access</th></tr></thead><tbody>
<tr><td><code>node:root</code></td><td>Always</td><td>Granted (Admin)</td></tr>
<tr><td><code>user:alice</code></td><td>Direct edge</td><td>Granted (Read only)</td></tr>
<tr><td><code>team:devs</code></td><td>Direct edge</td><td>Granted (Write)</td></tr>
<tr><td><code>user:bob</code></td><td>bob -&gt; team:devs -&gt; secret</td><td>Granted (Write via team)</td></tr>
<tr><td><code>user:carol</code></td><td>No path</td><td>Denied</td></tr>
</tbody></table>
</div>
<h3 id="permission-levels"><a class="header" href="#permission-levels">Permission Levels</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Capabilities</th></tr></thead><tbody>
<tr><td>Read</td><td><code>get()</code>, <code>list()</code>, <code>get_version()</code>, <code>list_versions()</code></td></tr>
<tr><td>Write</td><td>Read + <code>set()</code> (update), <code>rotate()</code>, <code>rollback()</code></td></tr>
<tr><td>Admin</td><td>Write + <code>delete()</code>, <code>grant()</code>, <code>revoke()</code></td></tr>
</tbody></table>
</div>
<p>Permission propagation follows graph paths. The effective permission is
determined by the <code>VAULT_ACCESS_*</code> edge type at the end of the path.</p>
<h3 id="allowed-traversal-edges"><a class="header" href="#allowed-traversal-edges">Allowed Traversal Edges</a></h3>
<p>Only these edge types can grant transitive access:</p>
<ul>
<li><code>VAULT_ACCESS</code> - Legacy edge type (treated as Admin for backward
compatibility)</li>
<li><code>VAULT_ACCESS_READ</code> - Read-only access</li>
<li><code>VAULT_ACCESS_WRITE</code> - Read + Write access</li>
<li><code>VAULT_ACCESS_ADMIN</code> - Full access including grant/revoke</li>
<li><code>MEMBER</code> - Allows group membership traversal but does NOT grant permission
directly</li>
</ul>
<h3 id="access-control-algorithm"><a class="header" href="#access-control-algorithm">Access Control Algorithm</a></h3>
<p>The <code>AccessController</code> uses BFS to find the best permission level along any
path:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simplified algorithm from access.rs
pub fn get_permission_level(graph: &amp;GraphEngine, source: &amp;str, target: &amp;str) -&gt; Option&lt;Permission&gt; {
    if source == target {
        return Some(Permission::Admin);  // Self-access
    }

    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    let mut best_permission: Option&lt;Permission&gt; = None;

    queue.push_back(source.to_string());
    visited.insert(source.to_string());

    while let Some(current) = queue.pop_front() {
        for edge in graph.get_entity_outgoing(&amp;current) {
            let (_, to, edge_type, _) = graph.get_entity_edge(&amp;edge);

            // Only traverse allowed edge types
            if !is_allowed_edge_type(&amp;edge_type) {
                continue;
            }

            // VAULT_ACCESS_* edges grant permission to target
            if edge_type.starts_with("VAULT_ACCESS") &amp;&amp; to == target {
                if let Some(perm) = Permission::from_edge_type(&amp;edge_type) {
                    best_permission = max(best_permission, perm);
                }
            } else if edge_type == "MEMBER" {
                // MEMBER edges allow traversal but NO permission grant
                if !visited.contains(&amp;to) {
                    visited.insert(to.clone());
                    queue.push_back(to);
                }
            }
        }
    }

    best_permission
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Note</strong>: <code>MEMBER</code> edges enable traversal through groups but do not
grant permissions. Only <code>VAULT_ACCESS_*</code> edges grant actual permissions. This
prevents privilege escalation via group membership.</p>
<h3 id="access-control-flow"><a class="header" href="#access-control-flow">Access Control Flow</a></h3>
<pre class="mermaid">flowchart TD
    Start([Check Access]) --&gt; IsRoot{Is requester ROOT?}
    IsRoot --&gt;|Yes| Granted([Access Granted - Admin])
    IsRoot --&gt;|No| BFS[Start BFS from requester]

    BFS --&gt; Queue{Queue empty?}
    Queue --&gt;|Yes| CheckBest{Best permission found?}
    Queue --&gt;|No| Pop[Pop next node]

    Pop --&gt; GetEdges[Get outgoing edges]
    GetEdges --&gt; ForEdge{For each edge}

    ForEdge --&gt; IsAllowed{Edge type allowed?}
    IsAllowed --&gt;|No| ForEdge
    IsAllowed --&gt;|Yes| IsVaultAccess{VAULT_ACCESS_* ?}

    IsVaultAccess --&gt;|Yes| IsTarget{Points to target?}
    IsTarget --&gt;|Yes| UpdateBest[Update best permission]
    IsTarget --&gt;|No| ForEdge
    UpdateBest --&gt; ForEdge

    IsVaultAccess --&gt;|No| IsMember{MEMBER edge?}
    IsMember --&gt;|Yes| AddQueue[Add destination to queue]
    IsMember --&gt;|No| ForEdge
    AddQueue --&gt; ForEdge

    ForEdge --&gt;|Done| Queue

    CheckBest --&gt;|Yes| CheckLevel{Permission &gt;= required?}
    CheckBest --&gt;|No| Denied([Access Denied])
    CheckLevel --&gt;|Yes| Granted2([Access Granted])
    CheckLevel --&gt;|No| Insufficient([Insufficient Permission])
</pre>
<h2 id="edge-signing"><a class="header" href="#edge-signing">Edge Signing</a></h2>
<p>Every permission edge in the graph is signed with HMAC-BLAKE2b to
prevent topology tampering. When the vault creates or modifies a
<code>VAULT_ACCESS_*</code> edge, it computes a signature over the canonicalized
tuple <code>(from, to, edge_type, timestamp)</code> and stores it as an edge
property.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From signing.rs
impl EdgeSigner {
    pub fn sign_edge(
        &amp;self,
        from: &amp;str,
        to: &amp;str,
        edge_type: &amp;str,
        timestamp: i64,
    ) -&gt; Vec&lt;u8&gt; {
        // HMAC-BLAKE2b over canonical representation
        // from || ":" || to || ":" || edge_type || ":" || timestamp
    }

    pub fn verify_edge(
        &amp;self,
        from: &amp;str,
        to: &amp;str,
        edge_type: &amp;str,
        timestamp: i64,
        signature: &amp;[u8],
    ) -&gt; bool {
        // Constant-time comparison to prevent timing attacks
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Signature verification happens during BFS traversal. If a tampered
edge is encountered, the <code>AccessController</code> skips it and the
<code>explain_access</code> API reports a <code>TamperedEdge</code> denial reason.</p>
<h2 id="distance-based-attenuation"><a class="header" href="#distance-based-attenuation">Distance-Based Attenuation</a></h2>
<p>Permissions degrade as graph distance increases between an entity
and a secret. This limits the blast radius of transitive access
chains.</p>
<h3 id="attenuationpolicy"><a class="header" href="#attenuationpolicy">AttenuationPolicy</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>admin_limit</code></td><td><code>usize</code></td><td>1</td><td>Maximum hops that preserve Admin</td></tr>
<tr><td><code>write_limit</code></td><td><code>usize</code></td><td>2</td><td>Maximum hops that preserve Write</td></tr>
<tr><td><code>horizon</code></td><td><code>usize</code></td><td>10</td><td>BFS cutoff; access denied beyond this</td></tr>
</tbody></table>
</div>
<h3 id="permission-at-each-hop"><a class="header" href="#permission-at-each-hop">Permission at Each Hop</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Hops</th><th>Effective Permission</th></tr></thead><tbody>
<tr><td>1</td><td>Admin (if granted Admin)</td></tr>
<tr><td>2</td><td>Write (Admin attenuates to Write)</td></tr>
<tr><td>3-10</td><td>Read (Write attenuates to Read)</td></tr>
<tr><td>&gt;10</td><td>Denied (beyond horizon)</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From attenuation.rs
impl AttenuationPolicy {
    pub fn attenuate(
        &amp;self,
        perm: Permission,
        hops: usize,
    ) -&gt; Option&lt;Permission&gt; {
        if hops &gt; self.horizon {
            return None; // Beyond horizon
        }
        match perm {
            Permission::Admin if hops &gt; self.admin_limit =&gt;
                self.attenuate(Permission::Write, hops),
            Permission::Write if hops &gt; self.write_limit =&gt;
                Some(Permission::Read),
            other =&gt; Some(other),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Use <code>AttenuationPolicy::none()</code> to disable attenuation for backward
compatibility with legacy deployments.</p>
<h2 id="delegation"><a class="header" href="#delegation">Delegation</a></h2>
<p>Agents can delegate subsets of their own access to child agents.
Delegation follows a ceiling model: the child can never exceed the
parent’s permission level.</p>
<h3 id="key-properties"><a class="header" href="#key-properties">Key Properties</a></h3>
<ul>
<li><strong>Ceiling model</strong>: <code>effective = min(parent_permission, requested)</code></li>
<li><strong>Depth limits</strong>: Configurable maximum chain depth (default 3)</li>
<li><strong>Cycle prevention</strong>: A child cannot delegate back to an ancestor</li>
<li><strong>Cascading revocation</strong>: Revoking a parent revokes all descendants</li>
<li><strong>TTL support</strong>: Delegations can expire automatically</li>
</ul>
<h3 id="delegationrecord-fields"><a class="header" href="#delegationrecord-fields">DelegationRecord Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>parent</code></td><td><code>String</code></td><td>Delegating (parent) agent</td></tr>
<tr><td><code>child</code></td><td><code>String</code></td><td>Receiving (child) agent</td></tr>
<tr><td><code>secrets</code></td><td><code>Vec&lt;String&gt;</code></td><td>Secret names delegated</td></tr>
<tr><td><code>max_permission</code></td><td><code>Permission</code></td><td>Ceiling permission level</td></tr>
<tr><td><code>ttl_ms</code></td><td><code>Option&lt;i64&gt;</code></td><td>Optional TTL in milliseconds</td></tr>
<tr><td><code>created_at_ms</code></td><td><code>i64</code></td><td>Creation timestamp (unix ms)</td></tr>
<tr><td><code>delegation_depth</code></td><td><code>u32</code></td><td>Hops from root to this child</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Delegation creates graph edges with ceiling enforcement
vault.delegate(
    "user:alice",   // parent
    "agent:deploy", // child
    &amp;["db/password", "api/key"],
    Permission::Read,
    Some(3_600_000), // 1-hour TTL
)?;

// Cascading revocation removes agent:deploy and all its children
vault.revoke_delegation_cascading("user:alice", "agent:deploy")?;
<span class="boring">}</span></code></pre></pre>
<p>Delegation composes with attenuation: the effective permission is
the minimum of the delegation ceiling and the attenuated permission
at the child’s graph distance.</p>
<h2 id="anomaly-detection"><a class="header" href="#anomaly-detection">Anomaly Detection</a></h2>
<p>The vault monitors per-agent behavior in real time and flags
suspicious patterns. The <code>AnomalyMonitor</code> is non-blocking; it
records events but does not deny access.</p>
<h3 id="anomalythresholds"><a class="header" href="#anomalythresholds">AnomalyThresholds</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>frequency_spike_limit</code></td><td><code>u64</code></td><td>50</td><td>Ops per window that trigger a spike</td></tr>
<tr><td><code>frequency_window_ms</code></td><td><code>i64</code></td><td>60,000</td><td>Sliding window size (1 minute)</td></tr>
<tr><td><code>bulk_operation_threshold</code></td><td><code>u64</code></td><td>10</td><td>Burst size that triggers a bulk event</td></tr>
<tr><td><code>inactive_threshold_ms</code></td><td><code>i64</code></td><td>86,400,000</td><td>Inactivity before resumption is flagged (24h)</td></tr>
</tbody></table>
</div>
<h3 id="anomalyevent-variants"><a class="header" href="#anomalyevent-variants">AnomalyEvent Variants</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Trigger</th></tr></thead><tbody>
<tr><td><code>FirstSecretAccess</code></td><td>Entity accesses a secret it has never accessed before</td></tr>
<tr><td><code>FrequencySpike</code></td><td>Operations in window exceed <code>frequency_spike_limit</code></td></tr>
<tr><td><code>BulkOperation</code></td><td>Burst of operations exceeds <code>bulk_operation_threshold</code></td></tr>
<tr><td><code>InactiveAgentResumed</code></td><td>Entity resumes after <code>inactive_threshold_ms</code> of silence</td></tr>
</tbody></table>
</div>
<h3 id="agentprofile"><a class="header" href="#agentprofile">AgentProfile</a></h3>
<p>Each entity accumulates an <code>AgentProfile</code> containing:</p>
<ul>
<li>Set of known (obfuscated) secret keys accessed</li>
<li>Per-secret access counts</li>
<li>Timestamp of most recent operation</li>
<li>Total lifetime operation count</li>
<li>Recent timestamps for sliding-window frequency analysis</li>
</ul>
<p>Profiles are persisted to <code>TensorStore</code> and survive vault restarts.</p>
<h2 id="storage-format"><a class="header" href="#storage-format">Storage Format</a></h2>
<p>Secrets use a two-tier storage model for security:</p>
<h3 id="metadata-tensor"><a class="header" href="#metadata-tensor">Metadata Tensor</a></h3>
<p>Storage key: <code>_vk:{HMAC(key)}</code> (key name obfuscated via HMAC-BLAKE2b)</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_blob</code></td><td>Pointer</td><td>Reference to current version ciphertext blob</td></tr>
<tr><td><code>_nonce</code></td><td>Bytes</td><td>12-byte encryption nonce for current version</td></tr>
<tr><td><code>_versions</code></td><td>Pointers</td><td>List of all version blob keys (oldest first)</td></tr>
<tr><td><code>_key_enc</code></td><td>Bytes</td><td>AES-GCM encrypted original key name</td></tr>
<tr><td><code>_key_nonce</code></td><td>Bytes</td><td>Nonce for key encryption</td></tr>
<tr><td><code>_creator_obf</code></td><td>Bytes</td><td>AEAD-encrypted creator (nonce prepended)</td></tr>
<tr><td><code>_created_obf</code></td><td>Bytes</td><td>AEAD-encrypted timestamp (nonce prepended)</td></tr>
<tr><td><code>_rotator_obf</code></td><td>Bytes</td><td>AEAD-encrypted last rotator (optional)</td></tr>
<tr><td><code>_rotated_obf</code></td><td>Bytes</td><td>AEAD-encrypted last rotation timestamp (optional)</td></tr>
</tbody></table>
</div>
<h3 id="ciphertext-blob"><a class="header" href="#ciphertext-blob">Ciphertext Blob</a></h3>
<p>Storage key: <code>_vs:{HMAC(key, nonce)}</code> (random-looking storage ID)</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_data</code></td><td>Bytes</td><td>Padded + encrypted secret</td></tr>
<tr><td><code>_nonce</code></td><td>Bytes</td><td>12-byte encryption nonce</td></tr>
<tr><td><code>_ts</code></td><td>Int</td><td>Unix timestamp (seconds) when version was created</td></tr>
</tbody></table>
</div>
<h3 id="storage-key-structure"><a class="header" href="#storage-key-structure">Storage Key Structure</a></h3>
<pre><code class="language-text">_vault:salt          - Persisted 16-byte salt for key derivation
_vk:&lt;32-hex-chars&gt;   - Metadata tensor (HMAC of secret key)
_vs:&lt;24-hex-chars&gt;   - Ciphertext blob (HMAC of key + nonce)
_va:&lt;timestamp&gt;:&lt;counter&gt; - Audit log entries
_vault_ttl_grants    - Persisted TTL grants (JSON)
vault_secret:&lt;32-hex-chars&gt; - Secret node for graph access control
</code></pre>
<h2 id="encryption"><a class="header" href="#encryption">Encryption</a></h2>
<h3 id="key-derivation"><a class="header" href="#key-derivation">Key Derivation</a></h3>
<p>Master key derived using Argon2id with HKDF-based subkey separation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From key.rs - Argon2id parameters
pub const SALT_SIZE: usize = 16;  // 128-bit salt
pub const KEY_SIZE: usize = 32;   // 256-bit key (AES-256)

// Default VaultConfig values:
// argon2_memory_cost: 65536 (64 MiB)
// argon2_time_cost: 3 (iterations)
// argon2_parallelism: 4 (threads)

// Argon2id configuration
let params = Params::new(
    config.argon2_memory_cost,  // Memory in KiB
    config.argon2_time_cost,    // Iterations
    config.argon2_parallelism,  // Parallelism
    Some(KEY_SIZE),             // Output length
)?;

let argon2 = Argon2::new(Algorithm::Argon2id, Version::V0x13, params);
argon2.hash_password_into(input, salt, &amp;mut key)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Argon2id Security Properties</strong>:</p>
<ul>
<li>Hybrid algorithm: Argon2i (side-channel resistant) + Argon2d (GPU resistant)</li>
<li>Memory-hard: Requires 64 MiB by default, defeating GPU/ASIC attacks</li>
<li>Time-hard: 3 iterations increase computation time</li>
<li>Parallelism: 4 threads to utilize modern CPUs</li>
</ul>
<h3 id="hkdf-subkey-derivation"><a class="header" href="#hkdf-subkey-derivation">HKDF Subkey Derivation</a></h3>
<p>Each purpose gets a cryptographically independent key via HKDF-SHA256:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From key.rs - Domain-separated subkeys
impl MasterKey {
    pub fn derive_subkey(&amp;self, domain: &amp;[u8]) -&gt; [u8; KEY_SIZE] {
        let hk = Hkdf::&lt;Sha256&gt;::new(None, &amp;self.bytes);
        let mut output = [0u8; KEY_SIZE];
        hk.expand(domain, &amp;mut output)
            .expect("HKDF expand cannot fail for 32 bytes");
        output
    }

    pub fn encryption_key(&amp;self) -&gt; [u8; KEY_SIZE] {
        self.derive_subkey(b"neumann_vault_encryption_v1")
    }

    pub fn obfuscation_key(&amp;self) -&gt; [u8; KEY_SIZE] {
        self.derive_subkey(b"neumann_vault_obfuscation_v1")
    }

    pub fn metadata_key(&amp;self) -&gt; [u8; KEY_SIZE] {
        self.derive_subkey(b"neumann_vault_metadata_v1")
    }

    pub fn audit_key(&amp;self) -&gt; [u8; KEY_SIZE] {
        self.derive_subkey(b"neumann_vault_audit_v1")
    }

    pub fn transit_key(&amp;self) -&gt; [u8; KEY_SIZE] {
        self.derive_subkey(b"neumann_vault_transit_v1")
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Hierarchy</strong>:</p>
<pre><code class="language-text">Master Password + Salt
        │
        ▼ Argon2id
    MasterKey (32 bytes)
        │
        ├──▶ HKDF("encryption_v1")  ──▶ AES-256-GCM key (secret data)
        ├──▶ HKDF("obfuscation_v1") ──▶ HMAC-BLAKE2b key (key names)
        ├──▶ HKDF("metadata_v1")    ──▶ AES-256-GCM key (metadata)
        ├──▶ HKDF("audit_v1")       ──▶ HMAC + AES-256-GCM key (audit)
        └──▶ HKDF("transit_v1")     ──▶ AES-256-GCM key (transit encryption)
</code></pre>
<p>Each subkey is cryptographically independent via HKDF domain separation.
Compromising one subkey does not reveal any other.</p>
<h3 id="salt-persistence"><a class="header" href="#salt-persistence">Salt Persistence</a></h3>
<p>The vault automatically manages salt persistence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From lib.rs - Salt handling on vault creation
pub fn new(master_key: &amp;[u8], graph: Arc&lt;GraphEngine&gt;, store: TensorStore, config: VaultConfig) -&gt; Result&lt;Self&gt; {
    let derived = if config.salt.is_some() {
        // Explicit salt provided - use it directly
        let (key, _) = MasterKey::derive(master_key, &amp;config)?;
        key
    } else if let Some(persisted_salt) = Self::load_salt(&amp;store) {
        // Use persisted salt for consistency across reopens
        MasterKey::derive_with_salt(master_key, &amp;persisted_salt, &amp;config)?
    } else {
        // Generate new random salt and persist it
        let (key, new_salt) = MasterKey::derive(master_key, &amp;config)?;
        Self::save_salt(&amp;store, new_salt)?;
        key
    };
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="encryption-process"><a class="header" href="#encryption-process">Encryption Process</a></h3>
<ol>
<li>Pad plaintext to fixed bucket size (256B, 1KB, 4KB, 16KB, 32KB, or 64KB)</li>
<li>Generate random 12-byte nonce</li>
<li>Encrypt with AES-256-GCM</li>
<li>Store ciphertext and nonce separately</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From encryption.rs
pub const NONCE_SIZE: usize = 12;  // 96-bit nonce (AES-GCM standard)

impl Cipher {
    pub fn encrypt(&amp;self, plaintext: &amp;[u8]) -&gt; Result&lt;(Vec&lt;u8&gt;, [u8; NONCE_SIZE])&gt; {
        let cipher = Aes256Gcm::new_from_slice(self.key.as_bytes())?;

        // Generate random nonce - CRITICAL for security
        let mut nonce_bytes = [0u8; NONCE_SIZE];
        rand::thread_rng().fill_bytes(&amp;mut nonce_bytes);
        let nonce = Nonce::from_slice(&amp;nonce_bytes);

        // AES-GCM provides authenticated encryption
        // Output: ciphertext || 16-byte authentication tag
        let ciphertext = cipher.encrypt(nonce, plaintext)?;

        Ok((ciphertext, nonce_bytes))
    }

    pub fn decrypt(&amp;self, ciphertext: &amp;[u8], nonce_bytes: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        if nonce_bytes.len() != NONCE_SIZE {
            return Err(VaultError::CryptoError("Invalid nonce size"));
        }

        let cipher = Aes256Gcm::new_from_slice(self.key.as_bytes())?;
        let nonce = Nonce::from_slice(nonce_bytes);

        // Decryption verifies authentication tag
        // Fails if ciphertext was tampered
        cipher.decrypt(nonce, ciphertext)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>AES-256-GCM Security Properties</strong>:</p>
<ul>
<li>Authenticated encryption: Detects tampering via 128-bit authentication tag</li>
<li>Nonce requirement: Each encryption MUST use a unique nonce</li>
<li>Ciphertext expansion: 16 bytes larger than plaintext (auth tag)</li>
</ul>
<h3 id="obfuscation-layers"><a class="header" href="#obfuscation-layers">Obfuscation Layers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Layer</th><th>Purpose</th><th>Implementation</th></tr></thead><tbody>
<tr><td>Key Obfuscation</td><td>Hide secret names</td><td>HMAC-BLAKE2b hash of key name</td></tr>
<tr><td>Pointer Indirection</td><td>Hide storage patterns</td><td>Ciphertext in separate blob with random-looking key</td></tr>
<tr><td>Length Padding</td><td>Hide plaintext size</td><td>Pad to fixed bucket sizes</td></tr>
<tr><td>Metadata Encryption</td><td>Hide creator/timestamps</td><td>AES-GCM with per-record random nonces</td></tr>
<tr><td>Blind Indexes</td><td>Searchable encryption</td><td>HMAC-based indexes for pattern matching</td></tr>
</tbody></table>
</div>
<h3 id="padding-bucket-sizes"><a class="header" href="#padding-bucket-sizes">Padding Bucket Sizes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From obfuscation.rs
pub enum PaddingSize {
    Small = 256,        // API keys, tokens
    Medium = 1024,      // Certificates, small configs
    Large = 4096,       // Private keys, large configs
    ExtraLarge = 16384, // Very large secrets
    Huge = 32768,       // Oversized secrets
    Maximum = 65536,    // Maximum supported
}

// Bucket selection (includes 4-byte length prefix + 1 byte min padding)
pub fn for_length(len: usize) -&gt; Option&lt;Self&gt; {
    let min_required = len + 5;  // length prefix + min padding

    if min_required &lt;= 256 { Some(Small) }
    else if min_required &lt;= 1024 { Some(Medium) }
    else if min_required &lt;= 4096 { Some(Large) }
    else if min_required &lt;= 16384 { Some(ExtraLarge) }
    else if min_required &lt;= 32768 { Some(Huge) }
    else if min_required &lt;= 65536 { Some(Maximum) }
    else { None }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="padding-format"><a class="header" href="#padding-format">Padding Format</a></h3>
<pre><code class="language-text">+----------------+-------------------+------------------+
| Length (4B LE) | Plaintext (N B)   | Random Padding   |
+----------------+-------------------+------------------+
|&lt;--------------- Bucket Size (256/1K/4K/...) --------&gt;|
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From obfuscation.rs
pub fn pad_plaintext(plaintext: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let target_size = PaddingSize::for_length(plaintext.len())? as usize;
    let padding_len = target_size - 4 - plaintext.len();  // 4 = length prefix

    let mut padded = Vec::with_capacity(target_size);

    // Store original length as u32 little-endian
    let len_bytes = (plaintext.len() as u32).to_le_bytes();
    padded.extend_from_slice(&amp;len_bytes);

    // Original data
    padded.extend_from_slice(plaintext);

    // Random padding (not zeros - prevents padding oracle attacks)
    let mut rng_bytes = vec![0u8; padding_len];
    rand::thread_rng().fill_bytes(&amp;mut rng_bytes);
    padded.extend_from_slice(&amp;rng_bytes);

    Ok(padded)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="hmac-blake2b-construction"><a class="header" href="#hmac-blake2b-construction">HMAC-BLAKE2b Construction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From obfuscation.rs - HMAC construction for key obfuscation
fn hmac_hash(&amp;self, data: &amp;[u8], domain: &amp;[u8]) -&gt; [u8; 32] {
    // Inner hash: H((key XOR ipad) || domain || data)
    let mut inner_key = self.obfuscation_key;
    for byte in &amp;mut inner_key {
        *byte ^= 0x36;  // ipad
    }
    let mut inner_hasher = Blake2b::&lt;U32&gt;::new();
    inner_hasher.update(inner_key);
    inner_hasher.update(domain);
    inner_hasher.update(data);
    let inner_hash = inner_hasher.finalize();

    // Outer hash: H((key XOR opad) || inner_hash)
    let mut outer_key = self.obfuscation_key;
    for byte in &amp;mut outer_key {
        *byte ^= 0x5c;  // opad
    }
    let mut outer_hasher = Blake2b::&lt;U32&gt;::new();
    outer_hasher.update(outer_key);
    outer_hasher.update(inner_hash);

    outer_hasher.finalize().into()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="metadata-aead-encryption"><a class="header" href="#metadata-aead-encryption">Metadata AEAD Encryption</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From obfuscation.rs - Per-record AEAD encryption
pub fn encrypt_metadata(&amp;self, data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let cipher = Aes256Gcm::new_from_slice(&amp;self.metadata_key)?;

    // Random nonce for each encryption
    let mut nonce_bytes = [0u8; 12];
    rand::thread_rng().fill_bytes(&amp;mut nonce_bytes);
    let nonce = Nonce::from_slice(&amp;nonce_bytes);

    let ciphertext = cipher.encrypt(nonce, data)?;

    // Format: nonce || ciphertext
    let mut result = Vec::with_capacity(12 + ciphertext.len());
    result.extend_from_slice(&amp;nonce_bytes);
    result.extend(ciphertext);
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h2>
<p>Rate limiting uses a sliding window algorithm to prevent brute-force attacks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From rate_limit.rs
pub struct RateLimiter {
    // (entity, operation) -&gt; timestamps of recent requests
    history: DashMap&lt;(String, String), VecDeque&lt;Instant&gt;&gt;,
    config: RateLimitConfig,
}

impl RateLimiter {
    pub fn check_and_record(&amp;self, entity: &amp;str, op: Operation) -&gt; Result&lt;(), String&gt; {
        let limit = op.limit(&amp;self.config);
        if limit == u32::MAX {
            return Ok(());  // Unlimited
        }

        let key = (entity.to_string(), op.as_str().to_string());
        let now = Instant::now();
        let window_start = now - self.config.window;

        let mut entry = self.history.entry(key).or_default();
        let timestamps = entry.value_mut();

        // Remove expired entries outside window
        while let Some(front) = timestamps.front() {
            if *front &lt; window_start {
                timestamps.pop_front();
            } else {
                break;
            }
        }

        let count = timestamps.len() as u32;
        if count &gt;= limit {
            Err(format!("Rate limit exceeded: {} {} calls in {:?}", count, op, self.config.window))
        } else {
            timestamps.push_back(now);  // Record this request
            Ok(())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sliding-window-visualization"><a class="header" href="#sliding-window-visualization">Sliding Window Visualization</a></h3>
<pre><code class="language-text">Window: 60 seconds
Limit: 5 requests

Timeline:
|--[req1]--[req2]---[req3]--[req4]---[req5]---|
|&lt;------------------ Window -----------------&gt;|
                                               ^
                                               Now (6th request blocked)

After 10 seconds:
                    |--[req2]---[req3]--[req4]---[req5]---|
   [req1] expired   |&lt;------------------ Window ---------&gt;|
                                                           ^
                                                           Now (6th request allowed)
</code></pre>
<h3 id="rate-limit-configuration-presets"><a class="header" href="#rate-limit-configuration-presets">Rate Limit Configuration Presets</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default configuration
impl Default for RateLimitConfig {
    fn default() -&gt; Self {
        Self {
            max_gets: 60,    // 60 get() calls per minute
            max_lists: 10,   // 10 list() calls per minute
            max_sets: 30,    // 30 set() calls per minute
            max_grants: 20,  // 20 grant() calls per minute
            window: Duration::from_secs(60),
        }
    }
}

// Strict configuration for testing
pub fn strict() -&gt; Self {
    Self {
        max_gets: 5,
        max_lists: 2,
        max_sets: 3,
        max_grants: 2,
        window: Duration::from_secs(60),
    }
}

// No rate limiting
pub fn unlimited() -&gt; Self {
    Self {
        max_gets: u32::MAX,
        max_lists: u32::MAX,
        max_sets: u32::MAX,
        max_grants: u32::MAX,
        window: Duration::from_secs(60),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Note</strong>: <code>node:root</code> is exempt from rate limiting.</p>
<h2 id="ttl-grant-tracking"><a class="header" href="#ttl-grant-tracking">TTL Grant Tracking</a></h2>
<p>TTL grants use a min-heap for efficient expiration tracking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From ttl.rs
pub struct GrantTTLTracker {
    // Priority queue of expiration times (min-heap)
    heap: Mutex&lt;BinaryHeap&lt;GrantTTLEntry&gt;&gt;,
}

struct GrantTTLEntry {
    expires_at: Instant,
    entity: String,
    secret_key: String,
}

// Reverse ordering for min-heap (earliest expiration first)
impl Ord for GrantTTLEntry {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        other.expires_at.cmp(&amp;self.expires_at)  // Reversed!
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ttl-operations"><a class="header" href="#ttl-operations">TTL Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add a grant with TTL
pub fn add(&amp;self, entity: &amp;str, secret_key: &amp;str, ttl: Duration) {
    let entry = GrantTTLEntry {
        expires_at: Instant::now() + ttl,
        entity: entity.to_string(),
        secret_key: secret_key.to_string(),
    };
    self.heap.lock().unwrap().push(entry);
}

// Efficient expiration check - O(1) to peek, O(log n) to pop
pub fn get_expired(&amp;self) -&gt; Vec&lt;(String, String)&gt; {
    let now = Instant::now();
    let mut expired = Vec::new();
    let mut heap = self.heap.lock().unwrap();

    // Pop all expired entries (they're at the top due to min-heap)
    while let Some(entry) = heap.peek() {
        if entry.expires_at &lt;= now {
            if let Some(entry) = heap.pop() {
                expired.push((entry.entity, entry.secret_key));
            }
        } else {
            break;  // No more expired entries
        }
    }

    expired
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ttl-persistence"><a class="header" href="#ttl-persistence">TTL Persistence</a></h3>
<p>TTL grants survive vault restarts via TensorStore persistence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From ttl.rs
const TTL_STORAGE_KEY: &amp;str = "_vault_ttl_grants";

#[derive(Serialize, Deserialize)]
pub struct PersistedGrant {
    pub expires_at_ms: i64,  // Unix timestamp
    pub entity: String,
    pub secret_key: String,
}

pub fn persist(&amp;self, store: &amp;TensorStore) -&gt; Result&lt;()&gt; {
    let grants: Vec&lt;PersistedGrant&gt; = self.heap.lock().unwrap()
        .iter()
        .map(|e| PersistedGrant {
            expires_at_ms: instant_to_unix_ms(e.expires_at),
            entity: e.entity.clone(),
            secret_key: e.secret_key.clone(),
        })
        .collect();

    let data = serde_json::to_vec(&amp;grants)?;
    store.put(TTL_STORAGE_KEY, tensor_with_bytes(data))?;
    Ok(())
}

pub fn load(store: &amp;TensorStore) -&gt; Result&lt;Self&gt; {
    let tracker = Self::new();
    let grants: Vec&lt;PersistedGrant&gt; = load_from_store(store)?;

    for grant in grants {
        // Skip already expired grants
        if !grant.is_expired() {
            tracker.add_with_expiration(
                &amp;grant.entity,
                &amp;grant.secret_key,
                unix_ms_to_instant(grant.expires_at_ms),
            );
        }
    }

    Ok(tracker)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cleanup-strategy"><a class="header" href="#cleanup-strategy">Cleanup Strategy</a></h3>
<p>Expired grants are cleaned up opportunistically during <code>get()</code> operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From lib.rs
pub fn get(&amp;self, requester: &amp;str, key: &amp;str) -&gt; Result&lt;String&gt; {
    // Opportunistic cleanup of expired grants
    self.cleanup_expired_grants();

    // ... rest of get operation
}

pub fn cleanup_expired_grants(&amp;self) -&gt; usize {
    let expired = self.ttl_tracker.get_expired();
    let mut revoked = 0;

    for (entity, key) in expired {
        let secret_node = self.secret_node_key(&amp;key);

        // Delete the VAULT_ACCESS_* edge
        if let Ok(edges) = self.graph.get_entity_outgoing(&amp;entity) {
            for edge_key in edges {
                if let Ok((_, to, edge_type, _)) = self.graph.get_entity_edge(&amp;edge_key) {
                    if to == secret_node &amp;&amp; edge_type.starts_with("VAULT_ACCESS") {
                        if self.graph.delete_entity_edge(&amp;edge_key).is_ok() {
                            revoked += 1;
                        }
                    }
                }
            }
        }
    }

    revoked
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h2>
<h3 id="keyed-vs-legacy-mode"><a class="header" href="#keyed-vs-legacy-mode">Keyed vs Legacy Mode</a></h3>
<p>The audit log supports two modes:</p>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>Audit Key</th><th>Entity/Target</th><th>Integrity</th></tr></thead><tbody>
<tr><td>Legacy (unkeyed)</td><td><code>None</code></td><td>Plaintext</td><td>None</td></tr>
<tr><td>Keyed</td><td><code>Some([u8; 32])</code></td><td>AEAD-encrypted</td><td>HMAC per entry</td></tr>
</tbody></table>
</div>
<p>When an <code>audit_key</code> is provided (derived from <code>MasterKey::audit_key()</code>),
each entry gets:</p>
<ul>
<li><strong><code>_entity_enc</code> / <code>_target_enc</code></strong>: AES-256-GCM encrypted entity and
target fields (nonce prepended). Prevents casual log readers from
learning who accessed what.</li>
<li><strong><code>_hmac</code></strong>: HMAC-BLAKE2b over the full entry. Any modification
(timestamp, operation, entity) is detected on read.</li>
<li><strong><code>_audit_epoch</code></strong>: Key rotation counter. Entries from a previous
epoch are still readable during transition but flagged as stale.</li>
</ul>
<h3 id="audit-entry-storage"><a class="header" href="#audit-entry-storage">Audit Entry Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From audit.rs
const AUDIT_PREFIX: &amp;str = "_va:";
static AUDIT_COUNTER: AtomicU64 = AtomicU64::new(0);

pub fn record(
    &amp;self,
    entity: &amp;str,
    secret_key: &amp;str,
    operation: &amp;AuditOperation,
) {
    let timestamp = now_millis();
    let counter = AUDIT_COUNTER.fetch_add(1, Ordering::SeqCst);
    let key = format!("{AUDIT_PREFIX}{timestamp}:{counter}");

    let mut tensor = TensorData::new();
    tensor.set("_entity", entity);
    tensor.set("_secret", secret_key);
    tensor.set("_op", operation.as_str());
    tensor.set("_ts", timestamp);

    // Additional fields for grant/revoke
    match operation {
        AuditOperation::Grant { to, permission } =&gt; {
            tensor.set("_target", to);
            tensor.set("_permission", permission);
        }
        AuditOperation::Revoke { from } =&gt; {
            tensor.set("_target", from);
        }
        _ =&gt; {}
    }

    // In keyed mode: encrypt entity/target with AEAD,
    // compute HMAC over all fields, attach epoch counter

    let _ = self.store.put(&amp;key, tensor);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="audit-query-methods"><a class="header" href="#audit-query-methods">Audit Query Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>Time Complexity</th></tr></thead><tbody>
<tr><td><code>by_secret(key)</code></td><td>All entries for a secret</td><td>O(n) scan + filter</td></tr>
<tr><td><code>by_entity(entity)</code></td><td>All entries by requester</td><td>O(n) scan + filter</td></tr>
<tr><td><code>since(timestamp)</code></td><td>Entries since timestamp</td><td>O(n) scan + filter</td></tr>
<tr><td><code>between(start, end)</code></td><td>Entries in time range</td><td>O(n) scan + filter</td></tr>
<tr><td><code>recent(limit)</code></td><td>Last N entries</td><td>O(n log n) sort + truncate</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: Secret keys are obfuscated in audit logs to prevent leaking
plaintext names. In keyed mode, entity and target fields are
additionally encrypted with AEAD.</p>
<h2 id="transit-encryption"><a class="header" href="#transit-encryption">Transit Encryption</a></h2>
<p>Transit encryption provides encrypt-as-a-service: agents can encrypt
data using a vault-managed key without ever seeing the key material.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Encrypt data for storage outside the vault
let sealed = vault.encrypt_for("user:alice", "db/password", b"plaintext")?;

// Later, decrypt it
let plaintext = vault.decrypt_as("user:alice", "db/password", &amp;sealed)?;
<span class="boring">}</span></code></pre></pre>
<p>Transit encryption uses a dedicated <code>transit_key</code> subkey, separate
from the secret-encryption key. The caller must have at least Read
permission on the referenced secret. This enables use cases like
encrypting application data at rest without storing it in the vault.</p>
<h2 id="secret-expiration"><a class="header" href="#secret-expiration">Secret Expiration</a></h2>
<p>Secrets themselves can have a TTL, distinct from grant TTLs. When a
secret expires, any <code>get()</code> call returns <code>SecretExpired</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Duration;

// Store a secret that expires in 24 hours
vault.set_with_ttl(
    Vault::ROOT,
    "temp/token",
    "abc123",
    Duration::from_secs(86400),
)?;

// Check remaining lifetime
let expires_at = vault.get_expiration(Vault::ROOT, "temp/token")?;

// Remove expiration (make permanent)
vault.clear_expiration(Vault::ROOT, "temp/token")?;
<span class="boring">}</span></code></pre></pre>
<p>Secret expiration is enforced on read. The ciphertext remains in
storage until explicitly deleted or overwritten.</p>
<h2 id="break-glass-emergency-access"><a class="header" href="#break-glass-emergency-access">Break-Glass Emergency Access</a></h2>
<p>Emergency access bypasses the normal graph-based access check for
time-critical scenarios. It is rate-limited, heavily audited, and
auto-expires.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Break-glass: get a secret you don't normally have access to
let value = vault.emergency_access(
    "ops:oncall",
    "prod/db_root",
    "P1 incident INC-4521",
    Duration::from_secs(1800), // 30-minute window
)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Constraints</strong>:</p>
<ul>
<li>Rate-limited to 1 emergency access per rate-limit window</li>
<li>The justification string is recorded in the audit log</li>
<li>Access auto-expires after the specified duration</li>
<li>All break-glass events generate a distinct audit operation</li>
</ul>
<h2 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h2>
<p>Batch operations reduce round-trip overhead for bulk reads and
writes. Both methods acquire locks in sorted key order to prevent
deadlocks.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Read multiple secrets in one call
let results = vault.batch_get("user:alice", &amp;["db/pass", "api/key"])?;
for (key, result) in &amp;results {
    match result {
        Ok(value) =&gt; println!("{key}: {value}"),
        Err(e) =&gt; println!("{key}: {e}"),
    }
}

// Write multiple secrets atomically
vault.batch_set(Vault::ROOT, &amp;[
    ("db/pass", "new_pass"),
    ("api/key", "new_key"),
])?;
<span class="boring">}</span></code></pre></pre>
<p><code>batch_set</code> is atomic: either all writes succeed or none are
applied. <code>batch_get</code> returns per-key results so partial failures
are visible.</p>
<h2 id="master-key-rotation"><a class="header" href="#master-key-rotation">Master Key Rotation</a></h2>
<p><code>rotate_master_key()</code> re-derives all 5 subkeys from a new password
and atomically re-encrypts all secrets, re-signs all graph edges,
and increments the audit epoch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rotate the master password
let mut vault = Vault::new(b"old_password", graph, store, config)?;
let secrets_rotated = vault.rotate_master_key(b"new_password")?;
println!("Re-encrypted {secrets_rotated} secrets");
<span class="boring">}</span></code></pre></pre>
<p>The rotation is atomic: if any re-encryption fails, the vault
reverts to the old key. After rotation, all previously issued
transit ciphertexts become undecryptable (forward secrecy for
transit data).</p>
<h2 id="graph-intelligence"><a class="header" href="#graph-intelligence">Graph Intelligence</a></h2>
<p>The vault includes three tiers of graph-based security analysis,
all operating on the live permission graph.</p>
<h3 id="tier-1--graph-native-features"><a class="header" href="#tier-1--graph-native-features">Tier 1 – Graph-Native Features</a></h3>
<p>These features use the permission graph directly for access
explanation, impact analysis, and structural auditing.</p>
<h4 id="explain_access"><a class="header" href="#explain_access">explain_access</a></h4>
<p>Returns a path-level explanation of why access was granted or
denied, including denial reasons (no path, insufficient permission,
attenuation, tampered edge).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let explanation = vault.explain_access("user:bob", "db/password");
if explanation.granted {
    for path in &amp;explanation.paths {
        for hop in path {
            println!("{} --{}--&gt;", hop.entity, hop.edge_type);
        }
    }
} else if let Some(reason) = &amp;explanation.denial_reason {
    println!("Denied: {reason:?}");
}
<span class="boring">}</span></code></pre></pre>
<h4 id="blast_radius"><a class="header" href="#blast_radius">blast_radius</a></h4>
<p>Computes all secrets reachable by an entity, with permission level
and hop count for each.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let radius = vault.blast_radius("user:alice");
println!("{} can reach {} secrets", radius.entity, radius.total_secrets);
for secret in &amp;radius.secrets {
    println!(
        "  {} ({:?}, {} hops)",
        secret.secret_name, secret.permission, secret.hop_count
    );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="simulate_grant"><a class="header" href="#simulate_grant">simulate_grant</a></h4>
<p>Dry-run a hypothetical grant and see what new access it would
create across the graph, without actually modifying anything.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sim = vault.simulate_grant("user:bob", "db/password", Permission::Write);
println!("{} entities would gain new access", sim.total_affected);
for access in &amp;sim.new_accesses {
    println!("  {} gains {:?} on {}", access.entity, access.permission, access.secret);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="security_audit"><a class="header" href="#security_audit">security_audit</a></h4>
<p>Runs a structural security audit detecting:</p>
<ul>
<li><strong>Cycles</strong>: Strongly connected components in the access graph</li>
<li><strong>Single points of failure</strong>: Entities whose removal disconnects
secrets</li>
<li><strong>Over-privileged entities</strong>: High PageRank with excessive
reachability</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let report = vault.security_audit();
println!("Cycles: {}", report.cycles.len());
println!("SPOFs: {}", report.single_points_of_failure.len());
println!("Over-privileged: {}", report.over_privileged.len());
<span class="boring">}</span></code></pre></pre>
<h4 id="find_critical_entities"><a class="header" href="#find_critical_entities">find_critical_entities</a></h4>
<p>Identifies articulation points in the permission graph –
entities whose removal would isolate secrets from all other
accessors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let critical = vault.find_critical_entities();
for entity in &amp;critical {
    println!(
        "{}: SPOF={}, {} secrets solely dependent, PageRank={:.4}",
        entity.entity,
        entity.is_single_point_of_failure,
        entity.secrets_solely_dependent,
        entity.pagerank_score,
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tier-2--production-features"><a class="header" href="#tier-2--production-features">Tier 2 – Production Features</a></h3>
<p>Transit encryption, secret expiration, break-glass emergency access,
batch operations, and master key rotation are covered in their own
sections above.</p>
<h3 id="tier-3--graph-analytics"><a class="header" href="#tier-3--graph-analytics">Tier 3 – Graph Analytics</a></h3>
<p>These features apply well-known graph algorithms to the permission
topology for deeper security insights.</p>
<h4 id="privilege_analysis"><a class="header" href="#privilege_analysis">privilege_analysis</a></h4>
<p>Uses PageRank to rank entities by influence, combined with
reachability counts to produce a privilege score.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let report = vault.privilege_analysis();
for entity in &amp;report.entities {
    println!(
        "{}: PageRank={:.4}, reachable={}, privilege={:.4}",
        entity.entity,
        entity.pagerank_score,
        entity.reachable_secrets,
        entity.privilege_score,
    );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="delegation_anomaly_scores"><a class="header" href="#delegation_anomaly_scores">delegation_anomaly_scores</a></h4>
<p>Computes Jaccard similarity and Adamic-Adar scores for each
entity-secret delegation edge. Low Jaccard scores indicate
unusual delegations that may warrant review.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scores = vault.delegation_anomaly_scores();
for score in &amp;scores {
    println!(
        "{} -&gt; {}: Jaccard={:.3}, anomaly={:.3}",
        score.entity, score.secret,
        score.jaccard, score.anomaly_score,
    );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="infer_roles"><a class="header" href="#infer_roles">infer_roles</a></h4>
<p>Applies Louvain community detection to discover implicit role
groupings among entities based on shared access patterns.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let roles = vault.infer_roles();
println!("Modularity: {:.4}", roles.modularity);
for role in &amp;roles.roles {
    println!(
        "Role {}: {} members, {} common secrets",
        role.role_id,
        role.members.len(),
        role.common_secrets.len(),
    );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="trust_transitivity"><a class="header" href="#trust_transitivity">trust_transitivity</a></h4>
<p>Counts triangles and computes clustering coefficients to
measure how “tightly knit” trust relationships are. High
clustering suggests robust mutual oversight.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let trust = vault.trust_transitivity();
println!("Global clustering: {:.4}", trust.global_clustering);
println!("Total triangles: {}", trust.total_triangles);
for entity in &amp;trust.entities {
    println!(
        "{}: triangles={}, clustering={:.4}, trust={:.4}",
        entity.entity,
        entity.triangle_count,
        entity.clustering_coefficient,
        entity.trust_score,
    );
}
<span class="boring">}</span></code></pre></pre>
<h4 id="risk_propagation"><a class="header" href="#risk_propagation">risk_propagation</a></h4>
<p>Uses eigenvector centrality to model how risk propagates through
the access graph, weighted by admin reachability.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let risk = vault.risk_propagation();
println!("Max risk: {:.4}", risk.max_risk);
for entity in &amp;risk.entities {
    println!(
        "{}: eigenvector={:.4}, admin_secrets={}, risk={:.4}",
        entity.entity,
        entity.eigenvector_score,
        entity.reachable_admin_secrets,
        entity.risk_score,
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="multi-agent-secret-sharing"><a class="header" href="#multi-agent-secret-sharing">Multi-Agent Secret Sharing</a></h3>
<p>A deployment pipeline has three agents: a CI runner, a deploy agent,
and a monitoring agent. Each needs different access levels to database
credentials.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CI runner needs read-only access to run migrations
vault.grant_with_permission(
    Vault::ROOT, "agent:ci", "db/password", Permission::Read,
)?;

// Deploy agent needs write to rotate credentials
vault.grant_with_permission(
    Vault::ROOT, "agent:deploy", "db/password", Permission::Write,
)?;

// Monitoring agent gets temporary read access
vault.grant_with_ttl(
    Vault::ROOT, "agent:monitor", "db/password",
    Permission::Read, Duration::from_secs(3600),
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="agent-delegation-chains"><a class="header" href="#agent-delegation-chains">Agent Delegation Chains</a></h3>
<p>A team lead delegates a subset of secrets to a deploy agent, which
further delegates to a canary agent. The ceiling model ensures no
agent exceeds its parent’s permissions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Team lead delegates read-only access to deploy agent
vault.delegate(
    "user:lead",
    "agent:deploy",
    &amp;["prod/db", "prod/api_key"],
    Permission::Read,
    None, // no TTL
)?;

// Deploy agent delegates to canary (ceiling: Read)
vault.delegate(
    "agent:deploy",
    "agent:canary",
    &amp;["prod/db"],
    Permission::Read, // cannot exceed parent's Read
    Some(Duration::from_secs(600)), // 10-minute window
)?;

// Revoking deploy agent cascades to canary
vault.revoke_delegation_cascading("user:lead", "agent:deploy")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="security-posture-review"><a class="header" href="#security-posture-review">Security Posture Review</a></h3>
<p>Run periodic security audits to detect over-privileged agents,
single points of failure, and unusual delegation patterns.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find entities with excessive access
let audit = vault.security_audit();
for entity in &amp;audit.over_privileged {
    println!("Over-privileged: {} (PageRank {:.4}, {} secrets)",
        entity.entity, entity.pagerank_score, entity.reachable_secrets);
}

// Detect unusual delegations via Jaccard similarity
let anomalies = vault.delegation_anomaly_scores();
for score in anomalies.iter().filter(|s| s.anomaly_score &gt; 0.8) {
    println!("Unusual delegation: {} -&gt; {} (anomaly {:.2})",
        score.entity, score.secret, score.anomaly_score);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="incident-response"><a class="header" href="#incident-response">Incident Response</a></h3>
<p>During a security incident, use break-glass access to retrieve a
secret you don’t normally have permission to read, with full
audit trail.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = vault.emergency_access(
    "ops:oncall",
    "prod/db_root",
    "P1 incident INC-4521 -- database compromise",
    Duration::from_secs(1800),
)?;
// Access is audited, rate-limited, and auto-expires
<span class="boring">}</span></code></pre></pre>
<h3 id="application-level-encryption"><a class="header" href="#application-level-encryption">Application-Level Encryption</a></h3>
<p>Use transit encryption to protect application data at rest without
storing it in the vault. The application never sees the key.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Encrypt data using a vault-managed key
let sealed = vault.encrypt_for("app:backend", "encryption/key", b"user PII data")?;
// Store `sealed` in application database

// Later, decrypt it
let plaintext = vault.decrypt_as("app:backend", "encryption/key", &amp;sealed)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tensor_vault::{Vault, VaultConfig, Permission};
use graph_engine::GraphEngine;
use tensor_store::TensorStore;
use std::sync::Arc;

// Initialize vault
let graph = Arc::new(GraphEngine::new());
let store = TensorStore::new();
let vault = Vault::new(b"master_password", graph, store, VaultConfig::default())?;

// Store a secret (root only)
vault.set(Vault::ROOT, "api_key", "sk-secret123")?;

// Grant access with permission level
vault.grant_with_permission(Vault::ROOT, "user:alice", "api_key", Permission::Read)?;

// Retrieve secret
let value = vault.get("user:alice", "api_key")?;

// Revoke access
vault.revoke(Vault::ROOT, "user:alice", "api_key")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="permission-based-access"><a class="header" href="#permission-based-access">Permission-Based Access</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Grant different permission levels
vault.grant_with_permission(Vault::ROOT, "user:reader", "secret", Permission::Read)?;
vault.grant_with_permission(Vault::ROOT, "user:writer", "secret", Permission::Write)?;
vault.grant_with_permission(Vault::ROOT, "user:admin", "secret", Permission::Admin)?;

// Reader can only get/list
vault.get("user:reader", "secret")?;  // OK
vault.set("user:reader", "secret", "new")?;  // InsufficientPermission

// Writer can update
vault.rotate("user:writer", "secret", "new_value")?;  // OK
vault.delete("user:writer", "secret")?;  // InsufficientPermission

// Admin can do everything
vault.grant_with_permission("user:admin", "user:new", "secret", Permission::Read)?;  // OK
vault.delete("user:admin", "secret")?;  // OK
<span class="boring">}</span></code></pre></pre>
<h3 id="ttl-grants"><a class="header" href="#ttl-grants">TTL Grants</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Duration;

// Grant temporary access (1 hour)
vault.grant_with_ttl(
    Vault::ROOT,
    "agent:temp",
    "api_key",
    Permission::Read,
    Duration::from_secs(3600),
)?;

// Access works during TTL
vault.get("agent:temp", "api_key")?;  // OK

// After 1 hour, access is automatically revoked
// (cleanup happens opportunistically on next vault operation)
<span class="boring">}</span></code></pre></pre>
<h3 id="namespace-isolation"><a class="header" href="#namespace-isolation">Namespace Isolation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create namespaced vault for multi-tenant isolation
let backend = vault.namespace("team:backend", "user:alice");
let frontend = vault.namespace("team:frontend", "user:bob");

// Keys are automatically prefixed
backend.set("db_password", "secret1")?;   // Stored as "team:backend:db_password"
frontend.set("api_key", "secret2")?;      // Stored as "team:frontend:api_key"

// Cross-namespace access blocked
frontend.get("db_password")?;  // AccessDenied
<span class="boring">}</span></code></pre></pre>
<h3 id="secret-versioning"><a class="header" href="#secret-versioning">Secret Versioning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Each set/rotate creates a new version
vault.set(Vault::ROOT, "api_key", "v1")?;
vault.rotate(Vault::ROOT, "api_key", "v2")?;
vault.rotate(Vault::ROOT, "api_key", "v3")?;

// Get version info
let version = vault.current_version(Vault::ROOT, "api_key")?;  // 3
let versions = vault.list_versions(Vault::ROOT, "api_key")?;
// [VersionInfo { version: 1, created_at: ... }, ...]

// Get specific version
let old_value = vault.get_version(Vault::ROOT, "api_key", 1)?;  // "v1"

// Rollback (creates new version with old content)
vault.rollback(Vault::ROOT, "api_key", 1)?;
vault.get(Vault::ROOT, "api_key")?;  // "v1"
vault.current_version(Vault::ROOT, "api_key")?;  // 4 (rollback creates new version)
<span class="boring">}</span></code></pre></pre>
<h3 id="audit-queries"><a class="header" href="#audit-queries">Audit Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Query by secret
let entries = vault.audit_log("api_key");

// Query by entity
let alice_actions = vault.audit_by_entity("user:alice");

// Query by time
let recent = vault.audit_since(timestamp_millis);
let last_10 = vault.audit_recent(10);

// Audit entries include operation details
for entry in entries {
    match &amp;entry.operation {
        AuditOperation::Grant { to, permission } =&gt; {
            println!("Granted {} to {} at {}", permission, to, entry.timestamp);
        },
        AuditOperation::Get =&gt; {
            println!("{} read secret at {}", entry.entity, entry.timestamp);
        },
        _ =&gt; {},
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="scoped-vault"><a class="header" href="#scoped-vault">Scoped Vault</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a scoped view for a specific entity
let alice = vault.scope("user:alice");

// All operations use alice as the requester
alice.get("api_key")?;  // Same as vault.get("user:alice", "api_key")
alice.list("*")?;       // Same as vault.list("user:alice", "*")
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="vaultconfig"><a class="header" href="#vaultconfig">VaultConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>salt</code></td><td><code>Option&lt;[u8; 16]&gt;</code></td><td>None</td><td>Salt for key derivation (random if not provided, persisted)</td></tr>
<tr><td><code>argon2_memory_cost</code></td><td><code>u32</code></td><td>65536</td><td>Memory cost in KiB (64MB)</td></tr>
<tr><td><code>argon2_time_cost</code></td><td><code>u32</code></td><td>3</td><td>Iteration count</td></tr>
<tr><td><code>argon2_parallelism</code></td><td><code>u32</code></td><td>4</td><td>Thread count</td></tr>
<tr><td><code>rate_limit</code></td><td><code>Option&lt;RateLimitConfig&gt;</code></td><td>None</td><td>Rate limiting (disabled if None)</td></tr>
<tr><td><code>max_versions</code></td><td><code>usize</code></td><td>5</td><td>Maximum versions to retain per secret</td></tr>
<tr><td><code>attenuation</code></td><td><code>AttenuationPolicy</code></td><td><code>default()</code></td><td>Distance-based permission degradation</td></tr>
<tr><td><code>anomaly_thresholds</code></td><td><code>Option&lt;AnomalyThresholds&gt;</code></td><td>None</td><td>Anomaly detection config (default thresholds if None)</td></tr>
<tr><td><code>max_delegation_depth</code></td><td><code>Option&lt;u32&gt;</code></td><td>None</td><td>Maximum delegation chain depth (default 3)</td></tr>
</tbody></table>
</div>
<p>VaultConfig supports a builder pattern for ergonomic construction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = VaultConfig::default()
    .with_rate_limit(RateLimitConfig::default())
    .with_attenuation(AttenuationPolicy {
        admin_limit: 1,
        write_limit: 2,
        horizon: 5,
    })
    .with_anomaly_thresholds(AnomalyThresholds {
        frequency_spike_limit: 100,
        ..AnomalyThresholds::default()
    })
    .with_max_delegation_depth(4);
<span class="boring">}</span></code></pre></pre>
<h3 id="ratelimitconfig"><a class="header" href="#ratelimitconfig">RateLimitConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>max_gets</code></td><td><code>u32</code></td><td>60</td><td>Maximum get() calls per window</td></tr>
<tr><td><code>max_lists</code></td><td><code>u32</code></td><td>10</td><td>Maximum list() calls per window</td></tr>
<tr><td><code>max_sets</code></td><td><code>u32</code></td><td>30</td><td>Maximum set() calls per window</td></tr>
<tr><td><code>max_grants</code></td><td><code>u32</code></td><td>20</td><td>Maximum grant() calls per window</td></tr>
<tr><td><code>window</code></td><td><code>Duration</code></td><td>60s</td><td>Sliding window duration</td></tr>
</tbody></table>
</div>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NEUMANN_VAULT_KEY</code></td><td>Base64-encoded 32-byte master key</td></tr>
</tbody></table>
</div>
<h2 id="shell-commands"><a class="header" href="#shell-commands">Shell Commands</a></h2>
<h3 id="core-operations"><a class="header" href="#core-operations">Core Operations</a></h3>
<pre><code class="language-text">VAULT INIT                              Initialize vault from NEUMANN_VAULT_KEY
VAULT IDENTITY 'node:alice'             Set current identity
VAULT NAMESPACE 'team:backend'          Set current namespace

VAULT SET 'api_key' 'sk-123'            Store encrypted secret
VAULT GET 'api_key'                     Retrieve secret
VAULT GET 'api_key' VERSION 2           Get specific version
VAULT DELETE 'api_key'                  Delete secret
VAULT LIST 'prefix:*'                   List accessible secrets
VAULT ROTATE 'api_key' 'new'            Rotate secret value
VAULT VERSIONS 'api_key'                List version history
VAULT ROLLBACK 'api_key' VERSION 2      Rollback to version
</code></pre>
<h3 id="access-control"><a class="header" href="#access-control">Access Control</a></h3>
<pre><code class="language-text">VAULT GRANT 'user:bob' ON 'api_key'              Grant admin access
VAULT GRANT 'user:bob' ON 'api_key' READ         Grant read-only access
VAULT GRANT 'user:bob' ON 'api_key' WRITE        Grant write access
VAULT GRANT 'user:bob' ON 'api_key' TTL 3600     Grant with 1-hour expiry
VAULT REVOKE 'user:bob' ON 'api_key'             Revoke access
</code></pre>
<h3 id="audit"><a class="header" href="#audit">Audit</a></h3>
<pre><code class="language-text">VAULT AUDIT 'api_key'                   View audit log for secret
VAULT AUDIT BY 'user:alice'             View audit log for entity
VAULT AUDIT RECENT 10                   View last 10 operations
</code></pre>
<h3 id="rust-api-only"><a class="header" href="#rust-api-only">Rust API Only</a></h3>
<p>The following features are available through the Rust API but do not
yet have shell command equivalents:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>API Method</th></tr></thead><tbody>
<tr><td>Delegation</td><td><code>vault.delegate()</code>, <code>vault.revoke_delegation()</code></td></tr>
<tr><td>Transit encryption</td><td><code>vault.encrypt_for()</code>, <code>vault.decrypt_as()</code></td></tr>
<tr><td>Secret expiration</td><td><code>vault.set_with_ttl()</code>, <code>vault.get_expiration()</code></td></tr>
<tr><td>Break-glass</td><td><code>vault.emergency_access()</code></td></tr>
<tr><td>Batch operations</td><td><code>vault.batch_get()</code>, <code>vault.batch_set()</code></td></tr>
<tr><td>Key rotation</td><td><code>vault.rotate_master_key()</code></td></tr>
<tr><td>Access explanation</td><td><code>vault.explain_access()</code></td></tr>
<tr><td>Blast radius</td><td><code>vault.blast_radius()</code></td></tr>
<tr><td>Grant simulation</td><td><code>vault.simulate_grant()</code></td></tr>
<tr><td>Security audit</td><td><code>vault.security_audit()</code></td></tr>
<tr><td>Critical entities</td><td><code>vault.find_critical_entities()</code></td></tr>
<tr><td>Privilege analysis</td><td><code>vault.privilege_analysis()</code></td></tr>
<tr><td>Delegation anomalies</td><td><code>vault.delegation_anomaly_scores()</code></td></tr>
<tr><td>Role inference</td><td><code>vault.infer_roles()</code></td></tr>
<tr><td>Trust transitivity</td><td><code>vault.trust_transitivity()</code></td></tr>
<tr><td>Risk propagation</td><td><code>vault.risk_propagation()</code></td></tr>
</tbody></table>
</div>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ol>
<li><strong>Use strong master passwords</strong>: At least 128 bits of entropy</li>
<li><strong>Rotate secrets regularly</strong>: Use <code>rotate()</code> to maintain version history</li>
<li><strong>Rotate the master key periodically</strong>: <code>rotate_master_key()</code> re-encrypts everything</li>
<li><strong>Grant minimal permissions</strong>: Use Read when Write/Admin not needed</li>
<li><strong>Use TTL grants for temporary access</strong>: Prevents forgotten grants</li>
<li><strong>Use delegation instead of direct grants for agents</strong>: Ceiling model limits blast radius</li>
<li><strong>Enable rate limiting in production</strong>: Prevents brute-force attacks</li>
<li><strong>Enable anomaly detection</strong>: Flags suspicious behavioral patterns early</li>
<li><strong>Use namespaces for multi-tenant</strong>: Enforces isolation</li>
<li><strong>Review audit logs and run security_audit()</strong>: Detect cycles, SPOFs, over-privilege</li>
<li><strong>Use explain_access() to debug permission problems</strong>: Shows exact paths and denial reasons</li>
<li><strong>Keep attenuation horizon low</strong>: Limits transitive privilege escalation</li>
</ol>
<h3 id="edge-cases-and-gotchas"><a class="header" href="#edge-cases-and-gotchas">Edge Cases and Gotchas</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Behavior</th></tr></thead><tbody>
<tr><td>Grant to non-existent entity</td><td>Succeeds (edge created, entity may exist later)</td></tr>
<tr><td>Revoke non-existent grant</td><td>Succeeds silently (idempotent)</td></tr>
<tr><td>Get non-existent secret</td><td>Returns <code>NotFound</code> error</td></tr>
<tr><td>Get expired secret</td><td>Returns <code>SecretExpired</code> error</td></tr>
<tr><td>Set by non-root without Write</td><td>Returns <code>AccessDenied</code> or <code>InsufficientPermission</code></td></tr>
<tr><td>TTL grant cleanup</td><td>Opportunistic on <code>get()</code> – may not be immediate</td></tr>
<tr><td>Version limit exceeded</td><td>Oldest versions automatically deleted</td></tr>
<tr><td>Plaintext &gt; 64KB</td><td>Returns <code>CryptoError</code></td></tr>
<tr><td>Invalid UTF-8 in secret</td><td><code>get()</code> returns <code>CryptoError</code></td></tr>
<tr><td>Concurrent modifications</td><td>Thread-safe via DashMap sharding</td></tr>
<tr><td>MEMBER edge to secret</td><td>Path exists but NO permission granted</td></tr>
<tr><td>Tampered graph edge</td><td>BFS skips the edge; <code>explain_access</code> reports <code>TamperedEdge</code></td></tr>
<tr><td>Delegation depth exceeded</td><td>Returns error; configurable via <code>max_delegation_depth</code></td></tr>
<tr><td>Delegation cycle attempt</td><td>Returns error; ancestors cannot be children</td></tr>
<tr><td>Break-glass rate limited</td><td>Only 1 emergency access per rate-limit window</td></tr>
<tr><td>Transit ciphertext after key rotation</td><td>Undecryptable (forward secrecy)</td></tr>
</tbody></table>
</div>
<h3 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Threat</th><th>Mitigation</th></tr></thead><tbody>
<tr><td>Password brute-force</td><td>Argon2id memory-hard KDF (64MB, 3 iterations)</td></tr>
<tr><td>Offline dictionary attack</td><td>Random 128-bit salt, stored in TensorStore</td></tr>
<tr><td>Ciphertext tampering</td><td>AES-GCM authentication tag (128-bit)</td></tr>
<tr><td>Nonce reuse</td><td>Random 96-bit nonce per encryption</td></tr>
<tr><td>Key leakage</td><td>Keys zeroized on drop, 5 independent subkeys via HKDF</td></tr>
<tr><td>Pattern analysis</td><td>Key obfuscation, padding, metadata encryption</td></tr>
<tr><td>Access enumeration</td><td>Rate limiting, audit logging</td></tr>
<tr><td>Privilege escalation</td><td>MEMBER edges don’t grant permissions</td></tr>
<tr><td>Replay attacks</td><td>Per-operation nonces, timestamps in metadata</td></tr>
<tr><td>Topology tampering</td><td>HMAC-BLAKE2b edge signatures with constant-time verification</td></tr>
<tr><td>Transitive escalation</td><td>Distance-based attenuation degrades permissions with hops</td></tr>
<tr><td>Delegation abuse</td><td>Ceiling model, depth limits, cycle prevention</td></tr>
<tr><td>Behavioral anomaly</td><td>Real-time per-agent anomaly detection</td></tr>
<tr><td>Emergency misuse</td><td>Rate-limited break-glass with mandatory justification and audit</td></tr>
<tr><td>Audit log tampering</td><td>HMAC integrity protection per entry, AEAD encryption of fields</td></tr>
<tr><td>Stale audit after rotation</td><td>Audit epoch counter detects entries from previous key</td></tr>
</tbody></table>
</div>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time</th><th>Notes</th></tr></thead><tbody>
<tr><td>Key derivation (Argon2id)</td><td>~80ms</td><td>64MB memory cost</td></tr>
<tr><td>set (1KB)</td><td>~29us</td><td>Includes encryption + versioning</td></tr>
<tr><td>get (1KB)</td><td>~24us</td><td>Includes decryption + audit</td></tr>
<tr><td>set (10KB)</td><td>~93us</td><td>Scales with data size</td></tr>
<tr><td>get (10KB)</td><td>~91us</td><td>Scales with data size</td></tr>
<tr><td>Access check (shallow)</td><td>~6us</td><td>Direct edge</td></tr>
<tr><td>Access check (deep, 10 hops)</td><td>~17us</td><td>BFS traversal</td></tr>
<tr><td>grant</td><td>~18us</td><td>Creates graph edge</td></tr>
<tr><td>revoke</td><td>~1.1ms</td><td>Edge deletion + TTL cleanup</td></tr>
<tr><td>list (100 secrets)</td><td>~291us</td><td>Pattern matching + access check</td></tr>
<tr><td>list (1000 secrets)</td><td>~2.7ms</td><td>Scales linearly</td></tr>
</tbody></table>
</div>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Relationship</th></tr></thead><tbody>
<tr><td><a href="tensor-store.html">Tensor Store</a></td><td>Underlying key-value storage for encrypted secrets</td></tr>
<tr><td><a href="graph-engine.html">Graph Engine</a></td><td>Access control edges and audit trail</td></tr>
<tr><td><a href="query-router.html">Query Router</a></td><td>VAULT command execution</td></tr>
<tr><td><a href="neumann-shell.html">Neumann Shell</a></td><td>Interactive vault commands</td></tr>
</tbody></table>
</div>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Crate</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>aes-gcm</code></td><td>AES-256-GCM authenticated encryption</td></tr>
<tr><td><code>argon2</code></td><td>Argon2id key derivation</td></tr>
<tr><td><code>hkdf</code></td><td>HKDF-SHA256 subkey derivation</td></tr>
<tr><td><code>blake2</code></td><td>HMAC-BLAKE2b for obfuscation, edge signing, audit integrity</td></tr>
<tr><td><code>rand</code></td><td>Nonce and salt generation</td></tr>
<tr><td><code>zeroize</code></td><td>Secure memory cleanup on drop</td></tr>
<tr><td><code>dashmap</code></td><td>Concurrent rate limit and anomaly tracking</td></tr>
<tr><td><code>serde</code></td><td>TTL grant and delegation persistence</td></tr>
<tr><td><code>graph_engine</code></td><td>BFS traversal, PageRank, Louvain, eigenvector centrality</td></tr>
<tr><td><code>tensor_store</code></td><td>Underlying key-value storage for all vault data</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/tensor-compress.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/tensor-cache.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/tensor-compress.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/tensor-cache.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
