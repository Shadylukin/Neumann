<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tensor Vault - Neumann</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Unified tensor-based runtime for relational, graph, and vector data">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neumann</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann/edit/main/docs/book/src/architecture/tensor-vault.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tensor-vault"><a class="header" href="#tensor-vault">Tensor Vault</a></h1>
<p>Tensor Vault provides secure secret storage with AES-256-GCM encryption and
graph-based access control. Designed for multi-agent environments, it implements
a zero-trust architecture where access is determined by graph topology rather
than traditional ACLs.</p>
<p>All secrets are encrypted at rest with authenticated encryption. The vault
maintains a permanent audit trail of all operations and supports features like
rate limiting, TTL-based grants, and namespace isolation for multi-tenant
deployments.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Principle</th><th>Description</th></tr></thead><tbody>
<tr><td>Encryption at Rest</td><td>All secrets encrypted with AES-256-GCM</td></tr>
<tr><td>Topological Access Control</td><td>Access determined by graph path, not ACLs</td></tr>
<tr><td>Zero Trust</td><td>No bypass mode; <code>node:root</code> is the only universal accessor</td></tr>
<tr><td>Memory Safety</td><td>Keys zeroized on drop via <code>zeroize</code> crate</td></tr>
<tr><td>Permanent Audit Trail</td><td>All operations logged with queryable API</td></tr>
<tr><td>Defense in Depth</td><td>Multiple obfuscation layers hide patterns</td></tr>
<tr><td>Multi-Tenant Ready</td><td>Namespace isolation and rate limiting for agent systems</td></tr>
</tbody></table>
</div>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<h3 id="core-types"><a class="header" href="#core-types">Core Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Vault</code></td><td>Main API for encrypted secret storage with graph-based access control</td></tr>
<tr><td><code>VaultConfig</code></td><td>Configuration for key derivation, rate limiting, and versioning</td></tr>
<tr><td><code>VaultError</code></td><td>Error types (AccessDenied, NotFound, CryptoError, etc.)</td></tr>
<tr><td><code>Permission</code></td><td>Access levels: Read, Write, Admin</td></tr>
<tr><td><code>VersionInfo</code></td><td>Metadata about a secret version (version number, timestamp)</td></tr>
<tr><td><code>ScopedVault</code></td><td>Entity-bound view for simplified API usage</td></tr>
<tr><td><code>NamespacedVault</code></td><td>Namespace-prefixed view for multi-tenant isolation</td></tr>
</tbody></table>
</div>
<h3 id="cryptographic-types"><a class="header" href="#cryptographic-types">Cryptographic Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>MasterKey</code></td><td>Derived encryption key with zeroize-on-drop (32 bytes)</td></tr>
<tr><td><code>Cipher</code></td><td>AES-256-GCM encryption wrapper</td></tr>
<tr><td><code>Obfuscator</code></td><td>HMAC-based key obfuscation and AEAD metadata encryption</td></tr>
<tr><td><code>PaddingSize</code></td><td>Padding buckets for length hiding (256B to 64KB)</td></tr>
</tbody></table>
</div>
<h3 id="access-control-types"><a class="header" href="#access-control-types">Access Control Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AccessController</code></td><td>BFS-based graph path verification</td></tr>
<tr><td><code>GrantTTLTracker</code></td><td>Min-heap tracking grant expirations with persistence</td></tr>
<tr><td><code>RateLimiter</code></td><td>Sliding window rate limiting per entity</td></tr>
<tr><td><code>RateLimitConfig</code></td><td>Configurable limits per operation type</td></tr>
</tbody></table>
</div>
<h3 id="audit-types"><a class="header" href="#audit-types">Audit Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>AuditLog</code></td><td>Query interface for audit entries</td></tr>
<tr><td><code>AuditEntry</code></td><td>Single operation record (entity, key, operation, timestamp)</td></tr>
<tr><td><code>AuditOperation</code></td><td>Operation types: Get, Set, Delete, Rotate, Grant, Revoke, List</td></tr>
</tbody></table>
</div>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre class="mermaid">graph TB
    subgraph &quot;Tensor Vault&quot;
        API[Vault API]
        AC[AccessController]
        Cipher[Cipher&lt;br/&gt;AES-256-GCM]
        KDF[MasterKey&lt;br/&gt;Argon2id + HKDF]
        Obf[Obfuscator&lt;br/&gt;HMAC + Padding]
        Audit[AuditLog]
        TTL[GrantTTLTracker]
        RL[RateLimiter]
    end

    subgraph &quot;Storage&quot;
        TS[TensorStore]
        GE[GraphEngine]
    end

    API --&gt; AC
    API --&gt; Cipher
    API --&gt; Obf
    API --&gt; Audit
    API --&gt; TTL
    API --&gt; RL

    AC --&gt; GE
    Cipher --&gt; KDF
    Obf --&gt; KDF

    API --&gt; TS
    Audit --&gt; TS
</pre>
<h3 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h3>
<ol>
<li><strong>Set Operation</strong>: Plaintext is padded, encrypted with random nonce, metadata
obfuscated, stored via TensorStore</li>
<li><strong>Get Operation</strong>: Rate limit check, access path verified via BFS, ciphertext
decrypted, padding removed, audit logged</li>
<li><strong>Grant Operation</strong>: Permission edge created in GraphEngine, TTL tracked if
specified</li>
<li><strong>Revoke Operation</strong>: Permission edge deleted, expired grants cleaned up</li>
</ol>
<h3 id="set-operation-flow"><a class="header" href="#set-operation-flow">Set Operation Flow</a></h3>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant V as Vault
    participant RL as RateLimiter
    participant AC as AccessController
    participant O as Obfuscator
    participant Ci as Cipher
    participant TS as TensorStore
    participant GE as GraphEngine
    participant A as AuditLog

    C-&gt;&gt;V: set(requester, key, value)
    V-&gt;&gt;RL: check_rate_limit(requester, Set)
    alt Rate Limited
        RL--&gt;&gt;V: RateLimited error
        V--&gt;&gt;C: Error
    end

    alt New Secret
        V-&gt;&gt;V: Check requester == ROOT
        alt Not Root
            V--&gt;&gt;C: AccessDenied
        end
    else Update
        V-&gt;&gt;AC: check_path_with_permission(Write)
    end

    V-&gt;&gt;O: pad_plaintext(value)
    O--&gt;&gt;V: padded_value
    V-&gt;&gt;Ci: encrypt(padded_value)
    Ci--&gt;&gt;V: (ciphertext, nonce)

    V-&gt;&gt;O: generate_storage_id(key, nonce)
    O--&gt;&gt;V: blob_key
    V-&gt;&gt;TS: put(blob_key, ciphertext)

    V-&gt;&gt;O: obfuscate_key(key)
    O--&gt;&gt;V: obfuscated_key
    V-&gt;&gt;O: encrypt_metadata(creator)
    V-&gt;&gt;O: encrypt_metadata(timestamp)
    V-&gt;&gt;TS: put(_vk:obfuscated_key, metadata)

    alt New Secret
        V-&gt;&gt;GE: add_entity_edge(ROOT, secret_node, VAULT_ACCESS_ADMIN)
    end

    V-&gt;&gt;A: record(requester, key, Set)
    V--&gt;&gt;C: Ok(())
</pre>
<h2 id="access-control-model"><a class="header" href="#access-control-model">Access Control Model</a></h2>
<p>Access is determined by graph topology using BFS traversal:</p>
<pre><code class="language-text">node:root ──VAULT_ACCESS_ADMIN──&gt; vault_secret:api_key
                                          ^
user:alice ──VAULT_ACCESS_READ───────────┘
                                          ^
team:devs ──VAULT_ACCESS_WRITE───────────┘
      ^
user:bob ──MEMBER────────────────────────┘
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Requester</th><th>Path</th><th>Access</th></tr></thead><tbody>
<tr><td><code>node:root</code></td><td>Always</td><td>Granted (Admin)</td></tr>
<tr><td><code>user:alice</code></td><td>Direct edge</td><td>Granted (Read only)</td></tr>
<tr><td><code>team:devs</code></td><td>Direct edge</td><td>Granted (Write)</td></tr>
<tr><td><code>user:bob</code></td><td>bob -&gt; team:devs -&gt; secret</td><td>Granted (Write via team)</td></tr>
<tr><td><code>user:carol</code></td><td>No path</td><td>Denied</td></tr>
</tbody></table>
</div>
<h3 id="permission-levels"><a class="header" href="#permission-levels">Permission Levels</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Capabilities</th></tr></thead><tbody>
<tr><td>Read</td><td><code>get()</code>, <code>list()</code>, <code>get_version()</code>, <code>list_versions()</code></td></tr>
<tr><td>Write</td><td>Read + <code>set()</code> (update), <code>rotate()</code>, <code>rollback()</code></td></tr>
<tr><td>Admin</td><td>Write + <code>delete()</code>, <code>grant()</code>, <code>revoke()</code></td></tr>
</tbody></table>
</div>
<p>Permission propagation follows graph paths. The effective permission is
determined by the <code>VAULT_ACCESS_*</code> edge type at the end of the path.</p>
<h3 id="allowed-traversal-edges"><a class="header" href="#allowed-traversal-edges">Allowed Traversal Edges</a></h3>
<p>Only these edge types can grant transitive access:</p>
<ul>
<li><code>VAULT_ACCESS</code> - Legacy edge type (treated as Admin for backward
compatibility)</li>
<li><code>VAULT_ACCESS_READ</code> - Read-only access</li>
<li><code>VAULT_ACCESS_WRITE</code> - Read + Write access</li>
<li><code>VAULT_ACCESS_ADMIN</code> - Full access including grant/revoke</li>
<li><code>MEMBER</code> - Allows group membership traversal but does NOT grant permission
directly</li>
</ul>
<h3 id="access-control-algorithm"><a class="header" href="#access-control-algorithm">Access Control Algorithm</a></h3>
<p>The <code>AccessController</code> uses BFS to find the best permission level along any
path:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simplified algorithm from access.rs
pub fn get_permission_level(graph: &amp;GraphEngine, source: &amp;str, target: &amp;str) -&gt; Option&lt;Permission&gt; {
    if source == target {
        return Some(Permission::Admin);  // Self-access
    }

    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    let mut best_permission: Option&lt;Permission&gt; = None;

    queue.push_back(source.to_string());
    visited.insert(source.to_string());

    while let Some(current) = queue.pop_front() {
        for edge in graph.get_entity_outgoing(&amp;current) {
            let (_, to, edge_type, _) = graph.get_entity_edge(&amp;edge);

            // Only traverse allowed edge types
            if !is_allowed_edge_type(&amp;edge_type) {
                continue;
            }

            // VAULT_ACCESS_* edges grant permission to target
            if edge_type.starts_with("VAULT_ACCESS") &amp;&amp; to == target {
                if let Some(perm) = Permission::from_edge_type(&amp;edge_type) {
                    best_permission = max(best_permission, perm);
                }
            } else if edge_type == "MEMBER" {
                // MEMBER edges allow traversal but NO permission grant
                if !visited.contains(&amp;to) {
                    visited.insert(to.clone());
                    queue.push_back(to);
                }
            }
        }
    }

    best_permission
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Note</strong>: <code>MEMBER</code> edges enable traversal through groups but do not
grant permissions. Only <code>VAULT_ACCESS_*</code> edges grant actual permissions. This
prevents privilege escalation via group membership.</p>
<h3 id="access-control-flow"><a class="header" href="#access-control-flow">Access Control Flow</a></h3>
<pre class="mermaid">flowchart TD
    Start([Check Access]) --&gt; IsRoot{Is requester ROOT?}
    IsRoot --&gt;|Yes| Granted([Access Granted - Admin])
    IsRoot --&gt;|No| BFS[Start BFS from requester]

    BFS --&gt; Queue{Queue empty?}
    Queue --&gt;|Yes| CheckBest{Best permission found?}
    Queue --&gt;|No| Pop[Pop next node]

    Pop --&gt; GetEdges[Get outgoing edges]
    GetEdges --&gt; ForEdge{For each edge}

    ForEdge --&gt; IsAllowed{Edge type allowed?}
    IsAllowed --&gt;|No| ForEdge
    IsAllowed --&gt;|Yes| IsVaultAccess{VAULT_ACCESS_* ?}

    IsVaultAccess --&gt;|Yes| IsTarget{Points to target?}
    IsTarget --&gt;|Yes| UpdateBest[Update best permission]
    IsTarget --&gt;|No| ForEdge
    UpdateBest --&gt; ForEdge

    IsVaultAccess --&gt;|No| IsMember{MEMBER edge?}
    IsMember --&gt;|Yes| AddQueue[Add destination to queue]
    IsMember --&gt;|No| ForEdge
    AddQueue --&gt; ForEdge

    ForEdge --&gt;|Done| Queue

    CheckBest --&gt;|Yes| CheckLevel{Permission &gt;= required?}
    CheckBest --&gt;|No| Denied([Access Denied])
    CheckLevel --&gt;|Yes| Granted2([Access Granted])
    CheckLevel --&gt;|No| Insufficient([Insufficient Permission])
</pre>
<h2 id="storage-format"><a class="header" href="#storage-format">Storage Format</a></h2>
<p>Secrets use a two-tier storage model for security:</p>
<h3 id="metadata-tensor"><a class="header" href="#metadata-tensor">Metadata Tensor</a></h3>
<p>Storage key: <code>_vk:{HMAC(key)}</code> (key name obfuscated via HMAC-BLAKE2b)</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_blob</code></td><td>Pointer</td><td>Reference to current version ciphertext blob</td></tr>
<tr><td><code>_nonce</code></td><td>Bytes</td><td>12-byte encryption nonce for current version</td></tr>
<tr><td><code>_versions</code></td><td>Pointers</td><td>List of all version blob keys (oldest first)</td></tr>
<tr><td><code>_key_enc</code></td><td>Bytes</td><td>AES-GCM encrypted original key name</td></tr>
<tr><td><code>_key_nonce</code></td><td>Bytes</td><td>Nonce for key encryption</td></tr>
<tr><td><code>_creator_obf</code></td><td>Bytes</td><td>AEAD-encrypted creator (nonce prepended)</td></tr>
<tr><td><code>_created_obf</code></td><td>Bytes</td><td>AEAD-encrypted timestamp (nonce prepended)</td></tr>
<tr><td><code>_rotator_obf</code></td><td>Bytes</td><td>AEAD-encrypted last rotator (optional)</td></tr>
<tr><td><code>_rotated_obf</code></td><td>Bytes</td><td>AEAD-encrypted last rotation timestamp (optional)</td></tr>
</tbody></table>
</div>
<h3 id="ciphertext-blob"><a class="header" href="#ciphertext-blob">Ciphertext Blob</a></h3>
<p>Storage key: <code>_vs:{HMAC(key, nonce)}</code> (random-looking storage ID)</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_data</code></td><td>Bytes</td><td>Padded + encrypted secret</td></tr>
<tr><td><code>_nonce</code></td><td>Bytes</td><td>12-byte encryption nonce</td></tr>
<tr><td><code>_ts</code></td><td>Int</td><td>Unix timestamp (seconds) when version was created</td></tr>
</tbody></table>
</div>
<h3 id="storage-key-structure"><a class="header" href="#storage-key-structure">Storage Key Structure</a></h3>
<pre><code class="language-text">_vault:salt          - Persisted 16-byte salt for key derivation
_vk:&lt;32-hex-chars&gt;   - Metadata tensor (HMAC of secret key)
_vs:&lt;24-hex-chars&gt;   - Ciphertext blob (HMAC of key + nonce)
_va:&lt;timestamp&gt;:&lt;counter&gt; - Audit log entries
_vault_ttl_grants    - Persisted TTL grants (JSON)
vault_secret:&lt;32-hex-chars&gt; - Secret node for graph access control
</code></pre>
<h2 id="encryption"><a class="header" href="#encryption">Encryption</a></h2>
<h3 id="key-derivation"><a class="header" href="#key-derivation">Key Derivation</a></h3>
<p>Master key derived using Argon2id with HKDF-based subkey separation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From key.rs - Argon2id parameters
pub const SALT_SIZE: usize = 16;  // 128-bit salt
pub const KEY_SIZE: usize = 32;   // 256-bit key (AES-256)

// Default VaultConfig values:
// argon2_memory_cost: 65536 (64 MiB)
// argon2_time_cost: 3 (iterations)
// argon2_parallelism: 4 (threads)

// Argon2id configuration
let params = Params::new(
    config.argon2_memory_cost,  // Memory in KiB
    config.argon2_time_cost,    // Iterations
    config.argon2_parallelism,  // Parallelism
    Some(KEY_SIZE),             // Output length
)?;

let argon2 = Argon2::new(Algorithm::Argon2id, Version::V0x13, params);
argon2.hash_password_into(input, salt, &amp;mut key)?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Argon2id Security Properties</strong>:</p>
<ul>
<li>Hybrid algorithm: Argon2i (side-channel resistant) + Argon2d (GPU resistant)</li>
<li>Memory-hard: Requires 64 MiB by default, defeating GPU/ASIC attacks</li>
<li>Time-hard: 3 iterations increase computation time</li>
<li>Parallelism: 4 threads to utilize modern CPUs</li>
</ul>
<h3 id="hkdf-subkey-derivation"><a class="header" href="#hkdf-subkey-derivation">HKDF Subkey Derivation</a></h3>
<p>Each purpose gets a cryptographically independent key via HKDF-SHA256:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From key.rs - Domain-separated subkeys
impl MasterKey {
    pub fn derive_subkey(&amp;self, domain: &amp;[u8]) -&gt; [u8; KEY_SIZE] {
        let hk = Hkdf::&lt;Sha256&gt;::new(None, &amp;self.bytes);
        let mut output = [0u8; KEY_SIZE];
        hk.expand(domain, &amp;mut output).expect("HKDF expand cannot fail for 32 bytes");
        output
    }

    pub fn encryption_key(&amp;self) -&gt; [u8; KEY_SIZE] {
        self.derive_subkey(b"neumann_vault_encryption_v1")
    }

    pub fn obfuscation_key(&amp;self) -&gt; [u8; KEY_SIZE] {
        self.derive_subkey(b"neumann_vault_obfuscation_v1")
    }

    pub fn metadata_key(&amp;self) -&gt; [u8; KEY_SIZE] {
        self.derive_subkey(b"neumann_vault_metadata_v1")
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Hierarchy</strong>:</p>
<pre><code class="language-text">Master Password + Salt
        │
        ▼ Argon2id
    MasterKey (32 bytes)
        │
        ├──▶ HKDF("encryption_v1") ──▶ AES-256-GCM key
        ├──▶ HKDF("obfuscation_v1") ──▶ HMAC key for obfuscation
        └──▶ HKDF("metadata_v1") ──▶ AES-256-GCM key for metadata
</code></pre>
<h3 id="salt-persistence"><a class="header" href="#salt-persistence">Salt Persistence</a></h3>
<p>The vault automatically manages salt persistence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From lib.rs - Salt handling on vault creation
pub fn new(master_key: &amp;[u8], graph: Arc&lt;GraphEngine&gt;, store: TensorStore, config: VaultConfig) -&gt; Result&lt;Self&gt; {
    let derived = if config.salt.is_some() {
        // Explicit salt provided - use it directly
        let (key, _) = MasterKey::derive(master_key, &amp;config)?;
        key
    } else if let Some(persisted_salt) = Self::load_salt(&amp;store) {
        // Use persisted salt for consistency across reopens
        MasterKey::derive_with_salt(master_key, &amp;persisted_salt, &amp;config)?
    } else {
        // Generate new random salt and persist it
        let (key, new_salt) = MasterKey::derive(master_key, &amp;config)?;
        Self::save_salt(&amp;store, new_salt)?;
        key
    };
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="encryption-process"><a class="header" href="#encryption-process">Encryption Process</a></h3>
<ol>
<li>Pad plaintext to fixed bucket size (256B, 1KB, 4KB, 16KB, 32KB, or 64KB)</li>
<li>Generate random 12-byte nonce</li>
<li>Encrypt with AES-256-GCM</li>
<li>Store ciphertext and nonce separately</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From encryption.rs
pub const NONCE_SIZE: usize = 12;  // 96-bit nonce (AES-GCM standard)

impl Cipher {
    pub fn encrypt(&amp;self, plaintext: &amp;[u8]) -&gt; Result&lt;(Vec&lt;u8&gt;, [u8; NONCE_SIZE])&gt; {
        let cipher = Aes256Gcm::new_from_slice(self.key.as_bytes())?;

        // Generate random nonce - CRITICAL for security
        let mut nonce_bytes = [0u8; NONCE_SIZE];
        rand::thread_rng().fill_bytes(&amp;mut nonce_bytes);
        let nonce = Nonce::from_slice(&amp;nonce_bytes);

        // AES-GCM provides authenticated encryption
        // Output: ciphertext || 16-byte authentication tag
        let ciphertext = cipher.encrypt(nonce, plaintext)?;

        Ok((ciphertext, nonce_bytes))
    }

    pub fn decrypt(&amp;self, ciphertext: &amp;[u8], nonce_bytes: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        if nonce_bytes.len() != NONCE_SIZE {
            return Err(VaultError::CryptoError("Invalid nonce size"));
        }

        let cipher = Aes256Gcm::new_from_slice(self.key.as_bytes())?;
        let nonce = Nonce::from_slice(nonce_bytes);

        // Decryption verifies authentication tag
        // Fails if ciphertext was tampered
        cipher.decrypt(nonce, ciphertext)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>AES-256-GCM Security Properties</strong>:</p>
<ul>
<li>Authenticated encryption: Detects tampering via 128-bit authentication tag</li>
<li>Nonce requirement: Each encryption MUST use a unique nonce</li>
<li>Ciphertext expansion: 16 bytes larger than plaintext (auth tag)</li>
</ul>
<h3 id="obfuscation-layers"><a class="header" href="#obfuscation-layers">Obfuscation Layers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Layer</th><th>Purpose</th><th>Implementation</th></tr></thead><tbody>
<tr><td>Key Obfuscation</td><td>Hide secret names</td><td>HMAC-BLAKE2b hash of key name</td></tr>
<tr><td>Pointer Indirection</td><td>Hide storage patterns</td><td>Ciphertext in separate blob with random-looking key</td></tr>
<tr><td>Length Padding</td><td>Hide plaintext size</td><td>Pad to fixed bucket sizes</td></tr>
<tr><td>Metadata Encryption</td><td>Hide creator/timestamps</td><td>AES-GCM with per-record random nonces</td></tr>
<tr><td>Blind Indexes</td><td>Searchable encryption</td><td>HMAC-based indexes for pattern matching</td></tr>
</tbody></table>
</div>
<h3 id="padding-bucket-sizes"><a class="header" href="#padding-bucket-sizes">Padding Bucket Sizes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From obfuscation.rs
pub enum PaddingSize {
    Small = 256,        // API keys, tokens
    Medium = 1024,      // Certificates, small configs
    Large = 4096,       // Private keys, large configs
    ExtraLarge = 16384, // Very large secrets
    Huge = 32768,       // Oversized secrets
    Maximum = 65536,    // Maximum supported
}

// Bucket selection (includes 4-byte length prefix + 1 byte min padding)
pub fn for_length(len: usize) -&gt; Option&lt;Self&gt; {
    let min_required = len + 5;  // length prefix + min padding

    if min_required &lt;= 256 { Some(Small) }
    else if min_required &lt;= 1024 { Some(Medium) }
    else if min_required &lt;= 4096 { Some(Large) }
    else if min_required &lt;= 16384 { Some(ExtraLarge) }
    else if min_required &lt;= 32768 { Some(Huge) }
    else if min_required &lt;= 65536 { Some(Maximum) }
    else { None }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="padding-format"><a class="header" href="#padding-format">Padding Format</a></h3>
<pre><code class="language-text">+----------------+-------------------+------------------+
| Length (4B LE) | Plaintext (N B)   | Random Padding   |
+----------------+-------------------+------------------+
|&lt;--------------- Bucket Size (256/1K/4K/...) --------&gt;|
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From obfuscation.rs
pub fn pad_plaintext(plaintext: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let target_size = PaddingSize::for_length(plaintext.len())? as usize;
    let padding_len = target_size - 4 - plaintext.len();  // 4 = length prefix

    let mut padded = Vec::with_capacity(target_size);

    // Store original length as u32 little-endian
    let len_bytes = (plaintext.len() as u32).to_le_bytes();
    padded.extend_from_slice(&amp;len_bytes);

    // Original data
    padded.extend_from_slice(plaintext);

    // Random padding (not zeros - prevents padding oracle attacks)
    let mut rng_bytes = vec![0u8; padding_len];
    rand::thread_rng().fill_bytes(&amp;mut rng_bytes);
    padded.extend_from_slice(&amp;rng_bytes);

    Ok(padded)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="hmac-blake2b-construction"><a class="header" href="#hmac-blake2b-construction">HMAC-BLAKE2b Construction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From obfuscation.rs - HMAC construction for key obfuscation
fn hmac_hash(&amp;self, data: &amp;[u8], domain: &amp;[u8]) -&gt; [u8; 32] {
    // Inner hash: H((key XOR ipad) || domain || data)
    let mut inner_key = self.obfuscation_key;
    for byte in &amp;mut inner_key {
        *byte ^= 0x36;  // ipad
    }
    let mut inner_hasher = Blake2b::&lt;U32&gt;::new();
    inner_hasher.update(inner_key);
    inner_hasher.update(domain);
    inner_hasher.update(data);
    let inner_hash = inner_hasher.finalize();

    // Outer hash: H((key XOR opad) || inner_hash)
    let mut outer_key = self.obfuscation_key;
    for byte in &amp;mut outer_key {
        *byte ^= 0x5c;  // opad
    }
    let mut outer_hasher = Blake2b::&lt;U32&gt;::new();
    outer_hasher.update(outer_key);
    outer_hasher.update(inner_hash);

    outer_hasher.finalize().into()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="metadata-aead-encryption"><a class="header" href="#metadata-aead-encryption">Metadata AEAD Encryption</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From obfuscation.rs - Per-record AEAD encryption
pub fn encrypt_metadata(&amp;self, data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let cipher = Aes256Gcm::new_from_slice(&amp;self.metadata_key)?;

    // Random nonce for each encryption
    let mut nonce_bytes = [0u8; 12];
    rand::thread_rng().fill_bytes(&amp;mut nonce_bytes);
    let nonce = Nonce::from_slice(&amp;nonce_bytes);

    let ciphertext = cipher.encrypt(nonce, data)?;

    // Format: nonce || ciphertext
    let mut result = Vec::with_capacity(12 + ciphertext.len());
    result.extend_from_slice(&amp;nonce_bytes);
    result.extend(ciphertext);
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h2>
<p>Rate limiting uses a sliding window algorithm to prevent brute-force attacks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From rate_limit.rs
pub struct RateLimiter {
    // (entity, operation) -&gt; timestamps of recent requests
    history: DashMap&lt;(String, String), VecDeque&lt;Instant&gt;&gt;,
    config: RateLimitConfig,
}

impl RateLimiter {
    pub fn check_and_record(&amp;self, entity: &amp;str, op: Operation) -&gt; Result&lt;(), String&gt; {
        let limit = op.limit(&amp;self.config);
        if limit == u32::MAX {
            return Ok(());  // Unlimited
        }

        let key = (entity.to_string(), op.as_str().to_string());
        let now = Instant::now();
        let window_start = now - self.config.window;

        let mut entry = self.history.entry(key).or_default();
        let timestamps = entry.value_mut();

        // Remove expired entries outside window
        while let Some(front) = timestamps.front() {
            if *front &lt; window_start {
                timestamps.pop_front();
            } else {
                break;
            }
        }

        let count = timestamps.len() as u32;
        if count &gt;= limit {
            Err(format!("Rate limit exceeded: {} {} calls in {:?}", count, op, self.config.window))
        } else {
            timestamps.push_back(now);  // Record this request
            Ok(())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sliding-window-visualization"><a class="header" href="#sliding-window-visualization">Sliding Window Visualization</a></h3>
<pre><code class="language-text">Window: 60 seconds
Limit: 5 requests

Timeline:
|--[req1]--[req2]---[req3]--[req4]---[req5]---|
|&lt;------------------ Window -----------------&gt;|
                                               ^
                                               Now (6th request blocked)

After 10 seconds:
                    |--[req2]---[req3]--[req4]---[req5]---|
   [req1] expired   |&lt;------------------ Window ---------&gt;|
                                                           ^
                                                           Now (6th request allowed)
</code></pre>
<h3 id="rate-limit-configuration-presets"><a class="header" href="#rate-limit-configuration-presets">Rate Limit Configuration Presets</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default configuration
impl Default for RateLimitConfig {
    fn default() -&gt; Self {
        Self {
            max_gets: 60,    // 60 get() calls per minute
            max_lists: 10,   // 10 list() calls per minute
            max_sets: 30,    // 30 set() calls per minute
            max_grants: 20,  // 20 grant() calls per minute
            window: Duration::from_secs(60),
        }
    }
}

// Strict configuration for testing
pub fn strict() -&gt; Self {
    Self {
        max_gets: 5,
        max_lists: 2,
        max_sets: 3,
        max_grants: 2,
        window: Duration::from_secs(60),
    }
}

// No rate limiting
pub fn unlimited() -&gt; Self {
    Self {
        max_gets: u32::MAX,
        max_lists: u32::MAX,
        max_sets: u32::MAX,
        max_grants: u32::MAX,
        window: Duration::from_secs(60),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Note</strong>: <code>node:root</code> is exempt from rate limiting.</p>
<h2 id="ttl-grant-tracking"><a class="header" href="#ttl-grant-tracking">TTL Grant Tracking</a></h2>
<p>TTL grants use a min-heap for efficient expiration tracking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From ttl.rs
pub struct GrantTTLTracker {
    // Priority queue of expiration times (min-heap)
    heap: Mutex&lt;BinaryHeap&lt;GrantTTLEntry&gt;&gt;,
}

struct GrantTTLEntry {
    expires_at: Instant,
    entity: String,
    secret_key: String,
}

// Reverse ordering for min-heap (earliest expiration first)
impl Ord for GrantTTLEntry {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        other.expires_at.cmp(&amp;self.expires_at)  // Reversed!
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ttl-operations"><a class="header" href="#ttl-operations">TTL Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add a grant with TTL
pub fn add(&amp;self, entity: &amp;str, secret_key: &amp;str, ttl: Duration) {
    let entry = GrantTTLEntry {
        expires_at: Instant::now() + ttl,
        entity: entity.to_string(),
        secret_key: secret_key.to_string(),
    };
    self.heap.lock().unwrap().push(entry);
}

// Efficient expiration check - O(1) to peek, O(log n) to pop
pub fn get_expired(&amp;self) -&gt; Vec&lt;(String, String)&gt; {
    let now = Instant::now();
    let mut expired = Vec::new();
    let mut heap = self.heap.lock().unwrap();

    // Pop all expired entries (they're at the top due to min-heap)
    while let Some(entry) = heap.peek() {
        if entry.expires_at &lt;= now {
            if let Some(entry) = heap.pop() {
                expired.push((entry.entity, entry.secret_key));
            }
        } else {
            break;  // No more expired entries
        }
    }

    expired
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ttl-persistence"><a class="header" href="#ttl-persistence">TTL Persistence</a></h3>
<p>TTL grants survive vault restarts via TensorStore persistence:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From ttl.rs
const TTL_STORAGE_KEY: &amp;str = "_vault_ttl_grants";

#[derive(Serialize, Deserialize)]
pub struct PersistedGrant {
    pub expires_at_ms: i64,  // Unix timestamp
    pub entity: String,
    pub secret_key: String,
}

pub fn persist(&amp;self, store: &amp;TensorStore) -&gt; Result&lt;()&gt; {
    let grants: Vec&lt;PersistedGrant&gt; = self.heap.lock().unwrap()
        .iter()
        .map(|e| PersistedGrant {
            expires_at_ms: instant_to_unix_ms(e.expires_at),
            entity: e.entity.clone(),
            secret_key: e.secret_key.clone(),
        })
        .collect();

    let data = serde_json::to_vec(&amp;grants)?;
    store.put(TTL_STORAGE_KEY, tensor_with_bytes(data))?;
    Ok(())
}

pub fn load(store: &amp;TensorStore) -&gt; Result&lt;Self&gt; {
    let tracker = Self::new();
    let grants: Vec&lt;PersistedGrant&gt; = load_from_store(store)?;

    for grant in grants {
        // Skip already expired grants
        if !grant.is_expired() {
            tracker.add_with_expiration(
                &amp;grant.entity,
                &amp;grant.secret_key,
                unix_ms_to_instant(grant.expires_at_ms),
            );
        }
    }

    Ok(tracker)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cleanup-strategy"><a class="header" href="#cleanup-strategy">Cleanup Strategy</a></h3>
<p>Expired grants are cleaned up opportunistically during <code>get()</code> operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From lib.rs
pub fn get(&amp;self, requester: &amp;str, key: &amp;str) -&gt; Result&lt;String&gt; {
    // Opportunistic cleanup of expired grants
    self.cleanup_expired_grants();

    // ... rest of get operation
}

pub fn cleanup_expired_grants(&amp;self) -&gt; usize {
    let expired = self.ttl_tracker.get_expired();
    let mut revoked = 0;

    for (entity, key) in expired {
        let secret_node = self.secret_node_key(&amp;key);

        // Delete the VAULT_ACCESS_* edge
        if let Ok(edges) = self.graph.get_entity_outgoing(&amp;entity) {
            for edge_key in edges {
                if let Ok((_, to, edge_type, _)) = self.graph.get_entity_edge(&amp;edge_key) {
                    if to == secret_node &amp;&amp; edge_type.starts_with("VAULT_ACCESS") {
                        if self.graph.delete_entity_edge(&amp;edge_key).is_ok() {
                            revoked += 1;
                        }
                    }
                }
            }
        }
    }

    revoked
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h2>
<h3 id="audit-entry-storage"><a class="header" href="#audit-entry-storage">Audit Entry Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From audit.rs
const AUDIT_PREFIX: &amp;str = "_va:";
static AUDIT_COUNTER: AtomicU64 = AtomicU64::new(0);

pub fn record(&amp;self, entity: &amp;str, secret_key: &amp;str, operation: &amp;AuditOperation) {
    let timestamp = now_millis();
    let counter = AUDIT_COUNTER.fetch_add(1, Ordering::SeqCst);
    let key = format!("{AUDIT_PREFIX}{timestamp}:{counter}");

    let mut tensor = TensorData::new();
    tensor.set("_entity", entity);
    tensor.set("_secret", secret_key);  // Already obfuscated by caller
    tensor.set("_op", operation.as_str());
    tensor.set("_ts", timestamp);

    // Additional fields for grant/revoke
    match operation {
        AuditOperation::Grant { to, permission } =&gt; {
            tensor.set("_target", to);
            tensor.set("_permission", permission);
        },
        AuditOperation::Revoke { from } =&gt; {
            tensor.set("_target", from);
        },
        _ =&gt; {},
    }

    // Best effort - audit failures don't block operations
    let _ = self.store.put(&amp;key, tensor);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="audit-query-methods"><a class="header" href="#audit-query-methods">Audit Query Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>Time Complexity</th></tr></thead><tbody>
<tr><td><code>by_secret(key)</code></td><td>All entries for a secret</td><td>O(n) scan + filter</td></tr>
<tr><td><code>by_entity(entity)</code></td><td>All entries by requester</td><td>O(n) scan + filter</td></tr>
<tr><td><code>since(timestamp)</code></td><td>Entries since timestamp</td><td>O(n) scan + filter</td></tr>
<tr><td><code>between(start, end)</code></td><td>Entries in time range</td><td>O(n) scan + filter</td></tr>
<tr><td><code>recent(limit)</code></td><td>Last N entries</td><td>O(n log n) sort + truncate</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: Secret keys are obfuscated in audit logs to prevent leaking plaintext
names.</p>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tensor_vault::{Vault, VaultConfig, Permission};
use graph_engine::GraphEngine;
use tensor_store::TensorStore;
use std::sync::Arc;

// Initialize vault
let graph = Arc::new(GraphEngine::new());
let store = TensorStore::new();
let vault = Vault::new(b"master_password", graph, store, VaultConfig::default())?;

// Store a secret (root only)
vault.set(Vault::ROOT, "api_key", "sk-secret123")?;

// Grant access with permission level
vault.grant_with_permission(Vault::ROOT, "user:alice", "api_key", Permission::Read)?;

// Retrieve secret
let value = vault.get("user:alice", "api_key")?;

// Revoke access
vault.revoke(Vault::ROOT, "user:alice", "api_key")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="permission-based-access"><a class="header" href="#permission-based-access">Permission-Based Access</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Grant different permission levels
vault.grant_with_permission(Vault::ROOT, "user:reader", "secret", Permission::Read)?;
vault.grant_with_permission(Vault::ROOT, "user:writer", "secret", Permission::Write)?;
vault.grant_with_permission(Vault::ROOT, "user:admin", "secret", Permission::Admin)?;

// Reader can only get/list
vault.get("user:reader", "secret")?;  // OK
vault.set("user:reader", "secret", "new")?;  // InsufficientPermission

// Writer can update
vault.rotate("user:writer", "secret", "new_value")?;  // OK
vault.delete("user:writer", "secret")?;  // InsufficientPermission

// Admin can do everything
vault.grant_with_permission("user:admin", "user:new", "secret", Permission::Read)?;  // OK
vault.delete("user:admin", "secret")?;  // OK
<span class="boring">}</span></code></pre></pre>
<h3 id="ttl-grants"><a class="header" href="#ttl-grants">TTL Grants</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Duration;

// Grant temporary access (1 hour)
vault.grant_with_ttl(
    Vault::ROOT,
    "agent:temp",
    "api_key",
    Permission::Read,
    Duration::from_secs(3600),
)?;

// Access works during TTL
vault.get("agent:temp", "api_key")?;  // OK

// After 1 hour, access is automatically revoked
// (cleanup happens opportunistically on next vault operation)
<span class="boring">}</span></code></pre></pre>
<h3 id="namespace-isolation"><a class="header" href="#namespace-isolation">Namespace Isolation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create namespaced vault for multi-tenant isolation
let backend = vault.namespace("team:backend", "user:alice");
let frontend = vault.namespace("team:frontend", "user:bob");

// Keys are automatically prefixed
backend.set("db_password", "secret1")?;   // Stored as "team:backend:db_password"
frontend.set("api_key", "secret2")?;      // Stored as "team:frontend:api_key"

// Cross-namespace access blocked
frontend.get("db_password")?;  // AccessDenied
<span class="boring">}</span></code></pre></pre>
<h3 id="secret-versioning"><a class="header" href="#secret-versioning">Secret Versioning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Each set/rotate creates a new version
vault.set(Vault::ROOT, "api_key", "v1")?;
vault.rotate(Vault::ROOT, "api_key", "v2")?;
vault.rotate(Vault::ROOT, "api_key", "v3")?;

// Get version info
let version = vault.current_version(Vault::ROOT, "api_key")?;  // 3
let versions = vault.list_versions(Vault::ROOT, "api_key")?;
// [VersionInfo { version: 1, created_at: ... }, ...]

// Get specific version
let old_value = vault.get_version(Vault::ROOT, "api_key", 1)?;  // "v1"

// Rollback (creates new version with old content)
vault.rollback(Vault::ROOT, "api_key", 1)?;
vault.get(Vault::ROOT, "api_key")?;  // "v1"
vault.current_version(Vault::ROOT, "api_key")?;  // 4 (rollback creates new version)
<span class="boring">}</span></code></pre></pre>
<h3 id="audit-queries"><a class="header" href="#audit-queries">Audit Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Query by secret
let entries = vault.audit_log("api_key");

// Query by entity
let alice_actions = vault.audit_by_entity("user:alice");

// Query by time
let recent = vault.audit_since(timestamp_millis);
let last_10 = vault.audit_recent(10);

// Audit entries include operation details
for entry in entries {
    match &amp;entry.operation {
        AuditOperation::Grant { to, permission } =&gt; {
            println!("Granted {} to {} at {}", permission, to, entry.timestamp);
        },
        AuditOperation::Get =&gt; {
            println!("{} read secret at {}", entry.entity, entry.timestamp);
        },
        _ =&gt; {},
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="scoped-vault"><a class="header" href="#scoped-vault">Scoped Vault</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a scoped view for a specific entity
let alice = vault.scope("user:alice");

// All operations use alice as the requester
alice.get("api_key")?;  // Same as vault.get("user:alice", "api_key")
alice.list("*")?;       // Same as vault.list("user:alice", "*")
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="vaultconfig"><a class="header" href="#vaultconfig">VaultConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>salt</code></td><td><code>Option&lt;[u8; 16]&gt;</code></td><td>None</td><td>Salt for key derivation (random if not provided, persisted)</td></tr>
<tr><td><code>argon2_memory_cost</code></td><td><code>u32</code></td><td>65536</td><td>Memory cost in KiB (64MB)</td></tr>
<tr><td><code>argon2_time_cost</code></td><td><code>u32</code></td><td>3</td><td>Iteration count</td></tr>
<tr><td><code>argon2_parallelism</code></td><td><code>u32</code></td><td>4</td><td>Thread count</td></tr>
<tr><td><code>rate_limit</code></td><td><code>Option&lt;RateLimitConfig&gt;</code></td><td>None</td><td>Rate limiting (disabled if None)</td></tr>
<tr><td><code>max_versions</code></td><td><code>usize</code></td><td>5</td><td>Maximum versions to retain per secret</td></tr>
</tbody></table>
</div>
<h3 id="ratelimitconfig"><a class="header" href="#ratelimitconfig">RateLimitConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>max_gets</code></td><td><code>u32</code></td><td>60</td><td>Maximum get() calls per window</td></tr>
<tr><td><code>max_lists</code></td><td><code>u32</code></td><td>10</td><td>Maximum list() calls per window</td></tr>
<tr><td><code>max_sets</code></td><td><code>u32</code></td><td>30</td><td>Maximum set() calls per window</td></tr>
<tr><td><code>max_grants</code></td><td><code>u32</code></td><td>20</td><td>Maximum grant() calls per window</td></tr>
<tr><td><code>window</code></td><td><code>Duration</code></td><td>60s</td><td>Sliding window duration</td></tr>
</tbody></table>
</div>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NEUMANN_VAULT_KEY</code></td><td>Base64-encoded 32-byte master key</td></tr>
</tbody></table>
</div>
<h2 id="shell-commands"><a class="header" href="#shell-commands">Shell Commands</a></h2>
<pre><code class="language-text">VAULT INIT                              Initialize vault from NEUMANN_VAULT_KEY
VAULT IDENTITY 'node:alice'             Set current identity
VAULT NAMESPACE 'team:backend'          Set current namespace

VAULT SET 'api_key' 'sk-123'            Store encrypted secret
VAULT GET 'api_key'                     Retrieve secret
VAULT GET 'api_key' VERSION 2           Get specific version
VAULT DELETE 'api_key'                  Delete secret
VAULT LIST 'prefix:*'                   List accessible secrets
VAULT ROTATE 'api_key' 'new'            Rotate secret value
VAULT VERSIONS 'api_key'                List version history
VAULT ROLLBACK 'api_key' VERSION 2      Rollback to version

VAULT GRANT 'user:bob' ON 'api_key'              Grant admin access
VAULT GRANT 'user:bob' ON 'api_key' READ         Grant read-only access
VAULT GRANT 'user:bob' ON 'api_key' WRITE        Grant write access
VAULT GRANT 'user:bob' ON 'api_key' TTL 3600     Grant with 1-hour expiry
VAULT REVOKE 'user:bob' ON 'api_key'             Revoke access

VAULT AUDIT 'api_key'                   View audit log for secret
VAULT AUDIT BY 'user:alice'             View audit log for entity
VAULT AUDIT RECENT 10                   View last 10 operations
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ol>
<li><strong>Use strong master passwords</strong>: At least 128 bits of entropy</li>
<li><strong>Rotate secrets regularly</strong>: Use <code>rotate()</code> to maintain version history</li>
<li><strong>Grant minimal permissions</strong>: Use Read when Write/Admin not needed</li>
<li><strong>Use TTL grants for temporary access</strong>: Prevents forgotten grants</li>
<li><strong>Enable rate limiting in production</strong>: Prevents brute-force attacks</li>
<li><strong>Use namespaces for multi-tenant</strong>: Enforces isolation</li>
<li><strong>Review audit logs</strong>: Monitor for suspicious access patterns</li>
</ol>
<h3 id="edge-cases-and-gotchas"><a class="header" href="#edge-cases-and-gotchas">Edge Cases and Gotchas</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Behavior</th></tr></thead><tbody>
<tr><td>Grant to non-existent entity</td><td>Succeeds (edge created, entity may exist later)</td></tr>
<tr><td>Revoke non-existent grant</td><td>Succeeds silently (idempotent)</td></tr>
<tr><td>Get non-existent secret</td><td>Returns <code>NotFound</code> error</td></tr>
<tr><td>Set by non-root without Write</td><td>Returns <code>AccessDenied</code> or <code>InsufficientPermission</code></td></tr>
<tr><td>TTL grant cleanup</td><td>Opportunistic on <code>get()</code> - may not be immediate</td></tr>
<tr><td>Version limit exceeded</td><td>Oldest versions automatically deleted</td></tr>
<tr><td>Plaintext &gt; 64KB</td><td>Returns <code>CryptoError</code></td></tr>
<tr><td>Invalid UTF-8 in secret</td><td><code>get()</code> returns <code>CryptoError</code></td></tr>
<tr><td>Concurrent modifications</td><td>Thread-safe via DashMap sharding</td></tr>
<tr><td>MEMBER edge to secret</td><td>Path exists but NO permission granted</td></tr>
</tbody></table>
</div>
<h3 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Threat</th><th>Mitigation</th></tr></thead><tbody>
<tr><td>Password brute-force</td><td>Argon2id memory-hard KDF (64MB, 3 iterations)</td></tr>
<tr><td>Offline dictionary attack</td><td>Random 128-bit salt, stored in TensorStore</td></tr>
<tr><td>Ciphertext tampering</td><td>AES-GCM authentication tag (128-bit)</td></tr>
<tr><td>Nonce reuse</td><td>Random 96-bit nonce per encryption</td></tr>
<tr><td>Key leakage</td><td>Keys zeroized on drop, subkeys via HKDF</td></tr>
<tr><td>Pattern analysis</td><td>Key obfuscation, padding, metadata encryption</td></tr>
<tr><td>Access enumeration</td><td>Rate limiting, audit logging</td></tr>
<tr><td>Privilege escalation</td><td>MEMBER edges don’t grant permissions</td></tr>
<tr><td>Replay attacks</td><td>Per-operation nonces, timestamps in metadata</td></tr>
</tbody></table>
</div>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time</th><th>Notes</th></tr></thead><tbody>
<tr><td>Key derivation (Argon2id)</td><td>~80ms</td><td>64MB memory cost</td></tr>
<tr><td>set (1KB)</td><td>~29us</td><td>Includes encryption + versioning</td></tr>
<tr><td>get (1KB)</td><td>~24us</td><td>Includes decryption + audit</td></tr>
<tr><td>set (10KB)</td><td>~93us</td><td>Scales with data size</td></tr>
<tr><td>get (10KB)</td><td>~91us</td><td>Scales with data size</td></tr>
<tr><td>Access check (shallow)</td><td>~6us</td><td>Direct edge</td></tr>
<tr><td>Access check (deep, 10 hops)</td><td>~17us</td><td>BFS traversal</td></tr>
<tr><td>grant</td><td>~18us</td><td>Creates graph edge</td></tr>
<tr><td>revoke</td><td>~1.1ms</td><td>Edge deletion + TTL cleanup</td></tr>
<tr><td>list (100 secrets)</td><td>~291us</td><td>Pattern matching + access check</td></tr>
<tr><td>list (1000 secrets)</td><td>~2.7ms</td><td>Scales linearly</td></tr>
</tbody></table>
</div>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Relationship</th></tr></thead><tbody>
<tr><td><a href="tensor-store.html">Tensor Store</a></td><td>Underlying key-value storage for encrypted secrets</td></tr>
<tr><td><a href="graph-engine.html">Graph Engine</a></td><td>Access control edges and audit trail</td></tr>
<tr><td><a href="query-router.html">Query Router</a></td><td>VAULT command execution</td></tr>
<tr><td><a href="neumann-shell.html">Neumann Shell</a></td><td>Interactive vault commands</td></tr>
</tbody></table>
</div>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Crate</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>aes-gcm</code></td><td>AES-256-GCM encryption</td></tr>
<tr><td><code>argon2</code></td><td>Key derivation</td></tr>
<tr><td><code>hkdf</code></td><td>Subkey derivation</td></tr>
<tr><td><code>blake2</code></td><td>HMAC and obfuscation hashing</td></tr>
<tr><td><code>rand</code></td><td>Nonce generation</td></tr>
<tr><td><code>zeroize</code></td><td>Secure memory cleanup</td></tr>
<tr><td><code>dashmap</code></td><td>Concurrent rate limit tracking</td></tr>
<tr><td><code>serde</code></td><td>TTL grant persistence</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/tensor-compress.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/tensor-cache.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/tensor-compress.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/tensor-cache.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
