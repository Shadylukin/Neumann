<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tensor Chain - Neumann</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Unified tensor-based runtime for relational, graph, and vector data">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neumann</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann/edit/main/docs/book/src/architecture/tensor-chain.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tensor-chain-architecture"><a class="header" href="#tensor-chain-architecture">Tensor Chain Architecture</a></h1>
<p>Tensor-native blockchain with semantic conflict detection, hierarchical
codebook-based validation, and Tensor-Raft distributed consensus. This is the
most complex module in Neumann, providing distributed transaction coordination
across a cluster of nodes.</p>
<p>Tensor Chain treats transactions as geometric objects in embedding space.
Changes are represented as delta vectors, enabling similarity-based conflict
detection and automatic merging of orthogonal transactions. The module
integrates Raft consensus for leader election, two-phase commit (2PC) for
cross-shard transactions, SWIM gossip for failure detection, and wait-for graph
analysis for deadlock detection.</p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="raft-consensus"><a class="header" href="#raft-consensus">Raft Consensus</a></h3>
<p>Tensor-Raft extends the standard Raft consensus protocol with tensor-native
optimizations:</p>
<ul>
<li><strong>Similarity Fast-Path</strong>: Followers can skip full validation when block
embeddings are similar (&gt;0.95 cosine) to recent blocks from the same leader</li>
<li><strong>Geometric Tie-Breaking</strong>: During elections with equal logs, candidates with
similar state embeddings to the cluster centroid are preferred</li>
<li><strong>Pre-Vote Phase</strong>: Prevents disruptive elections by requiring majority
agreement before incrementing term</li>
<li><strong>Automatic Heartbeat</strong>: Background task spawned on leader election maintains
quorum</li>
</ul>
<p>The leader replicates log entries containing blocks to followers. Entries are
committed when a quorum (majority) acknowledges them. Committed entries are
applied to the chain state machine.</p>
<h4 id="raft-state-machine"><a class="header" href="#raft-state-machine">Raft State Machine</a></h4>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Follower: Node startup

    Follower --&gt; Candidate: Election timeout
    Follower --&gt; Follower: AppendEntries from leader
    Follower --&gt; Follower: Higher term seen

    Candidate --&gt; Leader: Received quorum votes
    Candidate --&gt; Follower: Higher term seen
    Candidate --&gt; Candidate: Election timeout (split vote)

    Leader --&gt; Follower: Higher term seen
    Leader --&gt; Follower: Lost quorum (heartbeat failure)

    note right of Follower
        Receives log entries
        Grants votes
        Resets election timer on heartbeat
    end note

    note right of Candidate
        Increments term
        Votes for self
        Requests votes from peers
    end note

    note right of Leader
        Proposes blocks
        Sends heartbeats
        Handles client requests
        Tracks replication progress
    end note
</pre>
<h4 id="pre-vote-protocol"><a class="header" href="#pre-vote-protocol">Pre-Vote Protocol</a></h4>
<p>Pre-vote prevents disruptive elections from partitioned nodes:</p>
<pre><code class="language-text">Node A (partitioned, stale)              Healthy Cluster
    |                                         |
    |-- PreVote(term=5) ---------------------&gt;|
    |                                         |
    |&lt;-- PreVoteResponse(granted=false) ------|
    |                                         |
    | Does NOT increment term                 |
    | (prevents term inflation)               |
</code></pre>
<p>A pre-vote is granted only if:</p>
<ol>
<li>Candidate’s term &gt;= our term</li>
<li>Election timeout has elapsed (no recent leader heartbeat)</li>
<li>Candidate’s log is at least as up-to-date as ours</li>
</ol>
<h4 id="log-replication-flow"><a class="header" href="#log-replication-flow">Log Replication Flow</a></h4>
<pre class="mermaid">sequenceDiagram
    participant C as Client
    participant L as Leader
    participant F1 as Follower 1
    participant F2 as Follower 2

    C-&gt;&gt;L: propose(block)

    par Replicate to followers
        L-&gt;&gt;F1: AppendEntries(entries, prev_index, commit)
        L-&gt;&gt;F2: AppendEntries(entries, prev_index, commit)
    end

    F1-&gt;&gt;L: AppendEntriesResponse(success, match_index)
    F2-&gt;&gt;L: AppendEntriesResponse(success, match_index)

    Note over L: Quorum achieved (2/3)
    L-&gt;&gt;L: Update commit_index
    L-&gt;&gt;L: Apply to state machine

    par Notify commit
        L-&gt;&gt;F1: AppendEntries(commit_index updated)
        L-&gt;&gt;F2: AppendEntries(commit_index updated)
    end

    L-&gt;&gt;C: commit_success
</pre>
<h4 id="quorum-calculation"><a class="header" href="#quorum-calculation">Quorum Calculation</a></h4>
<p>Quorum requires a strict majority of voting members:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn quorum_size(total_nodes: usize) -&gt; usize {
    (total_nodes / 2) + 1
}

// Examples:
// 3 nodes: quorum = 2
// 5 nodes: quorum = 3
// 7 nodes: quorum = 4
<span class="boring">}</span></code></pre></pre>
<h4 id="fast-path-validation"><a class="header" href="#fast-path-validation">Fast-Path Validation</a></h4>
<p>When enabled, followers can skip expensive block validation for similar blocks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FastPathValidator {
    similarity_threshold: f32,  // Default: 0.95
    min_history: usize,         // Default: 3 blocks
}

// Validation logic:
// 1. Check if we have enough history from this leader
// 2. Compute cosine similarity with recent embeddings
// 3. If similarity &gt; threshold for all recent blocks:
//    - Skip full validation
//    - Record acceptance in stats
// 4. Otherwise: perform full validation
<span class="boring">}</span></code></pre></pre>
<h3 id="two-phase-commit-2pc"><a class="header" href="#two-phase-commit-2pc">Two-Phase Commit (2PC)</a></h3>
<p>Cross-shard distributed transactions use 2PC with delta-based conflict
detection:</p>
<p><strong>Phase 1 - PREPARE</strong>: Coordinator sends <code>TxPrepareMsg</code> to each participant
shard. Participants acquire locks, compute delta embeddings, and vote <code>Yes</code>,
<code>No</code>, or <code>Conflict</code>.</p>
<p><strong>Phase 2 - COMMIT/ABORT</strong>: If all votes are <code>Yes</code> and cross-shard deltas are
orthogonal (cosine &lt; 0.1), coordinator sends <code>TxCommitMsg</code>. Otherwise, sends
<code>TxAbortMsg</code> with retry.</p>
<p>Orthogonal transactions (operating on independent data dimensions) can commit in
parallel without coordination, reducing contention.</p>
<h4 id="2pc-coordinator-state-machine"><a class="header" href="#2pc-coordinator-state-machine">2PC Coordinator State Machine</a></h4>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Preparing: begin()

    Preparing --&gt; Prepared: All votes YES + deltas orthogonal
    Preparing --&gt; Aborting: Any vote NO/Conflict
    Preparing --&gt; Aborting: Timeout
    Preparing --&gt; Aborting: Cross-shard conflict detected

    Prepared --&gt; Committing: commit()
    Prepared --&gt; Aborting: abort()

    Committing --&gt; Committed: All ACKs received
    Committing --&gt; Committed: Timeout (presumed commit)

    Aborting --&gt; Aborted: All ACKs received
    Aborting --&gt; Aborted: Timeout (presumed abort)

    Committed --&gt; [*]
    Aborted --&gt; [*]
</pre>
<h4 id="2pc-participant-state-machine"><a class="header" href="#2pc-participant-state-machine">2PC Participant State Machine</a></h4>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Idle

    Idle --&gt; LockAcquiring: TxPrepareMsg received

    LockAcquiring --&gt; Locked: Locks acquired
    LockAcquiring --&gt; VoteNo: Lock conflict

    Locked --&gt; ConflictCheck: Compute delta

    ConflictCheck --&gt; VoteYes: No conflicts
    ConflictCheck --&gt; VoteConflict: Semantic conflict

    VoteYes --&gt; WaitingDecision: Send YES vote
    VoteNo --&gt; [*]: Send NO vote
    VoteConflict --&gt; [*]: Send CONFLICT vote

    WaitingDecision --&gt; Committed: TxCommitMsg
    WaitingDecision --&gt; Aborted: TxAbortMsg
    WaitingDecision --&gt; Aborted: Timeout

    Committed --&gt; [*]: Release locks, apply ops
    Aborted --&gt; [*]: Release locks, rollback
</pre>
<h4 id="lock-ordering-deadlock-prevention"><a class="header" href="#lock-ordering-deadlock-prevention">Lock Ordering (Deadlock Prevention)</a></h4>
<p>The coordinator follows strict lock ordering to prevent internal deadlocks:</p>
<pre><code class="language-text">Lock acquisition order:
1. pending           - Transaction state map
2. lock_manager.locks     - Key-level locks
3. lock_manager.tx_locks  - Per-transaction lock sets
4. pending_aborts    - Abort queue

CRITICAL: Never acquire pending_aborts while holding pending
</code></pre>
<h4 id="wal-recovery-protocol"><a class="header" href="#wal-recovery-protocol">WAL Recovery Protocol</a></h4>
<p>The coordinator uses write-ahead logging for crash recovery:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Recovery state machine:
// 1. Replay WAL to reconstruct pending transactions
// 2. For each transaction, determine recovery action:

match tx.phase {
    TxPhase::Preparing =&gt; {
        // Incomplete prepare - abort (presumed abort)
        tx.phase = TxPhase::Aborting;
    }
    TxPhase::Prepared =&gt; {
        // All YES votes recorded - check if can commit
        if all_yes_votes &amp;&amp; deltas_orthogonal {
            tx.phase = TxPhase::Committing;
        } else {
            tx.phase = TxPhase::Aborting;
        }
    }
    TxPhase::Committing =&gt; {
        // Continue commit - presumed commit
        complete_commit(tx);
    }
    TxPhase::Aborting =&gt; {
        // Continue abort
        complete_abort(tx);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="swim-gossip-protocol"><a class="header" href="#swim-gossip-protocol">SWIM Gossip Protocol</a></h3>
<p>Scalable membership management replaces O(N) sequential pings with O(log N)
epidemic propagation:</p>
<ul>
<li><strong>Peer Sampling</strong>: Select k peers per round (default: 3) using geometric
routing</li>
<li><strong>LWW-CRDT State</strong>: Last-Writer-Wins conflict resolution with Lamport
timestamps</li>
<li><strong>Suspicion Protocol</strong>: Direct ping failure triggers indirect probes via
intermediaries. Suspicion timer (5s default) allows refutation before marking
node as failed</li>
</ul>
<h4 id="gossip-message-types"><a class="header" href="#gossip-message-types">Gossip Message Types</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum GossipMessage {
    /// Sync message with piggy-backed node states
    Sync {
        sender: NodeId,
        states: Vec&lt;GossipNodeState&gt;,
        sender_time: u64,  // Lamport timestamp
    },

    /// Suspect a node of failure
    Suspect {
        reporter: NodeId,
        suspect: NodeId,
        incarnation: u64,
    },

    /// Refute suspicion by proving aliveness
    Alive {
        node_id: NodeId,
        incarnation: u64,  // Incremented to refute
    },

    /// Indirect ping request (SWIM protocol)
    PingReq {
        origin: NodeId,
        target: NodeId,
        sequence: u64,
    },

    /// Indirect ping response
    PingAck {
        origin: NodeId,
        target: NodeId,
        sequence: u64,
        success: bool,
    },
}
<span class="boring">}</span></code></pre></pre>
<h4 id="lww-crdt-state-merging"><a class="header" href="#lww-crdt-state-merging">LWW-CRDT State Merging</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// State supersession rules:
impl GossipNodeState {
    pub fn supersedes(&amp;self, other: &amp;GossipNodeState) -&gt; bool {
        // Incarnation takes precedence
        if self.incarnation != other.incarnation {
            self.incarnation &gt; other.incarnation
        } else {
            // Same incarnation: higher timestamp wins
            self.timestamp &gt; other.timestamp
        }
    }
}

// Merge algorithm:
pub fn merge(&amp;mut self, incoming: &amp;[GossipNodeState]) -&gt; Vec&lt;NodeId&gt; {
    let mut changed = Vec::new();

    for state in incoming {
        match self.states.get(&amp;state.node_id) {
            Some(existing) if state.supersedes(existing) =&gt; {
                self.states.insert(state.node_id.clone(), state.clone());
                changed.push(state.node_id.clone());
            }
            None =&gt; {
                self.states.insert(state.node_id.clone(), state.clone());
                changed.push(state.node_id.clone());
            }
            _ =&gt; {} // Existing state is newer, ignore
        }
    }

    // Sync Lamport time to max + 1
    if let Some(max_ts) = incoming.iter().map(|s| s.timestamp).max() {
        self.lamport_time = self.lamport_time.max(max_ts) + 1;
    }

    changed
}
<span class="boring">}</span></code></pre></pre>
<h4 id="swim-failure-detection-flow"><a class="header" href="#swim-failure-detection-flow">SWIM Failure Detection Flow</a></h4>
<pre class="mermaid">sequenceDiagram
    participant A as Node A
    participant B as Node B (suspect)
    participant C as Node C (intermediary)
    participant D as Node D (intermediary)

    A-&gt;&gt;B: Direct Ping
    Note over B: No response (timeout)

    par Indirect probes
        A-&gt;&gt;C: PingReq(target=B)
        A-&gt;&gt;D: PingReq(target=B)
    end

    C-&gt;&gt;B: Ping (on behalf of A)
    D-&gt;&gt;B: Ping (on behalf of A)

    alt B responds to C
        B-&gt;&gt;C: Pong
        C-&gt;&gt;A: PingAck(success=true)
        Note over A: B is healthy
    else All indirect pings fail
        C-&gt;&gt;A: PingAck(success=false)
        D-&gt;&gt;A: PingAck(success=false)
        Note over A: Start suspicion timer (5s)
        A-&gt;&gt;A: Broadcast Suspect(B)

        alt B refutes within 5s
            B-&gt;&gt;A: Alive(incarnation++)
            Note over A: Cancel suspicion
        else Timer expires
            Note over A: Mark B as Failed
        end
    end
</pre>
<h4 id="incarnation-number-protocol"><a class="header" href="#incarnation-number-protocol">Incarnation Number Protocol</a></h4>
<pre><code class="language-text">Scenario: Node B receives Suspect about itself

B's current incarnation: 5
Suspect message incarnation: 5

B increments: incarnation = 6
B broadcasts: Alive { node_id: B, incarnation: 6 }

All nodes receiving Alive update B's state:
- incarnation: 6
- health: Healthy
- timestamp: &lt;lamport_time++&gt;
</code></pre>
<h3 id="deadlock-detection"><a class="header" href="#deadlock-detection">Deadlock Detection</a></h3>
<p>Wait-for graph tracks transaction dependencies for cycle detection:</p>
<ol>
<li>Edge <code>A -&gt; B</code> added when transaction A blocks waiting for B to release locks</li>
<li>Periodic DFS traversal detects cycles (deadlocks)</li>
<li>Victim selected based on policy (youngest, oldest, lowest priority, or most
locks)</li>
<li>Victim transaction aborted to break the cycle</li>
</ol>
<h4 id="wait-for-graph-structure"><a class="header" href="#wait-for-graph-structure">Wait-For Graph Structure</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WaitForGraph {
    /// Maps tx_id -&gt; set of tx_ids it is waiting for
    edges: HashMap&lt;u64, HashSet&lt;u64&gt;&gt;,

    /// Reverse edges for O(1) removal: holder -&gt; waiters
    reverse_edges: HashMap&lt;u64, HashSet&lt;u64&gt;&gt;,

    /// Timestamp when wait started (for victim selection)
    wait_started: HashMap&lt;u64, EpochMillis&gt;,

    /// Priority values (lower = higher priority)
    priorities: HashMap&lt;u64, u32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="tarjans-dfs-cycle-detection-algorithm"><a class="header" href="#tarjans-dfs-cycle-detection-algorithm">Tarjan’s DFS Cycle Detection Algorithm</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dfs_detect(
    &amp;self,
    node: u64,
    edges: &amp;HashMap&lt;u64, HashSet&lt;u64&gt;&gt;,
    visited: &amp;mut HashSet&lt;u64&gt;,
    rec_stack: &amp;mut HashSet&lt;u64&gt;,  // Current recursion path
    path: &amp;mut Vec&lt;u64&gt;,           // Explicit path for extraction
    cycles: &amp;mut Vec&lt;Vec&lt;u64&gt;&gt;,
) {
    visited.insert(node);
    rec_stack.insert(node);
    path.push(node);

    if let Some(neighbors) = edges.get(&amp;node) {
        for &amp;neighbor in neighbors {
            if !visited.contains(&amp;neighbor) {
                // Continue DFS on unvisited
                self.dfs_detect(neighbor, edges, visited, rec_stack, path, cycles);
            } else if rec_stack.contains(&amp;neighbor) {
                // Back-edge to ancestor = cycle found!
                if let Some(cycle_start) = path.iter().position(|&amp;n| n == neighbor) {
                    cycles.push(path[cycle_start..].to_vec());
                }
            }
        }
    }

    path.pop();
    rec_stack.remove(&amp;node);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="victim-selection-policies"><a class="header" href="#victim-selection-policies">Victim Selection Policies</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Policy</th><th>Selection Criteria</th><th>Trade-off</th></tr></thead><tbody>
<tr><td><code>Youngest</code></td><td>Most recent wait start (highest timestamp)</td><td>Minimizes wasted work, may starve long transactions</td></tr>
<tr><td><code>Oldest</code></td><td>Earliest wait start (lowest timestamp)</td><td>Prevents starvation, wastes more completed work</td></tr>
<tr><td><code>LowestPriority</code></td><td>Highest priority value</td><td>Business-rule based, requires priority assignment</td></tr>
<tr><td><code>MostLocks</code></td><td>Transaction holding most locks</td><td>Maximizes freed resources, may abort complex transactions</td></tr>
</tbody></table>
</div>
<h3 id="ed25519-signing-and-identity"><a class="header" href="#ed25519-signing-and-identity">Ed25519 Signing and Identity</a></h3>
<p>Cryptographic identity binding ensures message authenticity and enables
geometric routing:</p>
<h4 id="identity-generation-and-nodeid-derivation"><a class="header" href="#identity-generation-and-nodeid-derivation">Identity Generation and NodeId Derivation</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Identity {
    signing_key: SigningKey,  // Ed25519 private key (zeroized on drop)
}

impl Identity {
    pub fn generate() -&gt; Self {
        let signing_key = SigningKey::generate(&amp;mut OsRng);
        Self { signing_key }
    }

    /// NodeId = BLAKE2b-128(domain || public_key)
    /// 16 bytes = 32 hex characters
    pub fn node_id(&amp;self) -&gt; NodeId {
        let mut hasher = Blake2b::&lt;U16&gt;::new();
        hasher.update(b"neumann_node_id_v1");
        hasher.update(self.signing_key.verifying_key().as_bytes());
        hex::encode(hasher.finalize())
    }

    /// Embedding = BLAKE2b-512(domain || public_key) -&gt; 16 f32 coords
    /// Normalized to [-1, 1] for geometric operations
    pub fn to_embedding(&amp;self) -&gt; SparseVector {
        let mut hasher = Blake2b::&lt;U64&gt;::new();
        hasher.update(b"neumann_node_embedding_v1");
        hasher.update(self.signing_key.verifying_key().as_bytes());
        let hash = hasher.finalize();

        // 64 bytes -&gt; 16 f32 coordinates
        let coords: Vec&lt;f32&gt; = hash.chunks(4)
            .map(|c| {
                let bits = u32::from_le_bytes([c[0], c[1], c[2], c[3]]);
                (bits as f64 / u32::MAX as f64 * 2.0 - 1.0) as f32
            })
            .collect();

        SparseVector::from_dense(&amp;coords)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="signed-message-envelope"><a class="header" href="#signed-message-envelope">Signed Message Envelope</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SignedMessage {
    pub sender: NodeId,           // Derived from public key
    pub public_key: [u8; 32],     // Ed25519 verifying key
    pub payload: Vec&lt;u8&gt;,         // Message content
    pub signature: Vec&lt;u8&gt;,       // 64-byte Ed25519 signature
    pub sequence: u64,            // Replay protection
    pub timestamp_ms: u64,        // Freshness check
}

// Signature covers: sender || sequence || timestamp || payload
// This binds identity, ordering, and content together
<span class="boring">}</span></code></pre></pre>
<h4 id="replay-protection"><a class="header" href="#replay-protection">Replay Protection</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SequenceTracker {
    sequences: DashMap&lt;NodeId, (u64, Instant)&gt;,
    config: SequenceTrackerConfig,
}

impl SequenceTracker {
    pub fn check_and_record(
        &amp;self,
        sender: &amp;NodeId,
        sequence: u64,
        timestamp_ms: u64,
    ) -&gt; Result&lt;()&gt; {
        // 1. Reject messages from the future (allow 1 min clock skew)
        if timestamp_ms &gt; now_ms + 60_000 {
            return Err("message timestamp is in the future");
        }

        // 2. Reject stale messages (default: 5 min max age)
        if now_ms &gt; timestamp_ms + self.config.max_age_ms {
            return Err("message too old");
        }

        // 3. Check sequence number is strictly increasing
        let entry = self.sequences.entry(sender.clone()).or_insert((0, now));
        if sequence &lt;= entry.0 {
            return Err("replay detected: sequence &lt;= last seen");
        }

        *entry = (sequence, now);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="message-validation-pipeline"><a class="header" href="#message-validation-pipeline">Message Validation Pipeline</a></h3>
<p>All incoming messages pass through validation before processing:</p>
<pre class="mermaid">flowchart TB
    subgraph Validation[&quot;Message Validation Pipeline&quot;]
        Input[&quot;Incoming Message&quot;]
        NodeIdCheck[&quot;Validate NodeId Format&quot;]
        TypeDispatch[&quot;Dispatch by Type&quot;]

        TermCheck[&quot;Validate Term Bounds&quot;]
        ShardCheck[&quot;Validate Shard ID&quot;]
        TimeoutCheck[&quot;Validate Timeout&quot;]
        EmbeddingCheck[&quot;Validate Embedding&quot;]
        SignatureCheck[&quot;Validate Signature&quot;]

        Accept[&quot;Accept Message&quot;]
        Reject[&quot;Reject with Error&quot;]
    end

    Input --&gt; NodeIdCheck
    NodeIdCheck --&gt;|Invalid| Reject
    NodeIdCheck --&gt;|Valid| TypeDispatch

    TypeDispatch --&gt;|Raft| TermCheck
    TypeDispatch --&gt;|2PC| ShardCheck
    TypeDispatch --&gt;|Signed| SignatureCheck

    TermCheck --&gt;|Invalid| Reject
    TermCheck --&gt;|Valid| EmbeddingCheck

    ShardCheck --&gt;|Invalid| Reject
    ShardCheck --&gt;|Valid| TimeoutCheck

    TimeoutCheck --&gt;|Invalid| Reject
    TimeoutCheck --&gt;|Valid| EmbeddingCheck

    EmbeddingCheck --&gt;|Invalid| Reject
    EmbeddingCheck --&gt;|Valid| Accept

    SignatureCheck --&gt;|Invalid| Reject
    SignatureCheck --&gt;|Valid| Accept
</pre>
<h4 id="embedding-validation"><a class="header" href="#embedding-validation">Embedding Validation</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EmbeddingValidator {
    max_dimension: usize,    // Default: 65,536
    max_magnitude: f32,      // Default: 1,000,000
}

impl EmbeddingValidator {
    pub fn validate(&amp;self, embedding: &amp;SparseVector, field: &amp;str) -&gt; Result&lt;()&gt; {
        // 1. Dimension bounds
        if embedding.dimension() == 0 {
            return Err("dimension cannot be zero");
        }
        if embedding.dimension() &gt; self.max_dimension {
            return Err("dimension exceeds maximum");
        }

        // 2. NaN/Inf detection (prevents computation errors)
        for (i, value) in embedding.values().iter().enumerate() {
            if value.is_nan() {
                return Err(format!("NaN value at position {}", i));
            }
            if value.is_infinite() {
                return Err(format!("infinite value at position {}", i));
            }
        }

        // 3. Magnitude bounds (prevents DoS via huge vectors)
        if embedding.magnitude() &gt; self.max_magnitude {
            return Err("magnitude exceeds maximum");
        }

        // 4. Position validity (sorted, within bounds)
        let positions = embedding.positions();
        for (i, &amp;pos) in positions.iter().enumerate() {
            if pos as usize &gt;= embedding.dimension() {
                return Err("position out of bounds");
            }
            if i &gt; 0 &amp;&amp; positions[i - 1] &gt;= pos {
                return Err("positions not strictly sorted");
            }
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="semantic-conflict-detection"><a class="header" href="#semantic-conflict-detection">Semantic Conflict Detection</a></h3>
<p>The consensus manager uses hybrid detection combining angular and structural
similarity:</p>
<h4 id="conflict-classification-algorithm"><a class="header" href="#conflict-classification-algorithm">Conflict Classification Algorithm</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn detect_conflict(&amp;self, d1: &amp;DeltaVector, d2: &amp;DeltaVector) -&gt; ConflictResult {
    let cosine = d1.cosine_similarity(d2);
    let jaccard = d1.structural_similarity(d2);  // Jaccard index
    let overlapping_keys = d1.overlapping_keys(d2);
    let all_keys_overlap = overlapping_keys.len() == d1.affected_keys.len()
        &amp;&amp; overlapping_keys.len() == d2.affected_keys.len();

    // Classification hierarchy:
    let (class, action) = if cosine &gt;= 0.99 &amp;&amp; all_keys_overlap {
        // Identical: same direction, same keys
        (ConflictClass::Identical, MergeAction::Deduplicate)

    } else if cosine &lt;= -0.95 &amp;&amp; all_keys_overlap {
        // Opposite: cancel out (A + (-A) = 0)
        (ConflictClass::Opposite, MergeAction::Cancel)

    } else if cosine.abs() &lt; 0.1 &amp;&amp; jaccard &lt; 0.5 {
        // Truly orthogonal: different directions AND different positions
        (ConflictClass::Orthogonal, MergeAction::VectorAdd)

    } else if cosine &gt;= 0.7 {
        // Angular conflict: pointing same direction
        (ConflictClass::Conflicting, MergeAction::Reject)

    } else if jaccard &gt;= 0.5 {
        // Structural conflict: same positions modified
        // Catches conflicts that cosine misses
        (ConflictClass::Conflicting, MergeAction::Reject)

    } else if !overlapping_keys.is_empty() {
        // Key overlap without structural/angular conflict
        (ConflictClass::Ambiguous, MergeAction::Reject)

    } else {
        // Low conflict: merge with weighted average
        (ConflictClass::LowConflict, MergeAction::WeightedAverage {
            weight1: 50, weight2: 50
        })
    };

    ConflictResult { class, cosine, jaccard, overlapping_keys, action, .. }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="merge-operations"><a class="header" href="#merge-operations">Merge Operations</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DeltaVector {
    /// Vector addition for orthogonal deltas
    pub fn add(&amp;self, other: &amp;DeltaVector) -&gt; DeltaVector {
        let delta = self.delta.add(&amp;other.delta);
        let keys = self.affected_keys.union(&amp;other.affected_keys).cloned().collect();
        DeltaVector::from_sparse(delta, keys, 0)
    }

    /// Weighted average for low-conflict deltas
    pub fn weighted_average(&amp;self, other: &amp;DeltaVector, w1: f32, w2: f32) -&gt; DeltaVector {
        let total = w1 + w2;
        if total == 0.0 {
            return DeltaVector::zero(0);
        }
        let delta = self.delta.weighted_average(&amp;other.delta, w1, w2);
        let keys = self.affected_keys.union(&amp;other.affected_keys).cloned().collect();
        DeltaVector::from_sparse(delta, keys, 0)
    }

    /// Project out conflicting component
    pub fn project_non_conflicting(&amp;self, conflict_direction: &amp;SparseVector) -&gt; DeltaVector {
        let delta = self.delta.project_orthogonal(conflict_direction);
        DeltaVector::from_sparse(delta, self.affected_keys.clone(), self.tx_id)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="types-reference"><a class="header" href="#types-reference">Types Reference</a></h2>
<h3 id="core-types"><a class="header" href="#core-types">Core Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Module</th><th>Description</th></tr></thead><tbody>
<tr><td><code>TensorChain</code></td><td><code>lib.rs</code></td><td>Main API for chain operations, transaction management</td></tr>
<tr><td><code>Block</code></td><td><code>block.rs</code></td><td>Block structure with header, transactions, signatures</td></tr>
<tr><td><code>BlockHeader</code></td><td><code>block.rs</code></td><td>Height, prev_hash, delta_embedding, quantized_codes</td></tr>
<tr><td><code>Transaction</code></td><td><code>block.rs</code></td><td>Put, Delete, Update operations</td></tr>
<tr><td><code>ChainConfig</code></td><td><code>lib.rs</code></td><td>Node ID, max transactions, conflict threshold, auto-merge</td></tr>
<tr><td><code>ChainError</code></td><td><code>error.rs</code></td><td>Error types for all chain operations</td></tr>
<tr><td><code>ChainMetrics</code></td><td><code>lib.rs</code></td><td>Aggregated metrics from all components</td></tr>
</tbody></table>
</div>
<h3 id="consensus-types"><a class="header" href="#consensus-types">Consensus Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Module</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RaftNode</code></td><td><code>raft.rs</code></td><td>Raft state machine with leader election, log replication</td></tr>
<tr><td><code>RaftState</code></td><td><code>raft.rs</code></td><td>Follower, Candidate, or Leader</td></tr>
<tr><td><code>RaftConfig</code></td><td><code>raft.rs</code></td><td>Election timeout, heartbeat interval, fast-path settings</td></tr>
<tr><td><code>RaftStats</code></td><td><code>raft.rs</code></td><td>Fast-path acceptance, heartbeat timing, quorum tracking</td></tr>
<tr><td><code>QuorumTracker</code></td><td><code>raft.rs</code></td><td>Tracks heartbeat responses to detect quorum loss</td></tr>
<tr><td><code>SnapshotMetadata</code></td><td><code>raft.rs</code></td><td>Log compaction point with hash and membership config</td></tr>
<tr><td><code>LogEntry</code></td><td><code>network.rs</code></td><td>Raft log entry with term, index, and data</td></tr>
<tr><td><code>ConsensusManager</code></td><td><code>consensus.rs</code></td><td>Semantic conflict detection and transaction merging</td></tr>
<tr><td><code>DeltaVector</code></td><td><code>consensus.rs</code></td><td>Sparse delta embedding with affected keys</td></tr>
<tr><td><code>ConflictClass</code></td><td><code>consensus.rs</code></td><td>Orthogonal, LowConflict, Ambiguous, Conflicting, Identical, Opposite</td></tr>
<tr><td><code>FastPathValidator</code></td><td><code>validation.rs</code></td><td>Block similarity validation for fast-path acceptance</td></tr>
<tr><td><code>FastPathState</code></td><td><code>raft.rs</code></td><td>Per-leader embedding history for fast-path</td></tr>
<tr><td><code>TransferState</code></td><td><code>raft.rs</code></td><td>Active leadership transfer tracking</td></tr>
<tr><td><code>HeartbeatStats</code></td><td><code>raft.rs</code></td><td>Heartbeat success/failure counters</td></tr>
</tbody></table>
</div>
<h3 id="distributed-transaction-types"><a class="header" href="#distributed-transaction-types">Distributed Transaction Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Module</th><th>Description</th></tr></thead><tbody>
<tr><td><code>DistributedTxCoordinator</code></td><td><code>distributed_tx.rs</code></td><td>2PC coordinator with timeout and retry</td></tr>
<tr><td><code>DistributedTransaction</code></td><td><code>distributed_tx.rs</code></td><td>Transaction spanning multiple shards</td></tr>
<tr><td><code>TxPhase</code></td><td><code>distributed_tx.rs</code></td><td>Preparing, Prepared, Committing, Committed, Aborting, Aborted</td></tr>
<tr><td><code>PrepareVote</code></td><td><code>distributed_tx.rs</code></td><td>Yes (with lock handle), No (with reason), Conflict</td></tr>
<tr><td><code>LockManager</code></td><td><code>distributed_tx.rs</code></td><td>Key-level locking for transaction isolation</td></tr>
<tr><td><code>KeyLock</code></td><td><code>distributed_tx.rs</code></td><td>Lock on a key with timeout and handle</td></tr>
<tr><td><code>TxWal</code></td><td><code>tx_wal.rs</code></td><td>Write-ahead log for crash recovery</td></tr>
<tr><td><code>TxWalEntry</code></td><td><code>tx_wal.rs</code></td><td>WAL entry types: TxBegin, PrepareVote, PhaseChange, TxComplete</td></tr>
<tr><td><code>TxRecoveryState</code></td><td><code>tx_wal.rs</code></td><td>Reconstructed state from WAL replay</td></tr>
<tr><td><code>PrepareRequest</code></td><td><code>distributed_tx.rs</code></td><td>Request to prepare a transaction on a shard</td></tr>
<tr><td><code>CommitRequest</code></td><td><code>distributed_tx.rs</code></td><td>Request to commit a prepared transaction</td></tr>
<tr><td><code>AbortRequest</code></td><td><code>distributed_tx.rs</code></td><td>Request to abort a transaction</td></tr>
<tr><td><code>CoordinatorState</code></td><td><code>distributed_tx.rs</code></td><td>Serializable coordinator state for persistence</td></tr>
<tr><td><code>ParticipantState</code></td><td><code>distributed_tx.rs</code></td><td>Serializable participant state for persistence</td></tr>
</tbody></table>
</div>
<h3 id="gossip-types"><a class="header" href="#gossip-types">Gossip Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Module</th><th>Description</th></tr></thead><tbody>
<tr><td><code>GossipMembershipManager</code></td><td><code>gossip.rs</code></td><td>SWIM-style gossip with signing support</td></tr>
<tr><td><code>GossipConfig</code></td><td><code>gossip.rs</code></td><td>Fanout, interval, suspicion timeout, signature requirements</td></tr>
<tr><td><code>GossipMessage</code></td><td><code>gossip.rs</code></td><td>Sync, Suspect, Alive, PingReq, PingAck</td></tr>
<tr><td><code>GossipNodeState</code></td><td><code>gossip.rs</code></td><td>Node health, Lamport timestamp, incarnation</td></tr>
<tr><td><code>LWWMembershipState</code></td><td><code>gossip.rs</code></td><td>CRDT for conflict-free state merging</td></tr>
<tr><td><code>PendingSuspicion</code></td><td><code>gossip.rs</code></td><td>Suspicion timer tracking</td></tr>
<tr><td><code>HealProgress</code></td><td><code>gossip.rs</code></td><td>Recovery tracking for partitioned nodes</td></tr>
<tr><td><code>SignedGossipMessage</code></td><td><code>signing.rs</code></td><td>Gossip message with Ed25519 signature</td></tr>
</tbody></table>
</div>
<h3 id="deadlock-detection-types"><a class="header" href="#deadlock-detection-types">Deadlock Detection Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Module</th><th>Description</th></tr></thead><tbody>
<tr><td><code>DeadlockDetector</code></td><td><code>deadlock.rs</code></td><td>Cycle detection with configurable victim selection</td></tr>
<tr><td><code>WaitForGraph</code></td><td><code>deadlock.rs</code></td><td>Directed graph of transaction dependencies</td></tr>
<tr><td><code>DeadlockInfo</code></td><td><code>deadlock.rs</code></td><td>Detected cycle with selected victim</td></tr>
<tr><td><code>VictimSelectionPolicy</code></td><td><code>deadlock.rs</code></td><td>Youngest, Oldest, LowestPriority, MostLocks</td></tr>
<tr><td><code>DeadlockStats</code></td><td><code>deadlock.rs</code></td><td>Detection timing and cycle length statistics</td></tr>
<tr><td><code>WaitInfo</code></td><td><code>deadlock.rs</code></td><td>Lock conflict information for wait-graph edges</td></tr>
</tbody></table>
</div>
<h3 id="identity-and-signing-types"><a class="header" href="#identity-and-signing-types">Identity and Signing Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Module</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Identity</code></td><td><code>signing.rs</code></td><td>Ed25519 private key (zeroized on drop)</td></tr>
<tr><td><code>PublicIdentity</code></td><td><code>signing.rs</code></td><td>Ed25519 public key for verification</td></tr>
<tr><td><code>SignedMessage</code></td><td><code>signing.rs</code></td><td>Message envelope with signature and replay protection</td></tr>
<tr><td><code>ValidatorRegistry</code></td><td><code>signing.rs</code></td><td>Registry of known validator public keys</td></tr>
<tr><td><code>SequenceTracker</code></td><td><code>signing.rs</code></td><td>Replay attack detection via sequence numbers</td></tr>
<tr><td><code>SequenceTrackerConfig</code></td><td><code>signing.rs</code></td><td>Max age, max entries, cleanup interval</td></tr>
</tbody></table>
</div>
<h3 id="message-validation-types"><a class="header" href="#message-validation-types">Message Validation Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Module</th><th>Description</th></tr></thead><tbody>
<tr><td><code>MessageValidationConfig</code></td><td><code>message_validation.rs</code></td><td>Bounds for DoS prevention</td></tr>
<tr><td><code>CompositeValidator</code></td><td><code>message_validation.rs</code></td><td>Validates all message types</td></tr>
<tr><td><code>EmbeddingValidator</code></td><td><code>message_validation.rs</code></td><td>Checks dimension, magnitude, NaN/Inf</td></tr>
<tr><td><code>MessageValidator</code></td><td><code>message_validation.rs</code></td><td>Trait for pluggable validation</td></tr>
</tbody></table>
</div>
<h2 id="architecture-diagram"><a class="header" href="#architecture-diagram">Architecture Diagram</a></h2>
<pre class="mermaid">flowchart TB
    subgraph Client[&quot;Client Layer&quot;]
        TensorChain[&quot;TensorChain API&quot;]
        TransactionWorkspace[&quot;Transaction Workspace&quot;]
    end

    subgraph Consensus[&quot;Consensus Layer&quot;]
        RaftNode[&quot;Raft Node&quot;]
        ConsensusManager[&quot;Consensus Manager&quot;]
        FastPath[&quot;Fast-Path Validator&quot;]
    end

    subgraph Network[&quot;Network Layer&quot;]
        Transport[&quot;Transport Trait&quot;]
        TcpTransport[&quot;TCP Transport&quot;]
        MemoryTransport[&quot;Memory Transport&quot;]
        MessageValidator[&quot;Message Validator&quot;]
    end

    subgraph Membership[&quot;Membership Layer&quot;]
        GossipManager[&quot;Gossip Manager&quot;]
        MembershipManager[&quot;Membership Manager&quot;]
        GeometricMembership[&quot;Geometric Membership&quot;]
    end

    subgraph DistTx[&quot;Distributed Transactions&quot;]
        Coordinator[&quot;2PC Coordinator&quot;]
        LockManager[&quot;Lock Manager&quot;]
        DeadlockDetector[&quot;Deadlock Detector&quot;]
        TxWal[&quot;Transaction WAL&quot;]
    end

    subgraph Storage[&quot;Storage Layer&quot;]
        Chain[&quot;Chain (Graph Engine)&quot;]
        Codebook[&quot;Codebook Manager&quot;]
        RaftWal[&quot;Raft WAL&quot;]
    end

    TensorChain --&gt; TransactionWorkspace
    TensorChain --&gt; ConsensusManager
    TensorChain --&gt; Codebook

    TransactionWorkspace --&gt; Chain

    RaftNode --&gt; Transport
    RaftNode --&gt; ConsensusManager
    RaftNode --&gt; FastPath
    RaftNode --&gt; RaftWal

    Transport --&gt; TcpTransport
    Transport --&gt; MemoryTransport
    TcpTransport --&gt; MessageValidator

    GossipManager --&gt; Transport
    GossipManager --&gt; MembershipManager
    MembershipManager --&gt; GeometricMembership

    Coordinator --&gt; LockManager
    Coordinator --&gt; DeadlockDetector
    Coordinator --&gt; Transport
    Coordinator --&gt; TxWal

    LockManager --&gt; DeadlockDetector

    Chain --&gt; Codebook
</pre>
<h2 id="subsystems"><a class="header" href="#subsystems">Subsystems</a></h2>
<h3 id="consensus-subsystem"><a class="header" href="#consensus-subsystem">Consensus Subsystem</a></h3>
<p>The Raft consensus implementation provides strong consistency guarantees:</p>
<p><strong>State Machine</strong>:</p>
<ul>
<li><code>Follower</code>: Receives AppendEntries from leader, grants votes</li>
<li><code>Candidate</code>: Requests votes after election timeout</li>
<li><code>Leader</code>: Proposes blocks, sends heartbeats, handles client requests</li>
</ul>
<p><strong>Log Replication</strong>:</p>
<pre><code class="language-sql">Leader:  propose(block) -&gt; AppendEntries to followers
                        -&gt; Wait for quorum acknowledgment
                        -&gt; Update commit_index
                        -&gt; Apply to state machine
</code></pre>
<p><strong>Fast-Path Validation</strong>:
When enabled and block embedding similarity exceeds threshold (default 0.95),
followers skip full validation. This optimization assumes semantically similar
blocks from the same leader are likely valid.</p>
<p><strong>Log Compaction</strong>:
After <code>snapshot_threshold</code> entries (default 10,000), a snapshot captures the
state machine at the commit point. Entries before the snapshot can be truncated,
keeping only <code>snapshot_trailing_logs</code> entries for followers catching up.</p>
<h3 id="distributed-transactions-subsystem"><a class="header" href="#distributed-transactions-subsystem">Distributed Transactions Subsystem</a></h3>
<p>Cross-shard coordination uses two-phase commit with tensor-native conflict
detection:</p>
<p><strong>Phase 1 - Prepare</strong>:</p>
<pre><code class="language-text">Coordinator                    Participant (per shard)
    |                                  |
    |--- TxPrepareMsg ---------------&gt;|
    |    (ops, delta_embedding)        |
    |                                  |-- acquire locks
    |                                  |-- compute local delta
    |                                  |-- check conflicts
    |&lt;--- TxPrepareResponse ----------|
    |     (Yes/No/Conflict)            |
</code></pre>
<p><strong>Phase 2 - Commit or Abort</strong>:</p>
<pre><code class="language-text">If all Yes AND deltas orthogonal:
    |--- TxCommitMsg ----------------&gt;| -- release locks, apply ops
    |&lt;--- TxAckMsg -------------------|

Otherwise:
    |--- TxAbortMsg -----------------&gt;| -- release locks, rollback
    |&lt;--- TxAckMsg -------------------|
</code></pre>
<p><strong>Conflict Detection</strong>:
Uses hybrid detection combining cosine similarity (angular conflict) and Jaccard
index (structural conflict):</p>
<div class="table-wrapper"><table><thead><tr><th>Cosine</th><th>Jaccard</th><th>Classification</th><th>Action</th></tr></thead><tbody>
<tr><td>&lt; 0.1</td><td>&lt; 0.5</td><td>Orthogonal</td><td>Auto-merge (vector add)</td></tr>
<tr><td>0.1-0.7</td><td>&lt; 0.5</td><td>LowConflict</td><td>Weighted merge</td></tr>
<tr><td>&gt;= 0.7</td><td>any</td><td>Conflicting</td><td>Reject</td></tr>
<tr><td>any</td><td>&gt;= 0.5</td><td>Conflicting</td><td>Reject (structural)</td></tr>
<tr><td>&gt;= 0.99</td><td>all keys</td><td>Identical</td><td>Deduplicate</td></tr>
<tr><td>&lt;= -0.95</td><td>all keys</td><td>Opposite</td><td>Cancel (no-op)</td></tr>
</tbody></table>
</div>
<h3 id="gossip-protocol-subsystem"><a class="header" href="#gossip-protocol-subsystem">Gossip Protocol Subsystem</a></h3>
<p>SWIM-style failure detection with LWW-CRDT state:</p>
<p><strong>Gossip Round</strong>:</p>
<pre><code class="language-sql">1. Select k peers (fanout=3) using geometric routing
2. Send Sync message with piggybacked node states
3. Merge received states (higher incarnation wins)
4. Update Lamport time
</code></pre>
<p><strong>Failure Detection</strong>:</p>
<pre><code class="language-text">Direct ping failed
    |
    v
Send PingReq to k intermediaries
    |
    v
All indirect pings failed?
    |-- No --&gt; Mark healthy
    |-- Yes --&gt; Start suspicion timer (5s)
                    |
                    v
                Timer expired without Alive?
                    |-- No --&gt; Mark healthy (refuted)
                    |-- Yes --&gt; Mark failed
</code></pre>
<p><strong>Incarnation Numbers</strong>:
When a node receives a Suspect about itself, it increments its incarnation and
broadcasts Alive to refute the suspicion.</p>
<h3 id="deadlock-detection-subsystem"><a class="header" href="#deadlock-detection-subsystem">Deadlock Detection Subsystem</a></h3>
<p>Wait-for graph analysis for cycle detection:</p>
<p><strong>Graph Structure</strong>:</p>
<pre><code class="language-text">Edge: waiter_tx -&gt; holder_tx
Meaning: waiter is blocked waiting for holder to release locks
</code></pre>
<p><strong>Detection Algorithm</strong> (Tarjan’s DFS):</p>
<pre><code class="language-sql">1. For each unvisited node, start DFS
2. Track recursion stack for back-edge detection
3. Back-edge to ancestor = cycle found
4. Extract cycle path for victim selection
</code></pre>
<p><strong>Victim Selection Policies</strong>:</p>
<ul>
<li><code>Youngest</code>: Abort most recent transaction (minimize wasted work)</li>
<li><code>Oldest</code>: Abort earliest transaction (prevent starvation)</li>
<li><code>LowestPriority</code>: Abort transaction with highest priority value</li>
<li><code>MostLocks</code>: Abort transaction holding most locks (minimize cascade)</li>
</ul>
<h2 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h2>
<h3 id="raftconfig"><a class="header" href="#raftconfig">RaftConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>election_timeout</code></td><td>(150, 300)</td><td>Random timeout range in ms</td></tr>
<tr><td><code>heartbeat_interval</code></td><td>50</td><td>Heartbeat interval in ms</td></tr>
<tr><td><code>similarity_threshold</code></td><td>0.95</td><td>Fast-path similarity threshold</td></tr>
<tr><td><code>enable_fast_path</code></td><td>true</td><td>Enable fast-path validation</td></tr>
<tr><td><code>enable_pre_vote</code></td><td>true</td><td>Enable pre-vote phase</td></tr>
<tr><td><code>enable_geometric_tiebreak</code></td><td>true</td><td>Enable geometric tie-breaking</td></tr>
<tr><td><code>geometric_tiebreak_threshold</code></td><td>0.3</td><td>Minimum similarity for tiebreak</td></tr>
<tr><td><code>snapshot_threshold</code></td><td>10,000</td><td>Entries before compaction</td></tr>
<tr><td><code>snapshot_trailing_logs</code></td><td>100</td><td>Entries to keep after snapshot</td></tr>
<tr><td><code>snapshot_chunk_size</code></td><td>1MB</td><td>Chunk size for snapshot transfer</td></tr>
<tr><td><code>transfer_timeout_ms</code></td><td>1,000</td><td>Leadership transfer timeout</td></tr>
<tr><td><code>compaction_check_interval</code></td><td>10</td><td>Ticks between compaction checks</td></tr>
<tr><td><code>compaction_cooldown_ms</code></td><td>60,000</td><td>Minimum time between compactions</td></tr>
<tr><td><code>snapshot_max_memory</code></td><td>256MB</td><td>Max memory for snapshot buffering</td></tr>
<tr><td><code>auto_heartbeat</code></td><td>true</td><td>Spawn heartbeat task on leader election</td></tr>
<tr><td><code>max_heartbeat_failures</code></td><td>3</td><td>Failures before logging warning</td></tr>
</tbody></table>
</div>
<h3 id="distributedtxconfig"><a class="header" href="#distributedtxconfig">DistributedTxConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>max_concurrent</code></td><td>100</td><td>Maximum concurrent transactions</td></tr>
<tr><td><code>prepare_timeout_ms</code></td><td>5,000</td><td>Prepare phase timeout</td></tr>
<tr><td><code>commit_timeout_ms</code></td><td>10,000</td><td>Commit phase timeout</td></tr>
<tr><td><code>orthogonal_threshold</code></td><td>0.1</td><td>Cosine threshold for orthogonality</td></tr>
<tr><td><code>optimistic_locking</code></td><td>true</td><td>Enable semantic conflict detection</td></tr>
</tbody></table>
</div>
<h3 id="gossipconfig"><a class="header" href="#gossipconfig">GossipConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>fanout</code></td><td>3</td><td>Peers per gossip round</td></tr>
<tr><td><code>gossip_interval_ms</code></td><td>200</td><td>Interval between rounds</td></tr>
<tr><td><code>suspicion_timeout_ms</code></td><td>5,000</td><td>Time before failure declaration</td></tr>
<tr><td><code>max_states_per_message</code></td><td>20</td><td>State limit per message</td></tr>
<tr><td><code>geometric_routing</code></td><td>true</td><td>Use embedding-based peer selection</td></tr>
<tr><td><code>indirect_ping_count</code></td><td>3</td><td>Indirect pings on direct failure</td></tr>
<tr><td><code>indirect_ping_timeout_ms</code></td><td>500</td><td>Timeout for indirect pings</td></tr>
<tr><td><code>require_signatures</code></td><td>false</td><td>Require Ed25519 signatures</td></tr>
<tr><td><code>max_message_age_ms</code></td><td>300,000</td><td>Maximum signed message age</td></tr>
</tbody></table>
</div>
<h3 id="deadlockdetectorconfig"><a class="header" href="#deadlockdetectorconfig">DeadlockDetectorConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>true</td><td>Enable deadlock detection</td></tr>
<tr><td><code>detection_interval_ms</code></td><td>100</td><td>Detection cycle interval</td></tr>
<tr><td><code>victim_policy</code></td><td>Youngest</td><td>Victim selection policy</td></tr>
<tr><td><code>max_cycle_length</code></td><td>100</td><td>Maximum detectable cycle length</td></tr>
<tr><td><code>auto_abort_victim</code></td><td>true</td><td>Automatically abort victim</td></tr>
</tbody></table>
</div>
<h3 id="messagevalidationconfig"><a class="header" href="#messagevalidationconfig">MessageValidationConfig</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>true</td><td>Enable validation</td></tr>
<tr><td><code>max_term</code></td><td>u64::MAX - 1</td><td>Prevent overflow attacks</td></tr>
<tr><td><code>max_shard_id</code></td><td>65,536</td><td>Bound shard addressing</td></tr>
<tr><td><code>max_tx_timeout_ms</code></td><td>300,000</td><td>Maximum transaction timeout</td></tr>
<tr><td><code>max_node_id_len</code></td><td>256</td><td>Maximum node ID length</td></tr>
<tr><td><code>max_key_len</code></td><td>4,096</td><td>Maximum key length</td></tr>
<tr><td><code>max_embedding_dimension</code></td><td>65,536</td><td>Prevent huge allocations</td></tr>
<tr><td><code>max_embedding_magnitude</code></td><td>1,000,000</td><td>Detect invalid values</td></tr>
<tr><td><code>max_query_len</code></td><td>1MB</td><td>Maximum query string length</td></tr>
<tr><td><code>max_message_age_ms</code></td><td>300,000</td><td>Reject stale/replayed messages</td></tr>
<tr><td><code>max_blocks_per_request</code></td><td>1,000</td><td>Limit block range requests</td></tr>
<tr><td><code>max_snapshot_chunk_size</code></td><td>10MB</td><td>Limit snapshot chunk size</td></tr>
</tbody></table>
</div>
<h2 id="edge-cases-and-gotchas"><a class="header" href="#edge-cases-and-gotchas">Edge Cases and Gotchas</a></h2>
<h3 id="raft-edge-cases"><a class="header" href="#raft-edge-cases">Raft Edge Cases</a></h3>
<ol>
<li>
<p><strong>Split Vote</strong>: When multiple candidates split the vote evenly, election
timeout triggers new election. Randomized timeouts (150-300ms) reduce
collision probability.</p>
</li>
<li>
<p><strong>Network Partition</strong>: During partition, minority side cannot commit (lacks
quorum). Pre-vote prevents term inflation when partition heals.</p>
</li>
<li>
<p><strong>Stale Leader</strong>: A partitioned leader may not know it lost leadership.
Quorum tracker detects heartbeat failures and steps down.</p>
</li>
<li>
<p><strong>Log Divergence</strong>: Followers with divergent logs are overwritten by leader’s
log (consistency &gt; availability).</p>
</li>
<li>
<p><strong>Snapshot During Election</strong>: Snapshot transfer continues even if leadership
changes. New leader may need to resend snapshot.</p>
</li>
</ol>
<h3 id="2pc-edge-cases"><a class="header" href="#2pc-edge-cases">2PC Edge Cases</a></h3>
<ol>
<li>
<p><strong>Coordinator Failure After Prepare</strong>: Participants holding locks may
timeout. WAL recovery allows new coordinator to resume.</p>
</li>
<li>
<p><strong>Participant Failure</strong>: Coordinator times out waiting for vote. Transaction
aborts, participant recovers from WAL on restart.</p>
</li>
<li>
<p><strong>Network Partition Between Phases</strong>: Commit messages may not reach all
participants. Retry loop ensures eventual delivery.</p>
</li>
<li>
<p><strong>Lock Timeout vs Transaction Timeout</strong>: Lock timeout (30s) should exceed
transaction timeout (5s) to prevent premature lock release.</p>
</li>
<li>
<p><strong>Orphaned Locks</strong>: Locks from crashed transactions are cleaned up by
periodic <code>cleanup_expired()</code> or WAL recovery.</p>
</li>
</ol>
<h3 id="gossip-edge-cases"><a class="header" href="#gossip-edge-cases">Gossip Edge Cases</a></h3>
<ol>
<li>
<p><strong>Incarnation Overflow</strong>: Theoretically possible with u64, but requires 2^64
restarts. Practically impossible.</p>
</li>
<li>
<p><strong>Clock Skew</strong>: Lamport timestamps are logical, not wall-clock. Sync messages
update local Lamport time to <code>max(local, remote) + 1</code>.</p>
</li>
<li>
<p><strong>Signature Replay</strong>: Sequence numbers and timestamp freshness checks prevent
replaying old signed messages.</p>
</li>
<li>
<p><strong>Rapid Restart</strong>: Node restarting rapidly may have lower incarnation than
suspected state. New incarnation on restart resolves this.</p>
</li>
</ol>
<h3 id="conflict-detection-edge-cases"><a class="header" href="#conflict-detection-edge-cases">Conflict Detection Edge Cases</a></h3>
<ol>
<li>
<p><strong>Zero Vector</strong>: Empty deltas (no changes) have undefined cosine similarity.
Treated as orthogonal.</p>
</li>
<li>
<p><strong>Nearly Identical</strong>: Transactions with 0.99 &lt; similarity &lt; 1.0 may conflict.
Use structural overlap (Jaccard) as secondary check.</p>
</li>
<li>
<p><strong>Large Dimension Mismatch</strong>: Deltas with different dimensions cannot be
directly compared. Pad smaller to match larger.</p>
</li>
</ol>
<h2 id="recovery-procedures"><a class="header" href="#recovery-procedures">Recovery Procedures</a></h2>
<h3 id="raft-recovery-from-wal"><a class="header" href="#raft-recovery-from-wal">Raft Recovery from WAL</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Open WAL and replay entries
let wal = RaftWal::open(wal_path)?;
let recovery = RaftRecoveryState::from_wal(&amp;wal)?;

// 2. Restore term and voted_for
node.current_term = recovery.current_term;
node.voted_for = recovery.voted_for;

// 3. Validate snapshot if present
if let Some((meta, data)) = load_snapshot() {
    let computed_hash = sha256(&amp;data);
    if computed_hash == meta.snapshot_hash {
        // Valid snapshot - restore state machine
        apply_snapshot(meta, data);
    } else {
        // Corrupted snapshot - ignore
        warn!("Snapshot hash mismatch, starting fresh");
    }
}

// 4. Start as follower
node.state = RaftState::Follower;
<span class="boring">}</span></code></pre></pre>
<h3 id="2pc-coordinator-recovery"><a class="header" href="#2pc-coordinator-recovery">2PC Coordinator Recovery</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Replay WAL to reconstruct pending transactions
let recovery = TxRecoveryState::from_wal(&amp;wal)?;

// 2. Process each transaction based on phase
for tx in recovery.prepared_txs {
    // All YES votes - resume commit
    coordinator.pending.insert(tx.tx_id, restore_tx(tx, TxPhase::Prepared));
}

for tx in recovery.committing_txs {
    // Was committing - complete commit
    coordinator.complete_commit(tx.tx_id)?;
}

for tx in recovery.aborting_txs {
    // Was aborting - complete abort
    coordinator.complete_abort(tx.tx_id)?;
}

// 3. Timed out transactions default to abort (presumed abort)
for tx in recovery.timed_out_txs {
    coordinator.abort(tx.tx_id, "recovered - timeout")?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gossip-state-recovery"><a class="header" href="#gossip-state-recovery">Gossip State Recovery</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Gossip state is reconstructed via protocol, not WAL
// 1. Start with only local node in state
let mut state = LWWMembershipState::new();
state.update_local(local_node.clone(), NodeHealth::Healthy, 0);

// 2. Add known peers as Unknown
for peer in known_peers {
    state.merge(&amp;[GossipNodeState::new(peer, NodeHealth::Unknown, 0, 0)]);
}

// 3. Gossip protocol will converge to correct state
// - Healthy nodes will respond to Sync
// - Failed nodes will be suspected and eventually marked failed
<span class="boring">}</span></code></pre></pre>
<h2 id="operational-best-practices"><a class="header" href="#operational-best-practices">Operational Best Practices</a></h2>
<h3 id="cluster-sizing"><a class="header" href="#cluster-sizing">Cluster Sizing</a></h3>
<ul>
<li><strong>Minimum</strong>: 3 nodes (tolerates 1 failure)</li>
<li><strong>Recommended</strong>: 5 nodes (tolerates 2 failures)</li>
<li><strong>Large</strong>: 7 nodes (tolerates 3 failures)</li>
<li>Avoid even numbers (split-brain risk)</li>
</ul>
<h3 id="timeout-tuning"><a class="header" href="#timeout-tuning">Timeout Tuning</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Network latency &lt; 10ms (same datacenter)
RaftConfig {
    election_timeout: (150, 300),
    heartbeat_interval: 50,
}

// Network latency 10-50ms (cross-datacenter)
RaftConfig {
    election_timeout: (500, 1000),
    heartbeat_interval: 150,
}

// Network latency &gt; 50ms (geo-distributed)
RaftConfig {
    election_timeout: (2000, 4000),
    heartbeat_interval: 500,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h3>
<p>Key metrics to monitor:</p>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Warning Threshold</th><th>Critical Threshold</th></tr></thead><tbody>
<tr><td><code>heartbeat_success_rate</code></td><td>&lt; 0.95</td><td>&lt; 0.80</td></tr>
<tr><td><code>fast_path_rate</code></td><td>&lt; 0.50</td><td>&lt; 0.20</td></tr>
<tr><td><code>commit_rate</code></td><td>&lt; 0.80</td><td>&lt; 0.50</td></tr>
<tr><td><code>conflict_rate</code></td><td>&gt; 0.10</td><td>&gt; 0.30</td></tr>
<tr><td><code>deadlocks_detected</code></td><td>&gt; 0/min</td><td>&gt; 10/min</td></tr>
<tr><td><code>quorum_lost_events</code></td><td>&gt; 0/hour</td><td>&gt; 0/min</td></tr>
</tbody></table>
</div>
<h3 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h3>
<ol>
<li><strong>Enable Message Signing</strong>: Set <code>require_signatures: true</code> in production</li>
<li><strong>Rotate Keys</strong>: Periodically generate new identities and update registry</li>
<li><strong>Network Isolation</strong>: Use TLS for transport, firewall cluster ports</li>
<li><strong>Audit Logging</strong>: Log all state transitions for forensic analysis</li>
</ol>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Relationship</th></tr></thead><tbody>
<tr><td><code>tensor_store</code></td><td>Provides <code>TensorStore</code> for persistence, <code>SparseVector</code> for embeddings, <code>ArchetypeRegistry</code> for delta compression</td></tr>
<tr><td><code>graph_engine</code></td><td>Blocks linked via graph edges, chain structure built on graph</td></tr>
<tr><td><code>tensor_compress</code></td><td>Int8 quantization for delta embeddings (4x compression)</td></tr>
<tr><td><code>tensor_checkpoint</code></td><td>Snapshot persistence for crash recovery</td></tr>
</tbody></table>
</div>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time</th><th>Notes</th></tr></thead><tbody>
<tr><td>Transaction commit</td><td>~50us</td><td>Single transaction block</td></tr>
<tr><td>Conflict detection</td><td>~1us</td><td>Cosine + Jaccard calculation</td></tr>
<tr><td>Deadlock detection</td><td>~350ns</td><td>DFS cycle detection</td></tr>
<tr><td>Gossip round</td><td>~200ms</td><td>Configurable interval</td></tr>
<tr><td>Heartbeat</td><td>~50ms</td><td>Leader to all followers</td></tr>
<tr><td>Fast-path validation</td><td>~2us</td><td>Similarity check only</td></tr>
<tr><td>Full validation</td><td>~50us</td><td>Complete block verification</td></tr>
<tr><td>Lock acquisition</td><td>~100ns</td><td>Uncontended case</td></tr>
<tr><td>Lock acquisition (contended)</td><td>~10us</td><td>With wait-graph update</td></tr>
<tr><td>Signature verification</td><td>~50us</td><td>Ed25519 verify</td></tr>
<tr><td>Message validation</td><td>~1us</td><td>Bounds checking</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/tensor-unified.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/neumann-parser.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/tensor-unified.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/neumann-parser.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
