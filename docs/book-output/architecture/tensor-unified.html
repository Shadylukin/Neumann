<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tensor Unified - Neumann</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Unified tensor-based runtime for relational, graph, and vector data">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neumann</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann/edit/main/docs/book/src/architecture/tensor-unified.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tensor-unified"><a class="header" href="#tensor-unified">Tensor Unified</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Cross-engine operations and unified entity management for Neumann. Provides a
single interface for queries that span relational, graph, and vector engines
with async-first design and thread safety inherited from TensorStore.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<ol>
<li><strong>Cross-Engine Abstraction</strong>: Single interface for operations spanning
multiple engines</li>
<li><strong>Unified Entities</strong>: Entities can have relational fields, graph connections,
and embeddings</li>
<li><strong>Composable Queries</strong>: Combine vector similarity with graph connectivity</li>
<li><strong>Async-First</strong>: All cross-engine operations support async execution</li>
<li><strong>Thread Safety</strong>: Inherits from underlying engines via TensorStore</li>
</ol>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code class="language-text">                    +------------------+
                    | UnifiedEngine    |
                    +------------------+
                           |
        +------------------+------------------+
        |                  |                  |
        v                  v                  v
+---------------+  +---------------+  +---------------+
|  Relational   |  |    Graph      |  |    Vector     |
|    Engine     |  |    Engine     |  |    Engine     |
+---------------+  +---------------+  +---------------+
        |                  |                  |
        +------------------+------------------+
                           |
                    +------v------+
                    | TensorStore |
                    +-------------+
</code></pre>
<p>All engines share the same TensorStore instance, enabling cross-engine queries
without data duplication.</p>
<h3 id="internal-engine-coordination"><a class="header" href="#internal-engine-coordination">Internal Engine Coordination</a></h3>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant UnifiedEngine
    participant VectorEngine
    participant GraphEngine
    participant TensorStore

    Client-&gt;&gt;UnifiedEngine: create_entity(&quot;user:1&quot;, fields, embedding)
    UnifiedEngine-&gt;&gt;VectorEngine: set_entity_embedding(&quot;user:1&quot;, embedding)
    VectorEngine-&gt;&gt;TensorStore: put(&quot;user:1&quot;, TensorData{_embedding: ...})
    UnifiedEngine-&gt;&gt;TensorStore: get(&quot;user:1&quot;)
    TensorStore--&gt;&gt;UnifiedEngine: TensorData
    UnifiedEngine-&gt;&gt;TensorStore: put(&quot;user:1&quot;, TensorData{fields + _embedding})
    UnifiedEngine--&gt;&gt;Client: Ok(())
</pre>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>UnifiedEngine</code></td><td>Main entry point for cross-engine operations</td></tr>
<tr><td><code>UnifiedResult</code></td><td>Query result containing description and items</td></tr>
<tr><td><code>UnifiedItem</code></td><td>Single item with source, id, data, embedding, and score</td></tr>
<tr><td><code>UnifiedError</code></td><td>Error type wrapping engine-specific errors</td></tr>
<tr><td><code>FindPattern</code></td><td>Pattern for FIND queries (Nodes or Edges)</td></tr>
<tr><td><code>DistanceMetric</code></td><td>Similarity metric (Cosine, Euclidean, DotProduct)</td></tr>
<tr><td><code>EntityInput</code></td><td>Tuple type for batch operations: (key, fields, embedding)</td></tr>
<tr><td><code>Unified</code></td><td>Trait for converting engine types to UnifiedItem</td></tr>
</tbody></table>
</div>
<h3 id="unifieditem"><a class="header" href="#unifieditem">UnifiedItem</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UnifiedItem {
    pub source: String,                    // "relational", "graph", "vector", or combined
    pub id: String,                        // Entity key
    pub data: HashMap&lt;String, String&gt;,     // Entity fields
    pub embedding: Option&lt;Vec&lt;f32&gt;&gt;,       // Optional embedding
    pub score: Option&lt;f32&gt;,                // Similarity score if applicable
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>source</code> field indicates which engine(s) produced the result:</p>
<ul>
<li><code>"graph"</code> - Result from graph operations (nodes, edges)</li>
<li><code>"vector"</code> - Result from vector similarity search</li>
<li><code>"unified"</code> - Result from cross-engine entity retrieval</li>
<li><code>"vector+graph"</code> - Result from <code>find_similar_connected</code> (similarity +
connectivity)</li>
<li><code>"graph+vector"</code> - Result from <code>find_neighbors_by_similarity</code> (connectivity +
similarity)</li>
</ul>
<h3 id="unifiederror"><a class="header" href="#unifiederror">UnifiedError</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Cause</th></tr></thead><tbody>
<tr><td><code>RelationalError</code></td><td>Error from relational engine</td></tr>
<tr><td><code>GraphError</code></td><td>Error from graph engine</td></tr>
<tr><td><code>VectorError</code></td><td>Error from vector engine</td></tr>
<tr><td><code>NotFound</code></td><td>Entity not found</td></tr>
<tr><td><code>InvalidOperation</code></td><td>Invalid operation attempted</td></tr>
</tbody></table>
</div>
<p>Error conversion is automatic via <code>From</code> implementations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;graph_engine::GraphError&gt; for UnifiedError {
    fn from(e: graph_engine::GraphError) -&gt; Self {
        UnifiedError::GraphError(e.to_string())
    }
}

impl From&lt;vector_engine::VectorError&gt; for UnifiedError {
    fn from(e: vector_engine::VectorError) -&gt; Self {
        UnifiedError::VectorError(e.to_string())
    }
}

impl From&lt;relational_engine::RelationalError&gt; for UnifiedError {
    fn from(e: relational_engine::RelationalError) -&gt; Self {
        UnifiedError::RelationalError(e.to_string())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="entity-storage-format"><a class="header" href="#entity-storage-format">Entity Storage Format</a></h2>
<p>Unified entities use reserved field prefixes in <code>TensorData</code> to store
cross-engine data within a single key-value entry:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_out</code></td><td><code>Pointers(Vec&lt;String&gt;)</code></td><td>Outgoing edge keys</td></tr>
<tr><td><code>_in</code></td><td><code>Pointers(Vec&lt;String&gt;)</code></td><td>Incoming edge keys</td></tr>
<tr><td><code>_embedding</code></td><td><code>Vector(Vec&lt;f32&gt;)</code> or <code>Sparse(SparseVector)</code></td><td>Embedding vector</td></tr>
<tr><td><code>_label</code></td><td><code>Scalar(String)</code></td><td>Entity type/label</td></tr>
<tr><td><code>_type</code></td><td><code>Scalar(String)</code></td><td>Discriminator (“node”, “edge”, “row”)</td></tr>
<tr><td><code>_id</code></td><td><code>Scalar(Int)</code></td><td>Numeric entity ID</td></tr>
<tr><td><code>_from</code></td><td><code>Scalar(String)</code></td><td>Edge source key</td></tr>
<tr><td><code>_to</code></td><td><code>Scalar(String)</code></td><td>Edge target key</td></tr>
<tr><td><code>_edge_type</code></td><td><code>Scalar(String)</code></td><td>Edge type</td></tr>
<tr><td><code>_directed</code></td><td><code>Scalar(Bool)</code></td><td>Whether edge is directed</td></tr>
<tr><td><code>_table</code></td><td><code>Scalar(String)</code></td><td>Table name for relational rows</td></tr>
</tbody></table>
</div>
<h3 id="entity-storage-example"><a class="header" href="#entity-storage-example">Entity Storage Example</a></h3>
<pre><code class="language-text">Key: "user:alice"
TensorData:
  _embedding: Vector([0.1, 0.2, 0.3, 0.4])
  _out: Pointers(["edge:follows:1", "edge:likes:2"])
  _in: Pointers(["edge:follows:3"])
  name: Scalar(String("Alice"))
  role: Scalar(String("admin"))

Key: "edge:follows:1"
TensorData:
  _type: Scalar(String("edge"))
  _from: Scalar(String("user:alice"))
  _to: Scalar(String("user:bob"))
  _edge_type: Scalar(String("follows"))
  _directed: Scalar(Bool(true))
</code></pre>
<h3 id="sparse-vector-auto-detection"><a class="header" href="#sparse-vector-auto-detection">Sparse Vector Auto-Detection</a></h3>
<p>Embeddings are automatically stored in sparse format when &gt;50% of values are
zero:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn should_use_sparse(vector: &amp;[f32]) -&gt; bool {
    if vector.is_empty() {
        return false;
    }
    let nnz = vector.iter().filter(|&amp;&amp;v| v.abs() &gt; 1e-6).count();
    // Sparse if nnz &lt;= len/2
    nnz * 2 &lt;= vector.len()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tensor_unified::UnifiedEngine;
use tensor_store::TensorStore;

// Create with new store
let engine = UnifiedEngine::new();

// Create with shared store
let store = TensorStore::new();
let engine = UnifiedEngine::with_store(store);

// Create with existing engines
let engine = UnifiedEngine::with_engines(store, relational, graph, vector);
<span class="boring">}</span></code></pre></pre>
<h3 id="internal-structure"><a class="header" href="#internal-structure">Internal Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UnifiedEngine {
    store: TensorStore,
    relational: Arc&lt;RelationalEngine&gt;,
    graph: Arc&lt;GraphEngine&gt;,
    vector: Arc&lt;VectorEngine&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Arc</code> wrappers enable:</p>
<ul>
<li>Thread-safe sharing across async tasks</li>
<li>Zero-copy cloning of the engine</li>
<li>Independent engine access when needed</li>
</ul>
<h2 id="entity-operations"><a class="header" href="#entity-operations">Entity Operations</a></h2>
<h3 id="creating-entities"><a class="header" href="#creating-entities">Creating Entities</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

// Create an entity with fields and optional embedding
let mut fields = HashMap::new();
fields.insert("name".to_string(), "Alice".to_string());
fields.insert("role".to_string(), "admin".to_string());

engine.create_entity(
    "user:1",
    fields,
    Some(vec![0.1, 0.2, 0.3, 0.4])  // Optional embedding
).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Internal flow:</strong></p>
<pre class="mermaid">flowchart TD
    A[create_entity] --&gt; B{Has embedding?}
    B --&gt;|Yes| C[VectorEngine::set_entity_embedding]
    C --&gt; D[Store to TensorData._embedding]
    B --&gt;|No| E[Get existing TensorData or new]
    D --&gt; E
    E --&gt; F[For each field]
    F --&gt; G[Set field as TensorValue::Scalar]
    G --&gt; H[TensorStore::put]
</pre>
<h3 id="connecting-entities"><a class="header" href="#connecting-entities">Connecting Entities</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connect entities via graph edge
let edge_id = engine.connect_entities("user:1", "user:2", "follows").await?;
<span class="boring">}</span></code></pre></pre>
<p>Edge creation updates three TensorData entries:</p>
<ol>
<li>Creates new edge entry with <code>_from</code>, <code>_to</code>, <code>_edge_type</code>, <code>_directed</code></li>
<li>Adds edge key to source entity’s <code>_out</code> field</li>
<li>Adds edge key to target entity’s <code>_in</code> field</li>
</ol>
<h3 id="retrieving-entities"><a class="header" href="#retrieving-entities">Retrieving Entities</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get entity with all data and embedding
let item = engine.get_entity("user:1").await?;
println!("Fields: {:?}", item.data);
println!("Embedding: {:?}", item.embedding);
<span class="boring">}</span></code></pre></pre>
<p><strong>Gotcha:</strong> Returns <code>UnifiedError::NotFound</code> if the entity has neither fields
nor embedding.</p>
<h2 id="cross-engine-queries"><a class="header" href="#cross-engine-queries">Cross-Engine Queries</a></h2>
<h3 id="find-similar-connected"><a class="header" href="#find-similar-connected">Find Similar Connected</a></h3>
<p>Find entities similar to a query that are also connected via graph edges:</p>
<pre class="mermaid">flowchart LR
    A[Query Entity] --&gt; B[Get embedding]
    B --&gt; C[Vector search top_k*2]
    C --&gt; D[Get connected neighbors]
    D --&gt; E[HashSet intersection]
    E --&gt; F[Take top_k]
    F --&gt; G[Return UnifiedItems]
</pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find entities similar to query AND connected to target
let results = engine.find_similar_connected(
    "user:1",      // Query entity (uses its embedding)
    "hub:main",    // Find entities connected to this
    10             // Top-k results
).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Algorithm details:</strong></p>
<ol>
<li>Retrieves embedding from <code>query_key</code> via <code>VectorEngine::get_entity_embedding</code></li>
<li>Searches for top <code>k*2</code> similar entities (over-fetches for filtering)</li>
<li>Gets neighbors of <code>connected_to</code> via <code>GraphEngine::get_entity_neighbors</code></li>
<li>Builds HashSet of connected neighbors for O(1) lookup</li>
<li>Filters similar results to only those in the neighbor set</li>
<li>Returns top-k results with source <code>"vector+graph"</code></li>
</ol>
<p><strong>Edge case:</strong> If <code>query_key</code> has no embedding, returns <code>VectorError::NotFound</code>.</p>
<h3 id="find-neighbors-by-similarity"><a class="header" href="#find-neighbors-by-similarity">Find Neighbors by Similarity</a></h3>
<p>Find graph neighbors sorted by similarity to a query vector:</p>
<pre class="mermaid">flowchart LR
    A[Entity Key] --&gt; B[Get neighbors via graph]
    B --&gt; C[For each neighbor]
    C --&gt; D[Get embedding]
    D --&gt; E{Dimension match?}
    E --&gt;|Yes| F[Compute cosine similarity]
    E --&gt;|No| G[Skip]
    F --&gt; H[Collect results]
    H --&gt; I[Sort by score desc]
    I --&gt; J[Truncate to top_k]
</pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find neighbors of an entity sorted by similarity to a vector
let results = engine.find_neighbors_by_similarity(
    "user:1",                    // Entity to get neighbors of
    &amp;[0.1, 0.2, 0.3, 0.4],      // Query vector
    10                           // Top-k results
).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Algorithm details:</strong></p>
<ol>
<li>Gets all neighbors (both directions) via <code>GraphEngine::get_entity_neighbors</code></li>
<li>For each neighbor:
<ul>
<li>Attempts to get embedding via <code>VectorEngine::get_entity_embedding</code></li>
<li>Skips if no embedding or dimension mismatch</li>
<li>Computes cosine similarity with query vector</li>
</ul>
</li>
<li>Sorts results by score descending</li>
<li>Truncates to top-k</li>
<li>Returns results with source <code>"graph+vector"</code></li>
</ol>
<p><strong>Gotcha:</strong> Neighbors without embeddings are silently skipped.</p>
<h3 id="find-nodes-and-edges"><a class="header" href="#find-nodes-and-edges">Find Nodes and Edges</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find all nodes with optional label filter
let nodes = engine.find_nodes(Some("person"), None).await?;

// Find all edges with optional type filter
let edges = engine.find_edges(Some("follows"), None).await?;

// Find with pattern and limit
let pattern = FindPattern::Nodes { label: Some("document".to_string()) };
let result = engine.find(&amp;pattern, Some(10)).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="find-pattern-matching-implementation"><a class="header" href="#find-pattern-matching-implementation">Find Pattern Matching Implementation</a></h2>
<p>The <code>find_nodes</code> and <code>find_edges</code> methods scan the TensorStore for matching
entities:</p>
<h3 id="node-scanning-algorithm"><a class="header" href="#node-scanning-algorithm">Node Scanning Algorithm</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn scan_nodes(&amp;self, label_filter: Option&lt;&amp;str&gt;) -&gt; Result&lt;Vec&lt;Node&gt;&gt; {
    let keys = self.store.scan("node:");  // Prefix scan

    for key in keys {
        // Filter out edge lists (node:123:out, node:123:in)
        if key.contains(":out") || key.contains(":in") {
            continue;
        }

        // Parse node ID from key "node:{id}"
        if let Some(id_str) = key.strip_prefix("node:") {
            if let Ok(id) = id_str.parse::&lt;u64&gt;() {
                // Fetch and optionally filter by label
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="condition-matching"><a class="header" href="#condition-matching">Condition Matching</a></h3>
<p>Conditions are evaluated against node/edge properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Condition</th><th>Node Fields</th><th>Edge Fields</th></tr></thead><tbody>
<tr><td><code>Eq("id", ...)</code></td><td>Matches <code>node.id</code></td><td>Matches <code>edge.id</code></td></tr>
<tr><td><code>Eq("label", ...)</code></td><td>Matches <code>node.label</code></td><td>N/A</td></tr>
<tr><td><code>Eq("type", ...)</code></td><td>N/A</td><td>Matches <code>edge.edge_type</code></td></tr>
<tr><td><code>Eq("edge_type", ...)</code></td><td>N/A</td><td>Matches <code>edge.edge_type</code> (alias)</td></tr>
<tr><td><code>Eq("from", ...)</code></td><td>N/A</td><td>Matches <code>edge.from</code></td></tr>
<tr><td><code>Eq("to", ...)</code></td><td>N/A</td><td>Matches <code>edge.to</code></td></tr>
<tr><td><code>Eq(property, ...)</code></td><td>Matches <code>node.properties[property]</code></td><td>Matches <code>edge.properties[property]</code></td></tr>
<tr><td><code>And(a, b)</code></td><td>Both must match</td><td>Both must match</td></tr>
<tr><td><code>Or(a, b)</code></td><td>Either must match</td><td>Either must match</td></tr>
<tr><td>Other conditions</td><td>Returns <code>true</code> (pass-through)</td><td>Returns <code>true</code> (pass-through)</td></tr>
</tbody></table>
</div>
<p><strong>Gotcha:</strong> Conditions other than <code>Eq</code>, <code>And</code>, <code>Or</code> return <code>true</code> (not yet
implemented for graph entities).</p>
<h2 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Store multiple embeddings
let items = vec![
    ("doc1".to_string(), vec![0.1, 0.2, 0.3]),
    ("doc2".to_string(), vec![0.4, 0.5, 0.6]),
];
let count = engine.embed_batch(items).await?;

// Create multiple entities
let entities: Vec&lt;EntityInput&gt; = vec![
    ("e1".to_string(), HashMap::from([("name".to_string(), "A".to_string())]), None),
    ("e2".to_string(), HashMap::from([("name".to_string(), "B".to_string())]), Some(vec![0.1, 0.2])),
];
let count = engine.create_entities_batch(entities).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Note:</strong> Batch operations process sequentially (not parallel). Failed
individual operations are counted as failures but don’t abort the batch.</p>
<h2 id="unified-trait"><a class="header" href="#unified-trait">Unified Trait</a></h2>
<p>Types implementing the <code>Unified</code> trait can be converted to <code>UnifiedItem</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Unified {
    fn as_unified(&amp;self) -&gt; UnifiedItem;
    fn source_engine(&amp;self) -&gt; &amp;'static str;
    fn unified_id(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<p>Implemented for:</p>
<ul>
<li><code>graph_engine::Node</code> - Converts label and properties to data fields</li>
<li><code>graph_engine::Edge</code> - Converts from, to, type, and properties to data fields</li>
<li><code>vector_engine::SearchResult</code> - Converts key and score</li>
</ul>
<h3 id="implementation-examples"><a class="header" href="#implementation-examples">Implementation Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Unified for Node {
    fn as_unified(&amp;self) -&gt; UnifiedItem {
        let mut item = UnifiedItem::new("graph", self.id.to_string());
        item.set("label", &amp;self.label);
        for (k, v) in &amp;self.properties {
            item.set(k.clone(), format!("{:?}", v));  // Debug format for PropertyValue
        }
        item
    }

    fn source_engine(&amp;self) -&gt; &amp;'static str { "graph" }
    fn unified_id(&amp;self) -&gt; String { self.id.to_string() }
}

impl Unified for SearchResult {
    fn as_unified(&amp;self) -&gt; UnifiedItem {
        UnifiedItem::new("vector", &amp;self.key).with_score(self.score)
    }

    fn source_engine(&amp;self) -&gt; &amp;'static str { "vector" }
    fn unified_id(&amp;self) -&gt; String { self.key.clone() }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="query-language"><a class="header" href="#query-language">Query Language</a></h2>
<p>Cross-engine operations are exposed via the query language:</p>
<h3 id="entity-creation"><a class="header" href="#entity-creation">Entity Creation</a></h3>
<pre><code class="language-sql">-- Create entity with fields and embedding
ENTITY CREATE 'user:1' {name: 'Alice', role: 'admin'} EMBEDDING [0.1, 0.2, 0.3]

-- Create entity with fields only
ENTITY CREATE 'user:2' {name: 'Bob'}

-- Connect entities
ENTITY CONNECT 'user:1' -&gt; 'user:2' : follows
</code></pre>
<h3 id="cross-engine-similarity"><a class="header" href="#cross-engine-similarity">Cross-Engine Similarity</a></h3>
<pre><code class="language-sql">-- Find similar entities that are also connected to a hub
SIMILAR 'query:key' CONNECTED TO 'hub:entity' LIMIT 10

-- Find neighbors sorted by similarity
NEIGHBORS 'entity:key' BY SIMILAR [0.1, 0.2, 0.3] LIMIT 10
</code></pre>
<h2 id="queryrouter-integration"><a class="header" href="#queryrouter-integration">QueryRouter Integration</a></h2>
<p>QueryRouter integrates with UnifiedEngine for cross-engine operations. When
created with <code>with_shared_store()</code>, the router automatically initializes an
internal UnifiedEngine:</p>
<pre class="mermaid">classDiagram
    class QueryRouter {
        -relational: Arc~RelationalEngine~
        -graph: Arc~GraphEngine~
        -vector: Arc~VectorEngine~
        -unified: Option~UnifiedEngine~
        -hnsw_index: Option~HNSWIndex~
        +with_shared_store(store) QueryRouter
        +unified() Option~UnifiedEngine~
        +find_similar_connected()
        +find_neighbors_by_similarity()
    }

    class UnifiedEngine {
        -store: TensorStore
        -relational: Arc~RelationalEngine~
        -graph: Arc~GraphEngine~
        -vector: Arc~VectorEngine~
    }

    QueryRouter --&gt; UnifiedEngine : contains
    QueryRouter --&gt; RelationalEngine : shares Arc
    QueryRouter --&gt; GraphEngine : shares Arc
    QueryRouter --&gt; VectorEngine : shares Arc
    UnifiedEngine --&gt; RelationalEngine : shares Arc
    UnifiedEngine --&gt; GraphEngine : shares Arc
    UnifiedEngine --&gt; VectorEngine : shares Arc
</pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use query_router::QueryRouter;
use tensor_store::TensorStore;

// Create router with shared store - this initializes UnifiedEngine
let store = TensorStore::new();
let router = QueryRouter::with_shared_store(store);

// Verify UnifiedEngine is available
assert!(router.unified().is_some());

// Cross-engine Rust API methods delegate to UnifiedEngine
let results = router.find_neighbors_by_similarity("entity:1", &amp;[0.1, 0.2], 10)?;
let results = router.find_similar_connected("query:1", "hub:1", 5)?;

// Query language commands also use the integrated engines
router.execute_parsed("ENTITY CREATE 'doc:1' {title: 'Hello'} EMBEDDING [0.1, 0.2]")?;
router.execute_parsed("ENTITY CONNECT 'user:1' -&gt; 'doc:1' : authored")?;
router.execute_parsed("SIMILAR 'query:doc' CONNECTED TO 'user:1' LIMIT 5")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="hnsw-optimization-path"><a class="header" href="#hnsw-optimization-path">HNSW Optimization Path</a></h3>
<p>When QueryRouter has an HNSW index, <code>find_similar_connected</code> uses it instead of
brute-force search:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use HNSW index if available, otherwise fall back to brute-force
let similar = if let Some((ref index, ref keys)) = self.hnsw_index {
    self.vector.search_with_hnsw(index, keys, &amp;query_embedding, top_k * 2)
} else {
    self.vector.search_entities(&amp;query_embedding, top_k * 2)
};
<span class="boring">}</span></code></pre></pre>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Complexity</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>create_entity</code></td><td>O(1)</td><td>Single store put + optional embedding</td></tr>
<tr><td><code>connect_entities</code></td><td>O(1)</td><td>Three store operations (edge + 2 entity updates)</td></tr>
<tr><td><code>get_entity</code></td><td>O(1)</td><td>Single store get + optional embedding lookup</td></tr>
<tr><td><code>find_similar_connected</code></td><td>O(k log n)</td><td>HNSW search + graph intersection</td></tr>
<tr><td><code>find_similar_connected</code> (brute)</td><td>O(n)</td><td>Linear scan when no HNSW index</td></tr>
<tr><td><code>find_neighbors_by_similarity</code></td><td>O(d * k)</td><td>Neighbor fetch + k similarity computations</td></tr>
<tr><td><code>find_nodes</code></td><td>O(n)</td><td>Full scan with prefix filter</td></tr>
<tr><td><code>find_edges</code></td><td>O(e)</td><td>Full scan with prefix filter</td></tr>
<tr><td><code>embed_batch</code></td><td>O(b)</td><td>Sequential embedding storage</td></tr>
<tr><td><code>create_entities_batch</code></td><td>O(b)</td><td>Sequential entity creation</td></tr>
</tbody></table>
</div>
<p>Where:</p>
<ul>
<li>n = number of entities with embeddings</li>
<li>d = average degree (number of neighbors)</li>
<li>k = top-k results requested</li>
<li>e = number of edges</li>
<li>b = batch size</li>
</ul>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<p>From <code>tensor_unified_bench.rs</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>10 items</th><th>100 items</th><th>1000 items</th></tr></thead><tbody>
<tr><td><code>create_entity</code></td><td>~50us</td><td>~500us</td><td>~5ms</td></tr>
<tr><td><code>embed_batch</code></td><td>~30us</td><td>~300us</td><td>~3ms</td></tr>
<tr><td><code>find_nodes</code></td><td>~10us</td><td>~100us</td><td>~1ms</td></tr>
<tr><td><code>UnifiedItem::new</code></td><td>~50ns</td><td>—</td><td>—</td></tr>
<tr><td><code>UnifiedItem::with_data</code></td><td>~200ns</td><td>—</td><td>—</td></tr>
</tbody></table>
</div>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>UnifiedEngine is thread-safe via:</p>
<ul>
<li><code>Arc&lt;VectorEngine&gt;</code>, <code>Arc&lt;GraphEngine&gt;</code>, <code>Arc&lt;RelationalEngine&gt;</code></li>
<li>All underlying engines share thread-safe TensorStore (DashMap)</li>
<li>No lock poisoning (parking_lot semantics)</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Clone for UnifiedEngine {
    fn clone(&amp;self) -&gt; Self {
        Self {
            store: self.store.clone(),           // Arc&lt;DashMap&gt; clone
            relational: Arc::clone(&amp;self.relational),
            graph: Arc::clone(&amp;self.graph),
            vector: Arc::clone(&amp;self.vector),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Safe concurrent patterns:</strong></p>
<ul>
<li>Multiple readers on same entity</li>
<li>Multiple writers on different entities</li>
<li>Mixed reads/writes (DashMap shard locking)</li>
</ul>
<p><strong>Gotcha:</strong> Concurrent writes to the same entity may interleave fields. Use
transactions for atomicity.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>UnifiedEngine uses the configuration of its underlying engines:</p>
<ul>
<li><code>TensorStore</code>: Storage configuration</li>
<li><code>VectorEngine</code>: HNSW index parameters, similarity metrics</li>
<li><code>GraphEngine</code>: Graph traversal settings</li>
<li><code>RelationalEngine</code>: Table and index configuration</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="entity-key-naming"><a class="header" href="#entity-key-naming">Entity Key Naming</a></h3>
<p>Use prefixed keys to distinguish entity types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>"user:123"      // User entities
"doc:456"       // Document entities
"hub:main"      // Hub/aggregate entities
"edge:follows:1" // Edge entities (auto-generated)
<span class="boring">}</span></code></pre></pre>
<h3 id="embedding-dimensions"><a class="header" href="#embedding-dimensions">Embedding Dimensions</a></h3>
<p>Ensure consistent embedding dimensions across entities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: All entities use 384-dimensional embeddings
engine.create_entity("doc:1", fields, Some(vec![0.0; 384])).await?;
engine.create_entity("doc:2", fields, Some(vec![0.0; 384])).await?;

// Bad: Dimension mismatch causes similarity search to skip entities
engine.create_entity("doc:1", fields, Some(vec![0.0; 384])).await?;
engine.create_entity("doc:2", fields, Some(vec![0.0; 768])).await?;  // Different dimension!
<span class="boring">}</span></code></pre></pre>
<h3 id="cross-engine-query-optimization"><a class="header" href="#cross-engine-query-optimization">Cross-Engine Query Optimization</a></h3>
<p>For <code>find_similar_connected</code>:</p>
<ol>
<li>Build HNSW index for large vector sets (&gt;5000 entities)</li>
<li>Ensure <code>connected_to</code> entity has edges (empty neighbors returns empty
results)</li>
<li>Request <code>top_k * 2</code> internally to account for filtering</li>
</ol>
<p>For <code>find_neighbors_by_similarity</code>:</p>
<ol>
<li>Ensure neighbors have embeddings (no embedding = skipped)</li>
<li>Use same dimension for query vector as stored embeddings</li>
<li>Consider degree distribution (high-degree nodes = more similarity
computations)</li>
</ol>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Relationship</th></tr></thead><tbody>
<tr><td><code>tensor_store</code></td><td>Shared storage backend, provides <code>TensorData</code> and <code>fields</code> constants</td></tr>
<tr><td><code>relational_engine</code></td><td>Relational data, conditions for filtering</td></tr>
<tr><td><code>graph_engine</code></td><td>Graph connectivity, entity edges, neighbor queries</td></tr>
<tr><td><code>vector_engine</code></td><td>Embeddings, similarity search, HNSW index</td></tr>
<tr><td><code>query_router</code></td><td>Query execution, language integration, HNSW optimization</td></tr>
</tbody></table>
</div>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<ul>
<li><code>tensor_store</code>: Core storage</li>
<li><code>relational_engine</code>: Table operations</li>
<li><code>graph_engine</code>: Graph operations</li>
<li><code>vector_engine</code>: Vector search</li>
<li><code>tokio</code>: Async runtime (multi-threaded)</li>
<li><code>futures</code>: Async utilities</li>
<li><code>serde</code>: Serialization for results and items</li>
<li><code>serde_json</code>: JSON output for <code>UnifiedResult</code></li>
</ul>
<h2 id="example-code-intelligence-system"><a class="header" href="#example-code-intelligence-system">Example: Code Intelligence System</a></h2>
<p>From <code>examples/code_search.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use tensor_unified::UnifiedEngine;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let engine = UnifiedEngine::new();

    // Store functions with embeddings representing semantic meaning
    let mut props = HashMap::new();
    props.insert("type".to_string(), "function".to_string());
    props.insert("language".to_string(), "rust".to_string());

    // "process_data" - embedding represents data processing semantics
    engine.create_entity(
        "func:process_data",
        props.clone(),
        Some(vec![1.0, 0.9, 0.0, 0.0])
    ).await?;

    // "validate_input" - embedding represents validation semantics
    engine.create_entity(
        "func:validate_input",
        props.clone(),
        Some(vec![0.0, 0.1, 0.9, 0.9])
    ).await?;

    // Create call graph relationship
    engine.connect_entities(
        "func:process_data",
        "func:validate_input",
        "CALLS"
    ).await?;

    // Find functions similar to "data processing" that call validate_input
    let results = engine.find_similar_connected(
        "func:process_data",   // Query by this function's embedding
        "func:validate_input", // Must be connected to validation
        5
    ).await?;

    for item in results {
        println!("Found: {} (Score: {:.4})", item.id, item.score.unwrap_or(0.0));
    }

    Ok(())
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/tensor-checkpoint.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/tensor-chain.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/tensor-checkpoint.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/tensor-chain.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
