<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Neumann Parser - Neumann</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Unified tensor-based runtime for relational, graph, and vector data">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neumann</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann/edit/main/docs/book/src/architecture/neumann-parser.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="neumann-parser"><a class="header" href="#neumann-parser">Neumann Parser</a></h1>
<p>The <code>neumann_parser</code> crate provides a hand-written recursive descent parser for
the Neumann unified query language. It converts source text into an Abstract
Syntax Tree (AST) that can be executed by the query router.</p>
<p>The parser is designed with zero external dependencies, full span tracking for
error reporting, and support for SQL, graph, vector, and domain-specific
operations in a single unified syntax.</p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody>
<tr><td>Recursive Descent</td><td>Top-down parsing where each grammar rule becomes a function</td></tr>
<tr><td>Pratt Parsing</td><td>Operator precedence parsing for expressions with correct associativity</td></tr>
<tr><td>Span Tracking</td><td>Every AST node carries source location for error messages</td></tr>
<tr><td>Case Insensitivity</td><td>Keywords are matched case-insensitively via uppercase conversion</td></tr>
<tr><td>Single Lookahead</td><td>Parser uses one-token lookahead with optional peek</td></tr>
<tr><td>Depth Limiting</td><td>Expression nesting is limited to 64 levels to prevent stack overflow</td></tr>
</tbody></table>
</div>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre class="mermaid">flowchart LR
    subgraph Input
        Source[&quot;Source String&quot;]
    end

    subgraph Lexer
        Chars[&quot;char iterator&quot;] --&gt; Tokenizer
        Tokenizer --&gt; Tokens[&quot;Token Stream&quot;]
    end

    subgraph Parser
        Tokens --&gt; StatementParser[&quot;Statement Parser&quot;]
        StatementParser --&gt; ExprParser[&quot;Expression Parser (Pratt)&quot;]
        ExprParser --&gt; AST[&quot;Abstract Syntax Tree&quot;]
    end

    Source --&gt; Chars
    AST --&gt; Output[&quot;Statement + Span&quot;]
</pre>
<h3 id="detailed-parsing-flow"><a class="header" href="#detailed-parsing-flow">Detailed Parsing Flow</a></h3>
<pre class="mermaid">sequenceDiagram
    participant User
    participant parse()
    participant Parser
    participant Lexer
    participant ExprParser

    User-&gt;&gt;parse(): &quot;SELECT * FROM users&quot;
    parse()-&gt;&gt;Parser: new(source)
    Parser-&gt;&gt;Lexer: new(source)
    Lexer--&gt;&gt;Parser: first token

    Parser-&gt;&gt;Parser: parse_statement()
    Parser-&gt;&gt;Parser: match on token kind
    Parser-&gt;&gt;Parser: parse_select()
    Parser-&gt;&gt;Parser: parse_select_body()

    loop For each select item
        Parser-&gt;&gt;ExprParser: parse_expr()
        ExprParser-&gt;&gt;ExprParser: parse_expr_bp(0)
        ExprParser-&gt;&gt;ExprParser: parse_prefix_expr()
        ExprParser--&gt;&gt;Parser: Expr with span
    end

    Parser--&gt;&gt;parse(): Statement
    parse()--&gt;&gt;User: Result&lt;Statement&gt;
</pre>
<h2 id="source-files"><a class="header" href="#source-files">Source Files</a></h2>
<div class="table-wrapper"><table><thead><tr><th>File</th><th>Purpose</th><th>Key Functions</th></tr></thead><tbody>
<tr><td><code>lib.rs</code></td><td>Public API exports</td><td><code>parse()</code>, <code>parse_all()</code>, <code>parse_expr()</code>, <code>tokenize()</code></td></tr>
<tr><td><code>lexer.rs</code></td><td>Tokenization (source to tokens)</td><td><code>Lexer::next_token()</code>, <code>scan_ident()</code>, <code>scan_number()</code>, <code>scan_string()</code></td></tr>
<tr><td><code>token.rs</code></td><td>Token definitions and keyword lookup</td><td><code>TokenKind</code>, <code>keyword_from_str()</code></td></tr>
<tr><td><code>parser.rs</code></td><td>Statement parsing (recursive descent)</td><td><code>Parser::parse_statement()</code>, <code>parse_select()</code>, <code>parse_insert()</code></td></tr>
<tr><td><code>expr.rs</code></td><td>Expression parsing (Pratt algorithm)</td><td><code>ExprParser::parse_expr()</code>, <code>parse_expr_bp()</code>, <code>infix_binding_power()</code></td></tr>
<tr><td><code>ast.rs</code></td><td>AST node definitions</td><td><code>Statement</code>, <code>StatementKind</code>, <code>Expr</code>, <code>ExprKind</code></td></tr>
<tr><td><code>span.rs</code></td><td>Source location tracking</td><td><code>BytePos</code>, <code>Span</code>, <code>line_col()</code>, <code>get_line()</code></td></tr>
<tr><td><code>error.rs</code></td><td>Error types with source context</td><td><code>ParseError</code>, <code>ParseErrorKind</code>, <code>format_with_source()</code></td></tr>
</tbody></table>
</div>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="token-system"><a class="header" href="#token-system">Token System</a></h3>
<pre class="mermaid">classDiagram
    class Token {
        +TokenKind kind
        +Span span
        +is_eof() bool
        +is_keyword() bool
    }

    class TokenKind {
        &lt;&lt;enumeration&gt;&gt;
        Ident(String)
        Integer(i64)
        Float(f64)
        String(String)
        Select
        From
        Where
        ...
        Error(String)
        Eof
    }

    class Span {
        +BytePos start
        +BytePos end
        +len() u32
        +merge(Span) Span
        +extract(str) str
    }

    Token --&gt; TokenKind
    Token --&gt; Span
</pre>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Token</code></td><td>A token with its kind and span</td></tr>
<tr><td><code>TokenKind</code></td><td>Enum of all token variants (130+ variants including keywords, literals, operators)</td></tr>
<tr><td><code>Lexer</code></td><td>Stateful tokenizer that produces tokens from source</td></tr>
</tbody></table>
</div>
<h3 id="ast-structure"><a class="header" href="#ast-structure">AST Structure</a></h3>
<pre class="mermaid">classDiagram
    class Statement {
        +StatementKind kind
        +Span span
    }

    class StatementKind {
        &lt;&lt;enumeration&gt;&gt;
        Select(SelectStmt)
        Insert(InsertStmt)
        Node(NodeStmt)
        Edge(EdgeStmt)
        Similar(SimilarStmt)
        Vault(VaultStmt)
        ...
    }

    class Expr {
        +ExprKind kind
        +Span span
        +boxed() Box~Expr~
    }

    class ExprKind {
        &lt;&lt;enumeration&gt;&gt;
        Literal(Literal)
        Ident(Ident)
        Binary(Box~Expr~, BinaryOp, Box~Expr~)
        Unary(UnaryOp, Box~Expr~)
        Call(FunctionCall)
        ...
    }

    Statement --&gt; StatementKind
    StatementKind --&gt; Expr
    Expr --&gt; ExprKind
</pre>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Statement</code></td><td>Top-level parsed statement with span</td></tr>
<tr><td><code>StatementKind</code></td><td>Enum of all statement variants (30+ variants)</td></tr>
<tr><td><code>Expr</code></td><td>Expression node with span</td></tr>
<tr><td><code>ExprKind</code></td><td>Enum of expression variants (20+ variants)</td></tr>
<tr><td><code>Literal</code></td><td>Literal values (Null, Boolean, Integer, Float, String)</td></tr>
<tr><td><code>Ident</code></td><td>Identifier with name and span</td></tr>
<tr><td><code>BinaryOp</code></td><td>Binary operators with precedence (18 operators)</td></tr>
<tr><td><code>UnaryOp</code></td><td>Unary operators (Not, Neg, BitNot)</td></tr>
</tbody></table>
</div>
<h3 id="span-types"><a class="header" href="#span-types">Span Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>BytePos</code></td><td>A byte offset into source text (u32)</td><td><code>BytePos(7)</code></td></tr>
<tr><td><code>Span</code></td><td>A range of bytes (start, end)</td><td><code>Span { start: 0, end: 6 }</code></td></tr>
<tr><td><code>Spanned&lt;T&gt;</code></td><td>A value paired with its source location</td><td><code>Spanned::new(42, span)</code></td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Span operations
let span1 = Span::from_offsets(0, 6);   // "SELECT"
let span2 = Span::from_offsets(7, 8);   // "*"
let merged = span1.merge(span2);         // "SELECT *"

// Extract source text
let source = "SELECT * FROM users";
let text = span1.extract(source);        // "SELECT"

// Line/column computation
let (line, col) = line_col(source, BytePos(7));  // (1, 8)
<span class="boring">}</span></code></pre></pre>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ParseError</code></td><td>Error with kind, span, and optional help message</td></tr>
<tr><td><code>ParseErrorKind</code></td><td>Enum of error variants (10 kinds)</td></tr>
<tr><td><code>ParseResult&lt;T&gt;</code></td><td><code>Result&lt;T, ParseError&gt;</code></td></tr>
<tr><td><code>Errors</code></td><td>Collection of parse errors with iteration support</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Error kinds
pub enum ParseErrorKind {
    UnexpectedToken { found: TokenKind, expected: String },
    UnexpectedEof { expected: String },
    InvalidSyntax(String),
    InvalidNumber(String),
    UnterminatedString,
    UnknownCommand(String),
    DuplicateColumn(String),
    InvalidEscape(char),
    TooDeep,           // Expression nesting &gt; 64 levels
    Custom(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lexer-implementation"><a class="header" href="#lexer-implementation">Lexer Implementation</a></h2>
<h3 id="state-machine"><a class="header" href="#state-machine">State Machine</a></h3>
<p>The lexer is implemented as an iterator-based state machine with
single-character lookahead:</p>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Initial
    Initial --&gt; Whitespace: is_whitespace
    Initial --&gt; LineComment: --
    Initial --&gt; BlockComment: /*
    Initial --&gt; Identifier: a-zA-Z_
    Initial --&gt; Number: 0-9
    Initial --&gt; String: ' or &quot;
    Initial --&gt; Operator: +-*/etc
    Initial --&gt; EOF: end

    Whitespace --&gt; Initial: skip
    LineComment --&gt; Initial: newline
    BlockComment --&gt; Initial: */

    Identifier --&gt; Token: non-alnum
    Number --&gt; Token: non-digit
    String --&gt; Token: closing quote
    Operator --&gt; Token: complete

    Token --&gt; Initial: emit token
    EOF --&gt; [*]
</pre>
<h3 id="internal-structure"><a class="header" href="#internal-structure">Internal Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Lexer&lt;'a&gt; {
    source: &amp;'a str,      // Original source text
    chars: Chars&lt;'a&gt;,     // Character iterator
    pos: u32,             // Current byte position
    peeked: Option&lt;char&gt;, // One-character lookahead
}
<span class="boring">}</span></code></pre></pre>
<h3 id="character-classification"><a class="header" href="#character-classification">Character Classification</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Characters</th><th>Handling</th></tr></thead><tbody>
<tr><td>Whitespace</td><td>space, tab, newline</td><td>Skipped</td></tr>
<tr><td>Line comment</td><td><code>--</code> to newline</td><td>Skipped</td></tr>
<tr><td>Block comment</td><td><code>/* */</code> (nestable)</td><td>Skipped, supports nesting</td></tr>
<tr><td>Identifier</td><td><code>[a-zA-Z_][a-zA-Z0-9_]*</code></td><td>Keyword lookup then Ident</td></tr>
<tr><td>Integer</td><td><code>[0-9]+</code></td><td>Parse as i64</td></tr>
<tr><td>Float</td><td><code>[0-9]+\.[0-9]+</code> or scientific</td><td>Parse as f64</td></tr>
<tr><td>String</td><td><code>'...'</code> or <code>"..."</code></td><td>Handle escapes</td></tr>
</tbody></table>
</div>
<h3 id="string-escape-sequences"><a class="header" href="#string-escape-sequences">String Escape Sequences</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Escape</th><th>Result</th></tr></thead><tbody>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\r</code></td><td>Carriage return</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
<tr><td><code>\'</code></td><td>Single quote</td></tr>
<tr><td><code>\"</code></td><td>Double quote</td></tr>
<tr><td><code>\0</code></td><td>Null character</td></tr>
<tr><td><code>''</code></td><td>Single quote (SQL-style doubled)</td></tr>
<tr><td><code>\x</code></td><td>Unknown: preserved as <code>\x</code></td></tr>
</tbody></table>
</div>
<h3 id="operator-recognition"><a class="header" href="#operator-recognition">Operator Recognition</a></h3>
<p>Multi-character operators are recognized with lookahead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lexer::next_token() operator matching
match c {
    '-' =&gt; if self.eat('&gt;') { Arrow }      // -&gt;
           else { Minus },                  // -
    '=' =&gt; if self.eat('&gt;') { FatArrow }   // =&gt;
           else { Eq },                     // =
    '&lt;' =&gt; if self.eat('=') { Le }         // &lt;=
           else if self.eat('&gt;') { Ne }    // &lt;&gt;
           else if self.eat('&lt;') { Shl }   // &lt;&lt;
           else { Lt },                     // &lt;
    '&gt;' =&gt; if self.eat('=') { Ge }         // &gt;=
           else if self.eat('&gt;') { Shr }   // &gt;&gt;
           else { Gt },                     // &gt;
    '|' =&gt; if self.eat('|') { Concat }     // ||
           else { Pipe },                   // |
    '&amp;' =&gt; if self.eat('&amp;') { AmpAmp }     // &amp;&amp;
           else { Amp },                    // &amp;
    ':' =&gt; if self.eat(':') { ColonColon } // ::
           else { Colon },                  // :
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="pratt-parser-expression-parsing"><a class="header" href="#pratt-parser-expression-parsing">Pratt Parser (Expression Parsing)</a></h2>
<h3 id="algorithm-overview"><a class="header" href="#algorithm-overview">Algorithm Overview</a></h3>
<p>The Pratt parser handles operator precedence through “binding power” - each
operator has a left and right binding power that determines associativity and
precedence.</p>
<pre class="mermaid">flowchart TD
    A[parse_expr_bp\nmin_bp] --&gt; B[parse_prefix]
    B --&gt; C{More tokens?}
    C --&gt;|No| D[Return lhs]
    C --&gt;|Yes| E[parse_postfix]
    E --&gt; F{Infix op?}
    F --&gt;|No| D
    F --&gt;|Yes| G{l_bp &gt;= min_bp?}
    G --&gt;|No| D
    G --&gt;|Yes| H[Advance]
    H --&gt; I[parse_expr_bp\nr_bp]
    I --&gt; J[Build Binary node]
    J --&gt; C
</pre>
<h3 id="binding-power-table"><a class="header" href="#binding-power-table">Binding Power Table</a></h3>
<p>Each operator has left and right binding powers <code>(l_bp, r_bp)</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Precedence</th><th>Operators</th><th>Binding Power (l, r)</th><th>Associativity</th></tr></thead><tbody>
<tr><td>1 (lowest)</td><td>OR</td><td>(1, 2)</td><td>Left</td></tr>
<tr><td>2</td><td>AND</td><td>(3, 4)</td><td>Left</td></tr>
<tr><td>3</td><td>=, !=, &lt;, &lt;=, &gt;, &gt;=</td><td>(5, 6)</td><td>Left</td></tr>
<tr><td>4</td><td><code>|</code> (bitwise OR)</td><td>(7, 8)</td><td>Left</td></tr>
<tr><td>5</td><td>^ (bitwise XOR)</td><td>(9, 10)</td><td>Left</td></tr>
<tr><td>6</td><td>&amp; (bitwise AND)</td><td>(11, 12)</td><td>Left</td></tr>
<tr><td>7</td><td>&lt;&lt;, &gt;&gt;</td><td>(13, 14)</td><td>Left</td></tr>
<tr><td>8</td><td>+, -, <code>||</code> (concat)</td><td>(15, 16)</td><td>Left</td></tr>
<tr><td>9</td><td>*, /, %</td><td>(17, 18)</td><td>Left</td></tr>
<tr><td>10 (highest)</td><td>NOT, -, ~ (unary)</td><td>19 (prefix)</td><td>Right</td></tr>
</tbody></table>
</div>
<p>Left associativity is achieved by having <code>r_bp &gt; l_bp</code>.</p>
<h3 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_DEPTH: usize = 64;  // Prevent stack overflow

fn parse_expr_bp(&amp;mut self, min_bp: u8) -&gt; ParseResult&lt;Expr&gt; {
    self.depth += 1;
    if self.depth &gt; MAX_DEPTH {
        return Err(ParseError::new(ParseErrorKind::TooDeep, self.current.span));
    }

    let mut lhs = self.parse_prefix()?;

    loop {
        // Handle postfix operators (IS NULL, IN, BETWEEN, LIKE, DOT)
        lhs = self.parse_postfix(lhs)?;

        // Check for infix operator
        let op = match self.current_binary_op() {
            Some(op) =&gt; op,
            None =&gt; break,
        };

        let (l_bp, r_bp) = infix_binding_power(op);
        if l_bp &lt; min_bp {
            break;  // Operator binds less tightly than current context
        }

        self.advance();
        let rhs = self.parse_expr_bp(r_bp)?;

        let span = lhs.span.merge(rhs.span);
        lhs = Expr::new(ExprKind::Binary(Box::new(lhs), op, Box::new(rhs)), span);
    }

    self.depth -= 1;
    Ok(lhs)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="prefix-expression-handling"><a class="header" href="#prefix-expression-handling">Prefix Expression Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_prefix(&amp;mut self) -&gt; ParseResult&lt;Expr&gt; {
    match &amp;self.current.kind {
        // Literals
        TokenKind::Integer(n) =&gt; { /* emit Literal(Integer) */ },
        TokenKind::Float(n) =&gt; { /* emit Literal(Float) */ },
        TokenKind::String(s) =&gt; { /* emit Literal(String) */ },
        TokenKind::True | TokenKind::False =&gt; { /* emit Literal(Boolean) */ },
        TokenKind::Null =&gt; { /* emit Literal(Null) */ },

        // Identifiers and function calls
        TokenKind::Ident(_) =&gt; self.parse_ident_or_call(),

        // Aggregate functions (COUNT, SUM, AVG, MIN, MAX)
        TokenKind::Count | TokenKind::Sum | ... =&gt; self.parse_aggregate_call(),

        // Wildcard
        TokenKind::Star =&gt; { /* emit Wildcard */ },

        // Parenthesized expression or tuple
        TokenKind::LParen =&gt; self.parse_paren_expr(),

        // Array literal
        TokenKind::LBracket =&gt; self.parse_array(),

        // Unary operators
        TokenKind::Minus =&gt; { /* parse operand with PREFIX_BP, emit Unary(Neg) */ },
        TokenKind::Not | TokenKind::Bang =&gt; { /* emit Unary(Not) */ },
        TokenKind::Tilde =&gt; { /* emit Unary(BitNot) */ },

        // Special expressions
        TokenKind::Case =&gt; self.parse_case(),
        TokenKind::Exists =&gt; self.parse_exists(),
        TokenKind::Cast =&gt; self.parse_cast(),

        // Contextual keywords as identifiers
        _ if token.kind.is_contextual_keyword() =&gt; self.parse_keyword_as_ident(),

        // Error
        _ =&gt; Err(ParseError::unexpected(...)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="postfix-expression-handling"><a class="header" href="#postfix-expression-handling">Postfix Expression Handling</a></h3>
<p>Postfix operators bind tighter than any infix operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_postfix(&amp;mut self, mut expr: Expr) -&gt; ParseResult&lt;Expr&gt; {
    loop {
        // Handle NOT IN, NOT BETWEEN, NOT LIKE
        if self.check(&amp;TokenKind::Not) {
            let next = self.peek().kind.clone();
            if next == TokenKind::In { /* parse NOT IN */ }
            else if next == TokenKind::Between { /* parse NOT BETWEEN */ }
            else if next == TokenKind::Like { /* parse NOT LIKE */ }
        }

        match self.current.kind {
            TokenKind::Is =&gt; {
                // IS [NOT] NULL
                self.advance();
                let negated = self.eat(&amp;TokenKind::Not);
                self.expect(&amp;TokenKind::Null)?;
                expr = Expr::new(ExprKind::IsNull { expr, negated }, span);
            },
            TokenKind::In =&gt; { /* parse IN (values) or IN (subquery) */ },
            TokenKind::Between =&gt; { /* parse BETWEEN low AND high */ },
            TokenKind::Like =&gt; { /* parse LIKE pattern */ },
            TokenKind::Dot =&gt; {
                // Qualified name: table.column or table.*
                self.advance();
                if self.eat(&amp;TokenKind::Star) {
                    expr = Expr::new(ExprKind::QualifiedWildcard(ident), span);
                } else {
                    let field = self.expect_ident()?;
                    expr = Expr::new(ExprKind::Qualified(Box::new(expr), field), span);
                }
            },
            _ =&gt; return Ok(expr),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="statement-kinds"><a class="header" href="#statement-kinds">Statement Kinds</a></h2>
<h3 id="sql-statements"><a class="header" href="#sql-statements">SQL Statements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Statement</th><th>Example</th><th>AST Type</th></tr></thead><tbody>
<tr><td><code>Select</code></td><td><code>SELECT * FROM users WHERE id = 1</code></td><td><code>SelectStmt</code></td></tr>
<tr><td><code>Insert</code></td><td><code>INSERT INTO users (name) VALUES ('Alice')</code></td><td><code>InsertStmt</code></td></tr>
<tr><td><code>Update</code></td><td><code>UPDATE users SET name = 'Bob' WHERE id = 1</code></td><td><code>UpdateStmt</code></td></tr>
<tr><td><code>Delete</code></td><td><code>DELETE FROM users WHERE id = 1</code></td><td><code>DeleteStmt</code></td></tr>
<tr><td><code>CreateTable</code></td><td><code>CREATE TABLE users (id INT PRIMARY KEY)</code></td><td><code>CreateTableStmt</code></td></tr>
<tr><td><code>DropTable</code></td><td><code>DROP TABLE IF EXISTS users CASCADE</code></td><td><code>DropTableStmt</code></td></tr>
<tr><td><code>CreateIndex</code></td><td><code>CREATE UNIQUE INDEX idx ON users(email)</code></td><td><code>CreateIndexStmt</code></td></tr>
<tr><td><code>DropIndex</code></td><td><code>DROP INDEX idx_name</code></td><td><code>DropIndexStmt</code></td></tr>
<tr><td><code>ShowTables</code></td><td><code>SHOW TABLES</code></td><td>unit</td></tr>
<tr><td><code>Describe</code></td><td><code>DESCRIBE TABLE users</code></td><td><code>DescribeStmt</code></td></tr>
</tbody></table>
</div>
<h3 id="graph-statements"><a class="header" href="#graph-statements">Graph Statements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Statement</th><th>Example</th><th>AST Type</th></tr></thead><tbody>
<tr><td><code>Node</code></td><td><code>NODE CREATE person {name: 'Alice'}</code></td><td><code>NodeStmt</code></td></tr>
<tr><td><code>Edge</code></td><td><code>EDGE CREATE 1 -&gt; 2 : FOLLOWS {since: 2023}</code></td><td><code>EdgeStmt</code></td></tr>
<tr><td><code>Neighbors</code></td><td><code>NEIGHBORS 'entity' OUTGOING follows</code></td><td><code>NeighborsStmt</code></td></tr>
<tr><td><code>Path</code></td><td><code>PATH SHORTEST 1 TO 5</code></td><td><code>PathStmt</code></td></tr>
<tr><td><code>Find</code></td><td><code>FIND NODE person WHERE age &gt; 18</code></td><td><code>FindStmt</code></td></tr>
</tbody></table>
</div>
<h3 id="vector-statements"><a class="header" href="#vector-statements">Vector Statements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Statement</th><th>Example</th><th>AST Type</th></tr></thead><tbody>
<tr><td><code>Embed</code></td><td><code>EMBED STORE 'key' [0.1, 0.2, 0.3]</code></td><td><code>EmbedStmt</code></td></tr>
<tr><td><code>Similar</code></td><td><code>SIMILAR 'query' LIMIT 10 COSINE</code></td><td><code>SimilarStmt</code></td></tr>
</tbody></table>
</div>
<h3 id="domain-statements"><a class="header" href="#domain-statements">Domain Statements</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Statement</th><th>Example</th><th>AST Type</th></tr></thead><tbody>
<tr><td><code>Vault</code></td><td><code>VAULT SET 'secret' 'value'</code></td><td><code>VaultStmt</code></td></tr>
<tr><td><code>Cache</code></td><td><code>CACHE STATS</code></td><td><code>CacheStmt</code></td></tr>
<tr><td><code>Blob</code></td><td><code>BLOB PUT 'file.txt' 'data'</code></td><td><code>BlobStmt</code></td></tr>
<tr><td><code>Blobs</code></td><td><code>BLOBS BY TAG 'important'</code></td><td><code>BlobsStmt</code></td></tr>
<tr><td><code>Chain</code></td><td><code>BEGIN CHAIN TRANSACTION</code></td><td><code>ChainStmt</code></td></tr>
<tr><td><code>Cluster</code></td><td><code>CLUSTER STATUS</code></td><td><code>ClusterStmt</code></td></tr>
<tr><td><code>Checkpoint</code></td><td><code>CHECKPOINT 'backup1'</code></td><td><code>CheckpointStmt</code></td></tr>
<tr><td><code>Entity</code></td><td><code>ENTITY CREATE 'key' {props} EMBEDDING [vec]</code></td><td><code>EntityStmt</code></td></tr>
</tbody></table>
</div>
<h2 id="expression-kinds"><a class="header" href="#expression-kinds">Expression Kinds</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Kind</th><th>Example</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>Literal</code></td><td><code>42</code>, <code>3.14</code>, <code>'hello'</code>, <code>TRUE</code>, <code>NULL</code></td><td>Five literal types</td></tr>
<tr><td><code>Ident</code></td><td><code>column_name</code></td><td>Simple identifier</td></tr>
<tr><td><code>Qualified</code></td><td><code>table.column</code></td><td>Dot notation</td></tr>
<tr><td><code>Binary</code></td><td><code>a + b</code>, <code>x AND y</code></td><td>18 binary operators</td></tr>
<tr><td><code>Unary</code></td><td><code>NOT flag</code>, <code>-value</code>, <code>~bits</code></td><td>3 unary operators</td></tr>
<tr><td><code>Call</code></td><td><code>COUNT(*)</code>, <code>MAX(price)</code></td><td>Function with args</td></tr>
<tr><td><code>Case</code></td><td><code>CASE WHEN x THEN y ELSE z END</code></td><td>Simple and searched</td></tr>
<tr><td><code>Subquery</code></td><td><code>(SELECT ...)</code></td><td>Nested SELECT</td></tr>
<tr><td><code>Exists</code></td><td><code>EXISTS (SELECT 1 ...)</code></td><td>Existence test</td></tr>
<tr><td><code>In</code></td><td><code>x IN (1, 2, 3)</code> or <code>x IN (SELECT...)</code></td><td>Value list or subquery</td></tr>
<tr><td><code>Between</code></td><td><code>x BETWEEN 1 AND 10</code></td><td>Range check</td></tr>
<tr><td><code>Like</code></td><td><code>name LIKE '%smith'</code></td><td>Pattern matching</td></tr>
<tr><td><code>IsNull</code></td><td><code>x IS NULL</code>, <code>y IS NOT NULL</code></td><td>NULL check</td></tr>
<tr><td><code>Array</code></td><td><code>[1, 2, 3]</code></td><td>Array literal</td></tr>
<tr><td><code>Tuple</code></td><td><code>(1, 2, 3)</code></td><td>Tuple/row literal</td></tr>
<tr><td><code>Cast</code></td><td><code>CAST(x AS INT)</code></td><td>Type conversion</td></tr>
<tr><td><code>Wildcard</code></td><td><code>*</code></td><td>All columns</td></tr>
<tr><td><code>QualifiedWildcard</code></td><td><code>table.*</code></td><td>All columns from table</td></tr>
</tbody></table>
</div>
<h2 id="span-tracking-implementation"><a class="header" href="#span-tracking-implementation">Span Tracking Implementation</a></h2>
<h3 id="bytepos-and-span"><a class="header" href="#bytepos-and-span">BytePos and Span</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A byte position in source code (u32 for memory efficiency).
pub struct BytePos(pub u32);

/// A span representing a range of source code.
pub struct Span {
    pub start: BytePos,  // Inclusive
    pub end: BytePos,    // Exclusive
}

impl Span {
    /// Combines two spans into one that covers both.
    pub const fn merge(self, other: Span) -&gt; Span {
        let start = if self.start.0 &lt; other.start.0 { self.start } else { other.start };
        let end = if self.end.0 &gt; other.end.0 { self.end } else { other.end };
        Span { start, end }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="linecolumn-calculation"><a class="header" href="#linecolumn-calculation">Line/Column Calculation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Computes line and column from a byte position.
pub fn line_col(source: &amp;str, pos: BytePos) -&gt; (usize, usize) {
    let offset = pos.as_usize().min(source.len());
    let mut line = 1;
    let mut col = 1;

    for (i, ch) in source.char_indices() {
        if i &gt;= offset { break; }
        if ch == '\n' {
            line += 1;
            col = 1;
        } else {
            col += 1;
        }
    }

    (line, col)
}

/// Returns the line containing a position.
pub fn get_line(source: &amp;str, pos: BytePos) -&gt; &amp;str {
    let offset = pos.as_usize().min(source.len());
    let line_start = source[..offset].rfind('\n').map(|i| i + 1).unwrap_or(0);
    let line_end = source[offset..].find('\n').map(|i| offset + i).unwrap_or(source.len());
    &amp;source[line_start..line_end]
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h2>
<h3 id="error-creation-patterns"><a class="header" href="#error-creation-patterns">Error Creation Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unexpected token
ParseError::unexpected(
    TokenKind::Comma,
    self.current.span,
    "column name"
)

// Unexpected EOF
ParseError::unexpected_eof(
    self.current.span,
    "expression"
)

// Invalid syntax
ParseError::invalid(
    "CASE requires at least one WHEN clause",
    self.current.span
)

// With help message
ParseError::invalid("unknown keyword SELCT", span)
    .with_help("did you mean SELECT?")
<span class="boring">}</span></code></pre></pre>
<h3 id="error-formatting"><a class="header" href="#error-formatting">Error Formatting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn format_with_source(&amp;self, source: &amp;str) -&gt; String {
    let (line, col) = line_col(source, self.span.start);
    let line_text = get_line(source, self.span.start);

    // Build error message with source context
    let mut result = format!("error: {}\n", self.kind);
    result.push_str(&amp;format!("  --&gt; line {}:{}\n", line, col));
    result.push_str("   |\n");
    result.push_str(&amp;format!("{:3} | {}\n", line, line_text));
    result.push_str("   | ");

    // Add carets under the error location
    for _ in 0..(col - 1) { result.push(' '); }
    let len = self.span.len().max(1) as usize;
    for _ in 0..len.min(line_text.len() - col + 1).max(1) {
        result.push('^');
    }
    result.push('\n');

    if let Some(help) = &amp;self.help {
        result.push_str(&amp;format!("   = help: {}\n", help));
    }

    result
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-error-output"><a class="header" href="#example-error-output">Example Error Output</a></h3>
<pre><code class="language-sql">error: unexpected FROM, expected expression or '*' after SELECT
  --&gt; line 1:8
   |
  1 | SELECT FROM users
   |        ^^^^
</code></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="parse-a-statement"><a class="header" href="#parse-a-statement">Parse a Statement</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neumann_parser::parse;

let stmt = parse("SELECT * FROM users WHERE id = 1")?;

match &amp;stmt.kind {
    StatementKind::Select(select) =&gt; {
        println!("Distinct: {}", select.distinct);
        println!("Columns: {}", select.columns.len());
        if let Some(from) = &amp;select.from {
            println!("Table: {:?}", from.table.kind);
        }
        if let Some(where_clause) = &amp;select.where_clause {
            println!("Has WHERE clause");
        }
    }
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="parse-multiple-statements"><a class="header" href="#parse-multiple-statements">Parse Multiple Statements</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neumann_parser::parse_all;

let stmts = parse_all("SELECT 1; SELECT 2; INSERT INTO t VALUES (1)")?;
assert_eq!(stmts.len(), 3);

for stmt in &amp;stmts {
    println!("Statement at {:?}", stmt.span);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="parse-an-expression"><a class="header" href="#parse-an-expression">Parse an Expression</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neumann_parser::parse_expr;

let expr = parse_expr("1 + 2 * 3")?;
// Parses as: 1 + (2 * 3) due to precedence

if let ExprKind::Binary(lhs, BinaryOp::Add, rhs) = expr.kind {
    // lhs = Literal(1)
    // rhs = Binary(Literal(2), Mul, Literal(3))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tokenize-source"><a class="header" href="#tokenize-source">Tokenize Source</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neumann_parser::tokenize;

let tokens = tokenize("SELECT * FROM users");
for token in tokens {
    println!("{:?} at {:?}", token.kind, token.span);
}

// Output:
// Select at 0..6
// Star at 7..8
// From at 9..13
// Ident("users") at 14..19
// Eof at 19..19
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-the-parser-directly"><a class="header" href="#working-with-the-parser-directly">Working with the Parser Directly</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neumann_parser::Parser;

let mut parser = Parser::new("SELECT 1; SELECT 2");

// Parse first statement
let stmt1 = parser.parse_statement()?;
assert!(matches!(stmt1.kind, StatementKind::Select(_)));

// Parse second statement
let stmt2 = parser.parse_statement()?;
assert!(matches!(stmt2.kind, StatementKind::Select(_)));

// Third call returns Empty (EOF)
let stmt3 = parser.parse_statement()?;
assert!(matches!(stmt3.kind, StatementKind::Empty));
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neumann_parser::parse;

let result = parse("SELECT FROM users");
if let Err(e) = result {
    // Format error with source context
    let formatted = e.format_with_source("SELECT FROM users");
    println!("{}", formatted);

    // Access error details
    println!("Error kind: {:?}", e.kind);
    println!("Span: {:?}", e.span);
    if let Some(help) = &amp;e.help {
        println!("Help: {}", help);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="grammar-overview"><a class="header" href="#grammar-overview">Grammar Overview</a></h2>
<h3 id="select-statement"><a class="header" href="#select-statement">SELECT Statement</a></h3>
<pre><code class="language-sql">SELECT [DISTINCT | ALL] columns
FROM table [alias]
[JOIN table ON condition | USING (cols)]...
[WHERE condition]
[GROUP BY exprs]
[HAVING condition]
[ORDER BY expr [ASC|DESC] [NULLS FIRST|LAST]]...
[LIMIT n]
[OFFSET n]
</code></pre>
<h3 id="create-table-statement"><a class="header" href="#create-table-statement">CREATE TABLE Statement</a></h3>
<pre><code class="language-sql">CREATE TABLE [IF NOT EXISTS] name (
    column type [NULL|NOT NULL] [PRIMARY KEY] [UNIQUE]
                [DEFAULT expr] [CHECK(expr)]
                [REFERENCES table(col) [ON DELETE action] [ON UPDATE action]]
    [, ...]
    [, PRIMARY KEY (cols)]
    [, UNIQUE (cols)]
    [, FOREIGN KEY (cols) REFERENCES table(cols)]
    [, CHECK (expr)]
)
</code></pre>
<h3 id="graph-operations"><a class="header" href="#graph-operations">Graph Operations</a></h3>
<pre><code class="language-sql">NODE CREATE label {properties}
NODE GET id
NODE DELETE id
NODE LIST [label]

EDGE CREATE from -&gt; to : type {properties}
EDGE GET id
EDGE DELETE id
EDGE LIST [type]

NEIGHBORS node [OUTGOING|INCOMING|BOTH] [edge_type]
          [BY SIMILAR [vector] LIMIT n]

PATH [SHORTEST|ALL] from TO to [MAX depth]
</code></pre>
<h3 id="vector-operations"><a class="header" href="#vector-operations">Vector Operations</a></h3>
<pre><code class="language-sql">EMBED STORE key [vector]
EMBED GET key
EMBED DELETE key
EMBED BUILD INDEX
EMBED BATCH [(key, [vector]), ...]

SIMILAR key|[vector] [LIMIT k] [COSINE|EUCLIDEAN|DOT_PRODUCT]
        [CONNECTED TO entity]
</code></pre>
<h3 id="chain-operations"><a class="header" href="#chain-operations">Chain Operations</a></h3>
<pre><code class="language-text">BEGIN CHAIN TRANSACTION
COMMIT CHAIN
ROLLBACK CHAIN TO height

CHAIN HEIGHT
CHAIN TIP
CHAIN BLOCK height
CHAIN VERIFY
CHAIN HISTORY key
CHAIN SIMILAR [embedding] LIMIT n
CHAIN DRIFT FROM height TO height

SHOW CODEBOOK GLOBAL
SHOW CODEBOOK LOCAL domain
ANALYZE CODEBOOK TRANSITIONS
</code></pre>
<h2 id="reserved-keywords"><a class="header" href="#reserved-keywords">Reserved Keywords</a></h2>
<p>Keywords are case-insensitive. The lexer converts to uppercase for matching.</p>
<p><strong>SQL (70+ keywords)</strong>: SELECT, DISTINCT, ALL, FROM, WHERE, INSERT, INTO,
VALUES, UPDATE, SET, DELETE, CREATE, DROP, TABLE, INDEX, AND, OR, NOT, NULL, IS,
IN, LIKE, BETWEEN, ORDER, BY, ASC, DESC, NULLS, FIRST, LAST, LIMIT, OFFSET,
GROUP, HAVING, JOIN, INNER, LEFT, RIGHT, FULL, OUTER, CROSS, NATURAL, ON, USING,
AS, PRIMARY, KEY, UNIQUE, REFERENCES, FOREIGN, CHECK, DEFAULT, CASCADE,
RESTRICT, IF, EXISTS, SHOW, TABLES, UNION, INTERSECT, EXCEPT, CASE, WHEN, THEN,
ELSE, END, CAST, ANY</p>
<p><strong>Types (16 keywords)</strong>: INT, INTEGER, BIGINT, SMALLINT, FLOAT, DOUBLE, REAL,
DECIMAL, NUMERIC, VARCHAR, CHAR, TEXT, BOOLEAN, DATE, TIME, TIMESTAMP</p>
<p><strong>Aggregates (5 keywords)</strong>: COUNT, SUM, AVG, MIN, MAX</p>
<p><strong>Graph (16 keywords)</strong>: NODE, EDGE, NEIGHBORS, PATH, GET, LIST, STORE,
OUTGOING, INCOMING, BOTH, SHORTEST, PROPERTIES, LABEL, VERTEX, VERTICES, EDGES</p>
<p><strong>Vector (10 keywords)</strong>: EMBED, SIMILAR, VECTOR, EMBEDDING, DIMENSION,
DISTANCE, COSINE, EUCLIDEAN, DOT_PRODUCT, BUILD</p>
<p><strong>Unified (6 keywords)</strong>: FIND, WITH, RETURN, MATCH, ENTITY, CONNECTED</p>
<p><strong>Domain (30+ keywords)</strong>: VAULT, GRANT, REVOKE, ROTATE, CACHE, INIT, STATS,
CLEAR, EVICT, PUT, SEMANTIC, THRESHOLD, CHECKPOINT, ROLLBACK, CHAIN, BEGIN,
COMMIT, TRANSACTION, HISTORY, DRIFT, CODEBOOK, GLOBAL, LOCAL, ANALYZE, HEIGHT,
TIP, BLOCK, CLUSTER, CONNECT, DISCONNECT, STATUS, NODES, LEADER, BLOB, BLOBS,
INFO, LINK, TAG, VERIFY, GC, REPAIR</p>
<h3 id="contextual-keywords"><a class="header" href="#contextual-keywords">Contextual Keywords</a></h3>
<p>These keywords can be used as identifiers in expression contexts (column names,
etc.):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_contextual_keyword(&amp;self) -&gt; bool {
    matches!(self,
        Status | Nodes | Leader | Connect | Disconnect | Cluster |
        Blobs | Info | Link | Unlink | Links | Tag | Untag | Verify | Gc | Repair |
        Height | Transitions | Tip | Block | Codebook | Global | Local | Drift |
        Begin | Commit | Transaction | ...
    )
}
<span class="boring">}</span></code></pre></pre>
<h2 id="edge-cases-and-gotchas"><a class="header" href="#edge-cases-and-gotchas">Edge Cases and Gotchas</a></h2>
<h3 id="ambiguous-token-sequences"><a class="header" href="#ambiguous-token-sequences">Ambiguous Token Sequences</a></h3>
<ol>
<li><strong>Minus vs Arrow</strong>: <code>-</code> vs <code>-&gt;</code> distinguished by lookahead</li>
<li><strong>Less-than variants</strong>: <code>&lt;</code> vs <code>&lt;=</code> vs <code>&lt;&gt;</code> vs <code>&lt;&lt;</code></li>
<li><strong>Pipe variants</strong>: <code>|</code> (bitwise) vs <code>||</code> (concat)</li>
<li><strong>Keyword as identifier</strong>: <code>SELECT status FROM orders</code> - <code>status</code> is
contextual keyword</li>
</ol>
<h3 id="number-parsing-edge-cases"><a class="header" href="#number-parsing-edge-cases">Number Parsing Edge Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// "3." is integer 3 followed by dot
tokens("3. ") // [Integer(3), Dot, Eof]

// "3.0" is float
tokens("3.0") // [Float(3.0), Eof]

// "3.x" is integer 3, dot, identifier x
tokens("3.x") // [Integer(3), Dot, Ident("x"), Eof]

// Scientific notation
tokens("1e10")   // [Float(1e10), Eof]
tokens("2.5E-3") // [Float(0.0025), Eof]
<span class="boring">}</span></code></pre></pre>
<h3 id="string-literal-edge-cases"><a class="header" href="#string-literal-edge-cases">String Literal Edge Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SQL-style doubled quotes
tokens("'it''s'") // [String("it's"), Eof]

// Unterminated string
tokens("'unterminated") // [Error("unterminated string literal"), Eof]

// String with newline (error)
tokens("'line1\nline2'") // Error - strings cannot span lines
<span class="boring">}</span></code></pre></pre>
<h3 id="expression-depth-limit"><a class="header" href="#expression-depth-limit">Expression Depth Limit</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Deeply nested expressions hit the depth limit (64)
let mut expr = "x".to_string();
for _ in 0..70 {
    expr = format!("({})", expr);
}
parse_expr(&amp;expr) // Err(ParseErrorKind::TooDeep)
<span class="boring">}</span></code></pre></pre>
<h3 id="between-precedence"><a class="header" href="#between-precedence">BETWEEN Precedence</a></h3>
<p>The <code>AND</code> in <code>BETWEEN low AND high</code> is part of the BETWEEN syntax, not a logical
operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// "x BETWEEN 1 AND 10 AND y = 5" parses as:
// (x BETWEEN 1 AND 10) AND (y = 5)
// Not: x BETWEEN 1 AND (10 AND y = 5)
<span class="boring">}</span></code></pre></pre>
<h3 id="qualified-wildcard-restriction"><a class="header" href="#qualified-wildcard-restriction">Qualified Wildcard Restriction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Valid: table.*
parse_expr("users.*") // Ok(QualifiedWildcard)

// Invalid: (expr).*
parse_expr("(1 + 2).*") // Err("qualified wildcard requires identifier")
<span class="boring">}</span></code></pre></pre>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Complexity</th><th>Notes</th></tr></thead><tbody>
<tr><td>Tokenize</td><td>O(n)</td><td>Single pass, no backtracking</td></tr>
<tr><td>Parse</td><td>O(n)</td><td>Single pass, constant stack per token</td></tr>
<tr><td>Total</td><td>O(n)</td><td>Where n = input length</td></tr>
</tbody></table>
</div>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li>Lexer: O(1) - only stores position and one peeked character</li>
<li>Parser: O(1) - only stores current and peeked token</li>
<li>AST: O(n) - proportional to number of nodes</li>
<li>Span: 8 bytes per span (two u32 values)</li>
</ul>
<h3 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h3>
<ol>
<li><strong>Keyword lookup</strong>: O(1) via match statement on uppercase string</li>
<li><strong>Token comparison</strong>: Uses <code>std::mem::discriminant</code> for enum comparison</li>
<li><strong>Span tracking</strong>: Constant-time merge operation</li>
<li><strong>No allocations during parsing</strong>: Identifiers and strings owned in tokens</li>
</ol>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Relationship</th></tr></thead><tbody>
<tr><td><code>query_router</code></td><td>Consumes AST and executes queries against engines</td></tr>
<tr><td><code>neumann_shell</code></td><td>Uses parser for interactive REPL commands</td></tr>
<tr><td><code>tensor_chain</code></td><td>Chain statements (BEGIN, COMMIT, HISTORY) parsed here</td></tr>
<tr><td><code>tensor_vault</code></td><td>Vault statements (SET, GET, GRANT) parsed here</td></tr>
<tr><td><code>tensor_cache</code></td><td>Cache statements (INIT, STATS, PUT) parsed here</td></tr>
<tr><td><code>tensor_blob</code></td><td>Blob statements (PUT, GET, TAG) parsed here</td></tr>
</tbody></table>
</div>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The parser has comprehensive test coverage including:</p>
<ul>
<li><strong>Unit tests in each module</strong>: Token, span, lexer, parser, expression tests</li>
<li><strong>Integration tests</strong>: Complex SQL queries, multi-statement parsing</li>
<li><strong>Edge case tests</strong>: Unterminated strings, deeply nested expressions,
ambiguous operators</li>
<li><strong>Fuzz targets</strong>: <code>parser_parse</code>, <code>parser_parse_all</code>, <code>parser_parse_expr</code>,
<code>parser_tokenize</code></li>
</ul>
<pre><code class="language-bash"># Run parser tests
cargo test -p neumann_parser

# Run parser fuzz targets
cargo +nightly fuzz run parser_parse -- -max_total_time=60
cargo +nightly fuzz run parser_tokenize -- -max_total_time=60
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/tensor-chain.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/query-router.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/tensor-chain.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/query-router.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
