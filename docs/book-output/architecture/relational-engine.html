<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Relational Engine - Neumann</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Unified tensor-based runtime for relational, graph, and vector data">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neumann</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann/edit/main/docs/book/src/architecture/relational-engine.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="relational-engine"><a class="header" href="#relational-engine">Relational Engine</a></h1>
<p>The Relational Engine (Module 2) provides SQL-like table operations on top of
the Tensor Store. It implements schema enforcement, composable condition
predicates, SIMD-accelerated columnar filtering, and both hash and B-tree
indexes for query acceleration.</p>
<p>Tables, rows, and indexes are stored as tensor data in the underlying Tensor
Store, inheriting its thread safety from DashMap. The engine supports all
standard CRUD operations, six SQL join types, aggregate functions, and batch
operations for bulk inserts.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre class="mermaid">flowchart TD
    subgraph RelationalEngine
        API[Public API]
        Schema[Schema Validation]
        Cond[Condition Evaluation]
        Hash[Hash Index]
        BTree[B-Tree Index]
        Columnar[Columnar SIMD]
    end

    API --&gt; Schema
    API --&gt; Cond
    Cond --&gt; Hash
    Cond --&gt; BTree
    Cond --&gt; Columnar

    subgraph TensorStore
        Store[(DashMap Storage)]
        Meta[Table Metadata]
        Rows[Row Data]
        Idx[Index Entries]
    end

    Schema --&gt; Meta
    API --&gt; Rows
    Hash --&gt; Idx
    BTree --&gt; Idx
</pre>
<h3 id="query-execution-flow"><a class="header" href="#query-execution-flow">Query Execution Flow</a></h3>
<pre class="mermaid">flowchart TD
    Query[SELECT Query] --&gt; ParseCond[Parse Condition]
    ParseCond --&gt; CheckIdx{Has Index?}

    CheckIdx --&gt;|Hash Index + Eq| HashLookup[O(1) Hash Lookup]
    CheckIdx --&gt;|BTree + Range| BTreeRange[O(log n) Range Scan]
    CheckIdx --&gt;|No Index| FullScan[Full Table Scan]

    HashLookup --&gt; FilterRows[Apply Remaining Conditions]
    BTreeRange --&gt; FilterRows
    FullScan --&gt; SIMDFilter{Columnar Data?}

    SIMDFilter --&gt;|Yes| VectorFilter[SIMD Vectorized Filter]
    SIMDFilter --&gt;|No| RowFilter[Row-by-Row Filter]

    VectorFilter --&gt; Results[Build Result Set]
    RowFilter --&gt; Results
    FilterRows --&gt; Results
</pre>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RelationalEngine</code></td><td>Main engine struct with TensorStore backend</td></tr>
<tr><td><code>Schema</code></td><td>Table schema with column definitions</td></tr>
<tr><td><code>Column</code></td><td>Column name, type, and nullability</td></tr>
<tr><td><code>ColumnType</code></td><td><code>Int</code>, <code>Float</code>, <code>String</code>, <code>Bool</code></td></tr>
<tr><td><code>Value</code></td><td>Typed value: <code>Null</code>, <code>Int(i64)</code>, <code>Float(f64)</code>, <code>String(String)</code>, <code>Bool(bool)</code></td></tr>
<tr><td><code>Row</code></td><td>Row with ID and ordered column values</td></tr>
<tr><td><code>Condition</code></td><td>Composable filter predicate tree</td></tr>
<tr><td><code>RelationalError</code></td><td>Error variants for table/column/index operations</td></tr>
<tr><td><code>ColumnData</code></td><td>Columnar storage for a single column with null bitmap</td></tr>
<tr><td><code>SelectionVector</code></td><td>Bitmap-based row selection for SIMD operations</td></tr>
<tr><td><code>OrderedKey</code></td><td>B-tree index key with total ordering semantics</td></tr>
</tbody></table>
</div>
<h3 id="column-types"><a class="header" href="#column-types">Column Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Rust Type</th><th>Storage Format</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Int</code></td><td><code>i64</code></td><td>8-byte little-endian</td><td>64-bit signed integer</td></tr>
<tr><td><code>Float</code></td><td><code>f64</code></td><td>8-byte IEEE 754</td><td>64-bit floating point</td></tr>
<tr><td><code>String</code></td><td><code>String</code></td><td>Dictionary-encoded</td><td>UTF-8 string with deduplication</td></tr>
<tr><td><code>Bool</code></td><td><code>bool</code></td><td>Packed bitmap (64 values per u64)</td><td>Boolean</td></tr>
</tbody></table>
</div>
<h3 id="conditions"><a class="header" href="#conditions">Conditions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Condition</th><th>Description</th><th>Index Support</th></tr></thead><tbody>
<tr><td><code>Condition::True</code></td><td>Matches all rows</td><td>N/A</td></tr>
<tr><td><code>Condition::Eq(col, val)</code></td><td>Column equals value</td><td>Hash Index</td></tr>
<tr><td><code>Condition::Ne(col, val)</code></td><td>Column not equals value</td><td>None</td></tr>
<tr><td><code>Condition::Lt(col, val)</code></td><td>Column less than value</td><td>B-Tree Index</td></tr>
<tr><td><code>Condition::Le(col, val)</code></td><td>Column less than or equal</td><td>B-Tree Index</td></tr>
<tr><td><code>Condition::Gt(col, val)</code></td><td>Column greater than value</td><td>B-Tree Index</td></tr>
<tr><td><code>Condition::Ge(col, val)</code></td><td>Column greater than or equal</td><td>B-Tree Index</td></tr>
<tr><td><code>Condition::And(a, b)</code></td><td>Logical AND of two conditions</td><td>Partial (first indexable)</td></tr>
<tr><td><code>Condition::Or(a, b)</code></td><td>Logical OR of two conditions</td><td>None</td></tr>
</tbody></table>
</div>
<p>Conditions can be combined using <code>.and()</code> and <code>.or()</code> methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// age &gt;= 18 AND age &lt; 65
let condition = Condition::Ge("age".into(), Value::Int(18))
    .and(Condition::Lt("age".into(), Value::Int(65)));

// status = 'active' OR priority &gt; 5
let condition = Condition::Eq("status".into(), Value::String("active".into()))
    .or(Condition::Gt("priority".into(), Value::Int(5)));
<span class="boring">}</span></code></pre></pre>
<p>The special column <code>_id</code> filters by row ID and can be indexed.</p>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Error</th><th>Cause</th></tr></thead><tbody>
<tr><td><code>TableNotFound</code></td><td>Table does not exist</td></tr>
<tr><td><code>TableAlreadyExists</code></td><td>Creating duplicate table</td></tr>
<tr><td><code>ColumnNotFound</code></td><td>Update references unknown column</td></tr>
<tr><td><code>TypeMismatch</code></td><td>Value type does not match column type</td></tr>
<tr><td><code>NullNotAllowed</code></td><td>NULL in non-nullable column</td></tr>
<tr><td><code>IndexAlreadyExists</code></td><td>Creating duplicate index</td></tr>
<tr><td><code>IndexNotFound</code></td><td>Dropping non-existent index</td></tr>
<tr><td><code>StorageError</code></td><td>Underlying Tensor Store error</td></tr>
</tbody></table>
</div>
<h2 id="storage-model"><a class="header" href="#storage-model">Storage Model</a></h2>
<p>Tables, rows, and indexes are stored in Tensor Store with specific key patterns:</p>
<div class="table-wrapper"><table><thead><tr><th>Key Pattern</th><th>Content</th></tr></thead><tbody>
<tr><td><code>_meta:table:{name}</code></td><td>Schema metadata</td></tr>
<tr><td><code>{table}:{row_id}</code></td><td>Row data</td></tr>
<tr><td><code>_idx:{table}:{column}</code></td><td>Hash index metadata</td></tr>
<tr><td><code>_idx:{table}:{column}:{hash}</code></td><td>Hash index entries (list of row IDs)</td></tr>
<tr><td><code>_btree:{table}:{column}</code></td><td>B-tree index metadata</td></tr>
<tr><td><code>_btree:{table}:{column}:{sortable_key}</code></td><td>B-tree index entries</td></tr>
<tr><td><code>_col:{table}:{column}:data</code></td><td>Columnar data storage</td></tr>
<tr><td><code>_col:{table}:{column}:ids</code></td><td>Columnar row ID mapping</td></tr>
<tr><td><code>_col:{table}:{column}:nulls</code></td><td>Columnar null bitmap</td></tr>
<tr><td><code>_col:{table}:{column}:meta</code></td><td>Columnar metadata</td></tr>
</tbody></table>
</div>
<p>Schema metadata encodes:</p>
<ul>
<li><code>_columns</code>: Comma-separated column names</li>
<li><code>_col:{name}</code>: Type and nullability for each column</li>
</ul>
<h3 id="row-storage-format"><a class="header" href="#row-storage-format">Row Storage Format</a></h3>
<p>Each row is stored as a <code>TensorData</code> object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal row structure
{
    "_id": Scalar(Int(row_id)),
    "name": Scalar(String("Alice")),
    "age": Scalar(Int(30)),
    "email": Scalar(String("alice@example.com"))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="table-operations"><a class="header" href="#table-operations">Table Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let engine = RelationalEngine::new();

// Create table with schema
let schema = Schema::new(vec![
    Column::new("name", ColumnType::String),
    Column::new("age", ColumnType::Int),
    Column::new("email", ColumnType::String).nullable(),
]);
engine.create_table("users", schema)?;

// Check existence
engine.table_exists("users")?;  // -&gt; bool

// List all tables
let tables = engine.list_tables();  // -&gt; Vec&lt;String&gt;

// Get schema
let schema = engine.get_schema("users")?;

// Drop table (deletes all rows and indexes)
engine.drop_table("users")?;

// Row count
engine.row_count("users")?;  // -&gt; usize
<span class="boring">}</span></code></pre></pre>
<h3 id="crud-operations"><a class="header" href="#crud-operations">CRUD Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// INSERT
let mut values = HashMap::new();
values.insert("name".to_string(), Value::String("Alice".into()));
values.insert("age".to_string(), Value::Int(30));
let row_id = engine.insert("users", values)?;

// BATCH INSERT (59x faster for bulk inserts)
let rows: Vec&lt;HashMap&lt;String, Value&gt;&gt; = (0..1000)
    .map(|i| {
        let mut values = HashMap::new();
        values.insert("name".to_string(), Value::String(format!("User{}", i)));
        values.insert("age".to_string(), Value::Int(20 + i));
        values
    })
    .collect();
let row_ids = engine.batch_insert("users", rows)?;

// SELECT
let rows = engine.select("users", Condition::Eq("age".into(), Value::Int(30)))?;

// UPDATE
let mut updates = HashMap::new();
updates.insert("age".to_string(), Value::Int(31));
let count = engine.update(
    "users",
    Condition::Eq("name".into(), Value::String("Alice".into())),
    updates
)?;

// DELETE
let count = engine.delete_rows("users", Condition::Lt("age".into(), Value::Int(18)))?;
<span class="boring">}</span></code></pre></pre>
<h3 id="joins"><a class="header" href="#joins">Joins</a></h3>
<p>All six SQL join types are supported using hash join algorithm (O(n+m)):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// INNER JOIN - Only matching rows from both tables
let joined = engine.join("users", "posts", "_id", "user_id")?;
// Returns: Vec&lt;(Row, Row)&gt;

// LEFT JOIN - All rows from left, matching from right (or None)
let joined = engine.left_join("users", "posts", "_id", "user_id")?;
// Returns: Vec&lt;(Row, Option&lt;Row&gt;)&gt;

// RIGHT JOIN - All rows from right, matching from left (or None)
let joined = engine.right_join("users", "posts", "_id", "user_id")?;
// Returns: Vec&lt;(Option&lt;Row&gt;, Row)&gt;

// FULL JOIN - All rows from both tables
let joined = engine.full_join("users", "posts", "_id", "user_id")?;
// Returns: Vec&lt;(Option&lt;Row&gt;, Option&lt;Row&gt;)&gt;

// CROSS JOIN (Cartesian product)
let joined = engine.cross_join("users", "posts")?;
// Returns: Vec&lt;(Row, Row)&gt; with n*m rows

// NATURAL JOIN (on common column names)
let joined = engine.natural_join("users", "user_profiles")?;
// Returns: Vec&lt;(Row, Row)&gt; matching on all common columns
<span class="boring">}</span></code></pre></pre>
<h3 id="aggregate-functions"><a class="header" href="#aggregate-functions">Aggregate Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// COUNT(*) - count all rows
let count = engine.count("users", Condition::True)?;

// COUNT(column) - count non-null values
let count = engine.count_column("users", "email", Condition::True)?;

// SUM - returns f64
let total = engine.sum("orders", "amount", Condition::True)?;

// AVG - returns Option&lt;f64&gt; (None if no matching rows)
let avg = engine.avg("orders", "amount", Condition::True)?;

// MIN/MAX - returns Option&lt;Value&gt;
let min = engine.min("products", "price", Condition::True)?;
let max = engine.max("products", "price", Condition::True)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="indexes"><a class="header" href="#indexes">Indexes</a></h2>
<h3 id="hash-indexes"><a class="header" href="#hash-indexes">Hash Indexes</a></h3>
<p>Hash indexes provide O(1) equality lookups for <code>Condition::Eq</code> queries:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create hash index
engine.create_index("users", "age")?;

// Check existence
engine.has_index("users", "age");  // -&gt; bool

// Get indexed columns
engine.get_indexed_columns("users");  // -&gt; Vec&lt;String&gt;

// Drop index
engine.drop_index("users", "age")?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Hash Index Implementation Details:</strong></p>
<pre class="mermaid">graph LR
    subgraph &quot;Hash Index Structure&quot;
        Value[Column Value] --&gt; Hash[hash_key()]
        Hash --&gt; Bucket[&quot;_idx:table:col:hash&quot;]
        Bucket --&gt; IDs[&quot;Vec&lt;row_id&gt;&quot;]
    end
</pre>
<p>The hash index uses value-specific hashing:</p>
<div class="table-wrapper"><table><thead><tr><th>Value Type</th><th>Hash Format</th><th>Example</th></tr></thead><tbody>
<tr><td><code>Null</code></td><td><code>"null"</code></td><td><code>"null"</code></td></tr>
<tr><td><code>Int(i)</code></td><td><code>"i:{value}"</code></td><td><code>"i:42"</code></td></tr>
<tr><td><code>Float(f)</code></td><td><code>"f:{bits}"</code></td><td><code>"f:4614253070214989087"</code></td></tr>
<tr><td><code>String(s)</code></td><td><code>"s:{hash}"</code></td><td><code>"s:a1b2c3d4"</code></td></tr>
<tr><td><code>Bool(b)</code></td><td><code>"b:{value}"</code></td><td><code>"b:true"</code></td></tr>
</tbody></table>
</div>
<p>Hash index performance:</p>
<div class="table-wrapper"><table><thead><tr><th>Query Type</th><th>Without Index</th><th>With Index</th><th>Speedup</th></tr></thead><tbody>
<tr><td>Equality (2% match on 5K rows)</td><td>5.96ms</td><td>126us</td><td>47x</td></tr>
<tr><td>Single row by _id (5K rows)</td><td>5.59ms</td><td>3.5us</td><td>1,597x</td></tr>
</tbody></table>
</div>
<h3 id="b-tree-indexes"><a class="header" href="#b-tree-indexes">B-Tree Indexes</a></h3>
<p>B-tree indexes accelerate range queries (<code>Lt</code>, <code>Le</code>, <code>Gt</code>, <code>Ge</code>) with O(log n +
m) complexity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create B-tree index
engine.create_btree_index("users", "age")?;

// Check existence
engine.has_btree_index("users", "age");  // -&gt; bool

// Get B-tree indexed columns
engine.get_btree_indexed_columns("users");  // -&gt; Vec&lt;String&gt;

// Drop index
engine.drop_btree_index("users", "age")?;

// Range queries now use the index
engine.select("users", Condition::Ge("age".into(), Value::Int(18)))?;
<span class="boring">}</span></code></pre></pre>
<p><strong>B-Tree Index Implementation Details:</strong></p>
<p>The B-tree index uses a dual-storage approach:</p>
<ol>
<li><strong>In-memory BTreeMap</strong>: For O(log n) range operations</li>
<li><strong>Persistent TensorStore</strong>: For durability and recovery</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal B-tree index structure
btree_indexes: RwLock&lt;HashMap&lt;
    (String, String),           // (table, column)
    BTreeMap&lt;OrderedKey, Vec&lt;u64&gt;&gt;  // value -&gt; row_ids
&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p><strong>OrderedKey for Total Ordering:</strong></p>
<p>The <code>OrderedKey</code> enum provides correct ordering semantics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum OrderedKey {
    Null,                    // Sorts first
    Bool(bool),              // false &lt; true
    Int(i64),                // Standard integer ordering
    Float(OrderedFloat),     // NaN &lt; all other values
    String(String),          // Lexicographic ordering
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Sortable Key Encoding:</strong></p>
<p>For persistent storage, values are encoded to maintain lexicographic ordering:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Encoding</th><th>Example</th></tr></thead><tbody>
<tr><td><code>Null</code></td><td><code>"0"</code></td><td><code>"0"</code></td></tr>
<tr><td><code>Int(i)</code></td><td><code>"i{hex(i + 2^63)}"</code></td><td><code>"i8000000000000000"</code> for 0</td></tr>
<tr><td><code>Float(f)</code></td><td><code>"f{sortable_bits}"</code></td><td>IEEE 754 with sign handling</td></tr>
<tr><td><code>String(s)</code></td><td><code>"s{s}"</code></td><td><code>"sAlice"</code></td></tr>
<tr><td><code>Bool(b)</code></td><td><code>"b0"</code> or <code>"b1"</code></td><td><code>"b1"</code> for true</td></tr>
</tbody></table>
</div>
<p>Integer encoding shifts the range from <code>[-2^63, 2^63-1]</code> to <code>[0, 2^64-1]</code> for
correct lexicographic ordering of negative numbers.</p>
<p><strong>B-Tree Range Operations:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Internal range lookup
fn btree_range_lookup(&amp;self, table: &amp;str, column: &amp;str,
                      value: &amp;Value, op: RangeOp) -&gt; Option&lt;Vec&lt;u64&gt;&gt; {
    match op {
        RangeOp::Lt =&gt; btree.range(..target),
        RangeOp::Le =&gt; btree.range(..=target),
        RangeOp::Gt =&gt; btree.range((Excluded(target), Unbounded)),
        RangeOp::Ge =&gt; btree.range(target..),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="columnar-architecture"><a class="header" href="#columnar-architecture">Columnar Architecture</a></h2>
<p>The engine uses columnar storage with SIMD-accelerated filtering:</p>
<h3 id="columnar-data-structures"><a class="header" href="#columnar-data-structures">Columnar Data Structures</a></h3>
<pre class="mermaid">graph TD
    subgraph &quot;ColumnData&quot;
        Name[name: String]
        RowIDs[row_ids: Vec&lt;u64&gt;]
        Nulls[nulls: NullBitmap]
        Values[values: ColumnValues]
    end

    subgraph &quot;ColumnValues Variants&quot;
        Int[&quot;Int(Vec&lt;i64&gt;)&quot;]
        Float[&quot;Float(Vec&lt;f64&gt;)&quot;]
        String[&quot;String { dict, indices }&quot;]
        Bool[&quot;Bool(Vec&lt;u64&gt;)&quot;]
    end

    subgraph &quot;NullBitmap Variants&quot;
        None[&quot;None (no nulls)&quot;]
        Dense[&quot;Dense(Vec&lt;u64&gt;)&quot;]
        Sparse[&quot;Sparse(Vec&lt;u64&gt;)&quot;]
    end

    Values --&gt; Int
    Values --&gt; Float
    Values --&gt; String
    Values --&gt; Bool
    Nulls --&gt; None
    Nulls --&gt; Dense
    Nulls --&gt; Sparse
</pre>
<p><strong>Null Bitmap Selection:</strong></p>
<ul>
<li><code>None</code>: When column has no null values</li>
<li><code>Sparse</code>: When nulls are &lt; 10% of rows (stores positions)</li>
<li><code>Dense</code>: When nulls are &gt;= 10% of rows (stores bitmap)</li>
</ul>
<h3 id="simd-filtering"><a class="header" href="#simd-filtering">SIMD Filtering</a></h3>
<p>Column data is stored in contiguous arrays enabling 4-wide SIMD vectorized
comparisons using the <code>wide</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SIMD filter implementation using wide::i64x4
pub fn filter_lt_i64(values: &amp;[i64], threshold: i64, result: &amp;mut [u64]) {
    let chunks = values.len() / 4;
    let threshold_vec = i64x4::splat(threshold);

    for i in 0..chunks {
        let offset = i * 4;
        let v = i64x4::new([
            values[offset],
            values[offset + 1],
            values[offset + 2],
            values[offset + 3],
        ]);
        let cmp = v.cmp_lt(threshold_vec);
        let mask_arr: [i64; 4] = cmp.into();

        for (j, &amp;m) in mask_arr.iter().enumerate() {
            if m != 0 {
                let bit_pos = offset + j;
                result[bit_pos / 64] |= 1u64 &lt;&lt; (bit_pos % 64);
            }
        }
    }

    // Handle remainder with scalar fallback
    let start = chunks * 4;
    for i in start..values.len() {
        if values[i] &lt; threshold {
            result[i / 64] |= 1u64 &lt;&lt; (i % 64);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Available SIMD Filter Functions:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Operation</th><th>Types</th></tr></thead><tbody>
<tr><td><code>filter_lt_i64</code></td><td>Less than</td><td>i64</td></tr>
<tr><td><code>filter_le_i64</code></td><td>Less than or equal</td><td>i64</td></tr>
<tr><td><code>filter_gt_i64</code></td><td>Greater than</td><td>i64</td></tr>
<tr><td><code>filter_ge_i64</code></td><td>Greater than or equal</td><td>i64</td></tr>
<tr><td><code>filter_eq_i64</code></td><td>Equal</td><td>i64</td></tr>
<tr><td><code>filter_ne_i64</code></td><td>Not equal</td><td>i64</td></tr>
<tr><td><code>filter_lt_f64</code></td><td>Less than</td><td>f64</td></tr>
<tr><td><code>filter_gt_f64</code></td><td>Greater than</td><td>f64</td></tr>
<tr><td><code>filter_eq_f64</code></td><td>Equal (with epsilon)</td><td>f64</td></tr>
</tbody></table>
</div>
<p><strong>Bitmap Operations:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AND two selection bitmaps
pub fn bitmap_and(a: &amp;[u64], b: &amp;[u64], result: &amp;mut [u64])

// OR two selection bitmaps
pub fn bitmap_or(a: &amp;[u64], b: &amp;[u64], result: &amp;mut [u64])

// Count set bits
pub fn popcount(bitmap: &amp;[u64]) -&gt; usize

// Extract selected indices
pub fn selected_indices(bitmap: &amp;[u64], max_count: usize) -&gt; Vec&lt;usize&gt;
<span class="boring">}</span></code></pre></pre>
<h3 id="selection-vectors"><a class="header" href="#selection-vectors">Selection Vectors</a></h3>
<p>Query results use bitmap-based selection vectors to avoid copying data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SelectionVector {
    bitmap: Vec&lt;u64&gt;,  // Packed bits indicating selected rows
    row_count: usize,
}

impl SelectionVector {
    // Create selection of all rows
    pub fn all(row_count: usize) -&gt; Self;

    // Create empty selection
    pub fn none(row_count: usize) -&gt; Self;

    // Check if row is selected
    pub fn is_selected(&amp;self, idx: usize) -&gt; bool;

    // Count selected rows
    pub fn count(&amp;self) -&gt; usize;

    // AND two selections (intersection)
    pub fn intersect(&amp;self, other: &amp;SelectionVector) -&gt; SelectionVector;

    // OR two selections (union)
    pub fn union(&amp;self, other: &amp;SelectionVector) -&gt; SelectionVector;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="columnar-select-api"><a class="header" href="#columnar-select-api">Columnar Select API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Materialize columns for SIMD filtering
engine.materialize_columns("users", &amp;["age", "name"])?;

// Check if columnar data exists
engine.has_columnar_data("users", "age");  // -&gt; bool

// Select with columnar scan options
let options = ColumnarScanOptions {
    projection: Some(vec!["name".into()]),  // Only return these columns
    prefer_columnar: true,                   // Use SIMD when available
};

let rows = engine.select_columnar(
    "users",
    Condition::Gt("age".into(), Value::Int(50)),
    options
)?;

// Drop columnar data
engine.drop_columnar_data("users", "age")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="condition-evaluation"><a class="header" href="#condition-evaluation">Condition Evaluation</a></h3>
<p>Two evaluation methods are available:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Input</th><th>Performance</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>evaluate(&amp;row)</code></td><td>Row struct</td><td>Legacy, creates intermediate objects</td><td>Row-by-row filtering</td></tr>
<tr><td><code>evaluate_tensor(&amp;tensor)</code></td><td>TensorData</td><td>31% faster, no intermediate allocation</td><td>Direct tensor filtering</td></tr>
</tbody></table>
</div>
<p>The engine automatically chooses the optimal evaluation path:</p>
<pre class="mermaid">flowchart TD
    Cond[Condition] --&gt; CheckColumnar{Columnar Data Available?}
    CheckColumnar --&gt;|Yes| CheckType{Int Column?}
    CheckColumnar --&gt;|No| RowEval[evaluate_tensor per row]

    CheckType --&gt;|Yes| SIMDEval[SIMD Vectorized Filter]
    CheckType --&gt;|No| RowEval

    SIMDEval --&gt; Bitmap[Selection Bitmap]
    RowEval --&gt; Filter[Filter Matching Rows]

    Bitmap --&gt; Materialize[Materialize Results]
    Filter --&gt; Materialize
</pre>
<h2 id="join-algorithm-implementations"><a class="header" href="#join-algorithm-implementations">Join Algorithm Implementations</a></h2>
<h3 id="hash-join-inner-left-right-full"><a class="header" href="#hash-join-inner-left-right-full">Hash Join (INNER, LEFT, RIGHT, FULL)</a></h3>
<p>All equality joins use the hash join algorithm with O(n+m) complexity:</p>
<pre class="mermaid">flowchart LR
    subgraph &quot;Build Phase&quot;
        RightTable[Right Table] --&gt; BuildHash[Build Hash Index]
        BuildHash --&gt; HashIndex[&quot;HashMap&lt;hash, Vec&lt;idx&gt;&gt;&quot;]
    end

    subgraph &quot;Probe Phase&quot;
        LeftTable[Left Table] --&gt; Probe[Probe Hash Index]
        Probe --&gt; HashIndex
        HashIndex --&gt; Match[Find Matching Rows]
    end

    Match --&gt; Results[Join Results]
</pre>
<p><strong>Hash Join Implementation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn join(&amp;self, table_a: &amp;str, table_b: &amp;str,
            on_a: &amp;str, on_b: &amp;str) -&gt; Result&lt;Vec&lt;(Row, Row)&gt;&gt; {
    let rows_a = self.select(table_a, Condition::True)?;
    let rows_b = self.select(table_b, Condition::True)?;

    // Build phase: index the right table
    let mut index: HashMap&lt;String, Vec&lt;usize&gt;&gt; = HashMap::with_capacity(rows_b.len());
    for (i, row) in rows_b.iter().enumerate() {
        if let Some(val) = row.get_with_id(on_b) {
            let hash = val.hash_key();
            index.entry(hash).or_default().push(i);
        }
    }

    // Probe phase: scan left table and probe index
    let mut results = Vec::with_capacity(min(rows_a.len(), rows_b.len()));
    for row_a in &amp;rows_a {
        if let Some(val) = row_a.get_with_id(on_a) {
            let hash = val.hash_key();
            if let Some(indices) = index.get(&amp;hash) {
                for &amp;i in indices {
                    let row_b = &amp;rows_b[i];
                    // Verify actual equality (handles hash collisions)
                    if row_b.get_with_id(on_b).as_ref() == Some(&amp;val) {
                        results.push((row_a.clone(), row_b.clone()));
                    }
                }
            }
        }
    }
    Ok(results)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Parallel Join Optimization:</strong></p>
<p>When left table exceeds <code>PARALLEL_THRESHOLD</code> (1000 rows), joins use Rayon for
parallel probing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if rows_a.len() &gt;= Self::PARALLEL_THRESHOLD {
    rows_a.par_iter()
        .flat_map(|row_a| {
            // Parallel probe of hash index
        })
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="natural-join"><a class="header" href="#natural-join">Natural Join</a></h3>
<p>Natural join finds all common column names and joins on their equality:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn natural_join(&amp;self, table_a: &amp;str, table_b: &amp;str) -&gt; Result&lt;Vec&lt;(Row, Row)&gt;&gt; {
    let schema_a = self.get_schema(table_a)?;
    let schema_b = self.get_schema(table_b)?;

    // Find common columns
    let cols_a: HashSet&lt;_&gt; = schema_a.columns.iter().map(|c| c.name.as_str()).collect();
    let cols_b: HashSet&lt;_&gt; = schema_b.columns.iter().map(|c| c.name.as_str()).collect();
    let common_cols: Vec&lt;_&gt; = cols_a.intersection(&amp;cols_b).copied().collect();

    // No common columns = cross join
    if common_cols.is_empty() {
        return self.cross_join(table_a, table_b);
    }

    // Build composite hash key from all common columns
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="aggregate-function-internals"><a class="header" href="#aggregate-function-internals">Aggregate Function Internals</a></h2>
<h3 id="parallel-aggregation"><a class="header" href="#parallel-aggregation">Parallel Aggregation</a></h3>
<p>For tables exceeding <code>PARALLEL_THRESHOLD</code> (1000 rows), aggregates use parallel
reduction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn avg(&amp;self, table: &amp;str, column: &amp;str, condition: Condition) -&gt; Result&lt;Option&lt;f64&gt;&gt; {
    let rows = self.select(table, condition)?;

    let (total, count) = if rows.len() &gt;= Self::PARALLEL_THRESHOLD {
        // Parallel map-reduce
        rows.par_iter()
            .map(|row| extract_numeric(row, column))
            .reduce(|| (0.0, 0u64), |(s1, c1), (s2, c2)| (s1 + s2, c1 + c2))
    } else {
        // Sequential accumulation
        let mut total = 0.0;
        let mut count = 0u64;
        for row in &amp;rows {
            // accumulate...
        }
        (total, count)
    };

    if count == 0 { Ok(None) } else { Ok(Some(total / count as f64)) }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="minmax-with-parallel-reduction"><a class="header" href="#minmax-with-parallel-reduction">MIN/MAX with Parallel Reduction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn min(&amp;self, table: &amp;str, column: &amp;str, condition: Condition) -&gt; Result&lt;Option&lt;Value&gt;&gt; {
    let rows = self.select(table, condition)?;

    if rows.len() &gt;= Self::PARALLEL_THRESHOLD {
        rows.par_iter()
            .filter_map(|row| row.get(column).filter(|v| !matches!(v, Value::Null)))
            .reduce_with(|a, b| {
                if a.partial_cmp_value(&amp;b) == Some(Ordering::Less) { a } else { b }
            })
    } else {
        // Sequential scan
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Complexity</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>insert</code></td><td>O(1) + O(k)</td><td>Schema validation + store put + k index updates</td></tr>
<tr><td><code>batch_insert</code></td><td>O(n) + O(n*k)</td><td>Single schema lookup, 59x faster than n inserts</td></tr>
<tr><td><code>select</code> (no index)</td><td>O(n)</td><td>Full table scan with SIMD filter</td></tr>
<tr><td><code>select</code> (hash index)</td><td>O(1)</td><td>Direct lookup via hash index</td></tr>
<tr><td><code>select</code> (btree range)</td><td>O(log n + m)</td><td>B-tree lookup + m matching rows</td></tr>
<tr><td><code>update</code></td><td>O(n) + O(k)</td><td>Scan + conditional update + index maintenance</td></tr>
<tr><td><code>delete_rows</code></td><td>O(n) + O(k)</td><td>Scan + conditional delete + index removal</td></tr>
<tr><td><code>join</code></td><td>O(n+m)</td><td>Hash join for all 6 join types</td></tr>
<tr><td><code>cross_join</code></td><td>O(n*m)</td><td>Cartesian product</td></tr>
<tr><td><code>count/sum/avg/min/max</code></td><td>O(n)</td><td>Single pass over matching rows</td></tr>
<tr><td><code>create_index</code></td><td>O(n)</td><td>Scan all rows to build index</td></tr>
<tr><td><code>materialize_columns</code></td><td>O(n)</td><td>Extract column to contiguous array</td></tr>
</tbody></table>
</div>
<p>Where k = number of indexes on the table, n = rows in left table, m = rows in
right table.</p>
<h3 id="parallel-threshold"><a class="header" href="#parallel-threshold">Parallel Threshold</a></h3>
<p>Operations automatically switch to parallel execution when row count exceeds
<code>PARALLEL_THRESHOLD</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RelationalEngine {
    const PARALLEL_THRESHOLD: usize = 1000;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Parallel Operations:</strong></p>
<ul>
<li><code>delete_rows</code> (parallel deletion via Rayon)</li>
<li><code>join</code> (parallel probe phase)</li>
<li><code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code> (parallel reduction)</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The Relational Engine uses the underlying TensorStore configuration. Key
internal constants:</p>
<div class="table-wrapper"><table><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>PARALLEL_THRESHOLD</code></td><td>1000</td><td>Minimum rows for parallel operations</td></tr>
<tr><td>Null bitmap sparse threshold</td><td>10%</td><td>Use sparse bitmap when nulls &lt; 10%</td></tr>
<tr><td>SIMD vector width</td><td>4</td><td>i64x4/f64x4 operations</td></tr>
</tbody></table>
</div>
<h2 id="edge-cases-and-gotchas"><a class="header" href="#edge-cases-and-gotchas">Edge Cases and Gotchas</a></h2>
<h3 id="null-handling"><a class="header" href="#null-handling">NULL Handling</a></h3>
<ol>
<li>
<p><strong>NULL in conditions</strong>: Comparisons with NULL columns return <code>false</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If email is NULL, this returns false (not true!)
Condition::Lt("email".into(), Value::String("z".into()))

<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<pre><code class="language-text">
2. **NULL in joins**: NULL values never match in join conditions:

   ```rust
   // Post with user_id = NULL will not join with any user
   engine.join("users", "posts", "_id", "user_id")
</code></pre>
<ol>
<li><strong>COUNT vs COUNT(column)</strong>:
<ul>
<li><code>count()</code> counts all rows</li>
<li><code>count_column()</code> counts non-null values only</li>
</ul>
</li>
</ol>
<h3 id="type-mismatches"><a class="header" href="#type-mismatches">Type Mismatches</a></h3>
<p>Comparisons between incompatible types return <code>false</code> rather than error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Age is Int, comparing with String returns 0 matches (not error)
engine.select("users", Condition::Lt("age".into(), Value::String("30".into())));
<span class="boring">}</span></code></pre></pre>
<h3 id="index-maintenance"><a class="header" href="#index-maintenance">Index Maintenance</a></h3>
<p>Indexes are automatically maintained on INSERT, UPDATE, and DELETE:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Creating index AFTER data exists
engine.insert("users", values)?;  // No index update
engine.create_index("users", "age")?;  // Scans all rows

// Creating index BEFORE data exists
engine.create_index("users", "age")?;  // Empty index
engine.insert("users", values)?;  // Updates index
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-insert-atomicity"><a class="header" href="#batch-insert-atomicity">Batch Insert Atomicity</a></h3>
<p><code>batch_insert</code> validates ALL rows upfront before inserting any:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rows = vec![valid_row, invalid_row];
// Fails on validation - NO rows inserted (not partial insert)
engine.batch_insert("users", rows);
<span class="boring">}</span></code></pre></pre>
<h3 id="b-tree-index-recovery"><a class="header" href="#b-tree-index-recovery">B-Tree Index Recovery</a></h3>
<p>B-tree indexes maintain both in-memory and persistent state. The in-memory
BTreeMap is rebuilt lazily on first access after restart.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="index-selection"><a class="header" href="#index-selection">Index Selection</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Query Pattern</th><th>Recommended Index</th></tr></thead><tbody>
<tr><td><code>WHERE col = value</code></td><td>Hash Index</td></tr>
<tr><td><code>WHERE col &gt; value</code></td><td>B-Tree Index</td></tr>
<tr><td><code>WHERE col BETWEEN a AND b</code></td><td>B-Tree Index</td></tr>
<tr><td><code>WHERE col IN (...)</code></td><td>Hash Index</td></tr>
<tr><td>Unique lookups by ID</td><td>Hash Index on <code>_id</code></td></tr>
</tbody></table>
</div>
<h3 id="columnar-materialization"><a class="header" href="#columnar-materialization">Columnar Materialization</a></h3>
<p>Materialize columns when:</p>
<ul>
<li>Performing many range scans on large tables</li>
<li>Query selectivity is low (scanning most rows)</li>
<li>Column data fits in memory</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Materialize frequently-filtered columns
engine.materialize_columns("events", &amp;["timestamp", "user_id"])?;

// Query uses SIMD acceleration
engine.select_columnar("events",
    Condition::Gt("timestamp".into(), Value::Int(cutoff)),
    ColumnarScanOptions { prefer_columnar: true, .. }
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<p>Use <code>batch_insert</code> for bulk loading:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: 1000 individual inserts
for row in rows {
    engine.insert("table", row)?;  // 1000 schema lookups
}

// Good: Single batch insert
engine.batch_insert("table", rows)?;  // 1 schema lookup, 59x faster
<span class="boring">}</span></code></pre></pre>
<h2 id="sql-features-via-query-router"><a class="header" href="#sql-features-via-query-router">SQL Features via Query Router</a></h2>
<p>When using the relational engine through <code>query_router</code>, additional SQL features
are available:</p>
<h3 id="order-by-and-offset"><a class="header" href="#order-by-and-offset">ORDER BY and OFFSET</a></h3>
<pre><code class="language-sql">SELECT * FROM users ORDER BY age ASC;
SELECT * FROM users ORDER BY department DESC, name ASC;
SELECT * FROM users ORDER BY email NULLS FIRST;
SELECT * FROM users ORDER BY created_at DESC LIMIT 10 OFFSET 20;
</code></pre>
<h3 id="group-by-and-having"><a class="header" href="#group-by-and-having">GROUP BY and HAVING</a></h3>
<pre><code class="language-sql">SELECT department, COUNT(*), AVG(salary) FROM employees GROUP BY department;

SELECT product, SUM(quantity) as total
FROM orders
GROUP BY product
HAVING SUM(quantity) &gt; 100;
</code></pre>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Relationship</th></tr></thead><tbody>
<tr><td><code>tensor_store</code></td><td>Storage backend for tables, rows, and indexes</td></tr>
<tr><td><code>query_router</code></td><td>Executes SQL queries using RelationalEngine</td></tr>
<tr><td><code>neumann_parser</code></td><td>Parses SQL statements into AST</td></tr>
<tr><td><code>tensor_unified</code></td><td>Multi-engine unified storage layer</td></tr>
</tbody></table>
</div>
<h2 id="feature-summary"><a class="header" href="#feature-summary">Feature Summary</a></h2>
<h3 id="implemented"><a class="header" href="#implemented">Implemented</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td>Hash indexes</td><td>O(1) equality lookups</td></tr>
<tr><td>B-tree indexes</td><td>O(log n) range query acceleration</td></tr>
<tr><td>All 6 JOIN types</td><td>INNER, LEFT, RIGHT, FULL, CROSS, NATURAL</td></tr>
<tr><td>Aggregate functions</td><td>COUNT, SUM, AVG, MIN, MAX</td></tr>
<tr><td>ORDER BY</td><td>Multi-column sorting with ASC/DESC, NULLS FIRST/LAST</td></tr>
<tr><td>LIMIT/OFFSET</td><td>Pagination support</td></tr>
<tr><td>GROUP BY + HAVING</td><td>Row grouping with aggregate filtering</td></tr>
<tr><td>Columnar storage</td><td>SIMD-accelerated filtering with selection vectors</td></tr>
<tr><td>Batch operations</td><td>59x faster bulk inserts</td></tr>
<tr><td>Parallel operations</td><td>Rayon-based parallelism for large tables</td></tr>
<tr><td>Dictionary encoding</td><td>String column compression</td></tr>
</tbody></table>
</div>
<h3 id="future-considerations"><a class="header" href="#future-considerations">Future Considerations</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th></tr></thead><tbody>
<tr><td>Query Optimization</td><td>Not implemented</td></tr>
<tr><td>Transactions</td><td>Row-level ACID with undo log - see <a href="relational-transactions.html">Transactions</a></td></tr>
<tr><td>Foreign Keys</td><td>Not implemented</td></tr>
<tr><td>Subqueries</td><td>Not implemented</td></tr>
<tr><td>Window Functions</td><td>Not implemented</td></tr>
<tr><td>Composite Indexes</td><td>Not implemented</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/tensor-store.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/relational-transactions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/tensor-store.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/relational-transactions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
