<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Neumann Shell - Neumann</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Unified tensor-based runtime for relational, graph, and vector data">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neumann</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann/edit/main/docs/book/src/architecture/neumann-shell.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="neumann-shell-architecture"><a class="header" href="#neumann-shell-architecture">Neumann Shell Architecture</a></h1>
<p>The Neumann Shell (<code>neumann_shell</code>) provides an interactive CLI interface for
the Neumann database. It is a thin layer that delegates query execution to the
Query Router while providing readline-based input handling, command history,
output formatting, and crash recovery via write-ahead logging.</p>
<p>The shell follows four design principles: human-first interface (readable
prompts, formatted output, command history), thin layer (minimal logic,
delegates to Query Router), graceful handling (Ctrl+C does not exit, errors
displayed cleanly), and zero configuration (works out of the box with sensible
defaults).</p>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Shell</code></td><td>Main shell struct holding router, config, and WAL state</td></tr>
<tr><td><code>ShellConfig</code></td><td>Configuration for history file, history size, and prompt</td></tr>
<tr><td><code>CommandResult</code></td><td>Result enum: <code>Output</code>, <code>Exit</code>, <code>Help</code>, <code>Empty</code>, <code>Error</code></td></tr>
<tr><td><code>LoopAction</code></td><td>Action after command: <code>Continue</code> or <code>Exit</code></td></tr>
<tr><td><code>ShellError</code></td><td>Error type for initialization failures</td></tr>
<tr><td><code>Wal</code></td><td>Internal write-ahead log for crash recovery</td></tr>
<tr><td><code>RouterExecutor</code></td><td>Wrapper implementing <code>QueryExecutor</code> trait for cluster operations</td></tr>
<tr><td><code>ShellConfirmationHandler</code></td><td>Interactive confirmation handler for destructive operations</td></tr>
</tbody></table>
</div>
<h2 id="shell-configuration"><a class="header" href="#shell-configuration">Shell Configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>history_file</code></td><td><code>Option&lt;PathBuf&gt;</code></td><td><code>~/.neumann_history</code></td><td>Path for persistent history</td></tr>
<tr><td><code>history_size</code></td><td><code>usize</code></td><td><code>1000</code></td><td>Maximum history entries</td></tr>
<tr><td><code>prompt</code></td><td><code>String</code></td><td><code>"&gt; "</code></td><td>Input prompt string</td></tr>
</tbody></table>
</div>
<p>The default history file location is determined by reading the <code>HOME</code>
environment variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dirs_home() -&gt; Option&lt;PathBuf&gt; {
    std::env::var_os("HOME").map(PathBuf::from)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="command-result-types"><a class="header" href="#command-result-types">Command Result Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Description</th><th>REPL Behavior</th></tr></thead><tbody>
<tr><td><code>Output(String)</code></td><td>Query executed successfully with output</td><td>Print to stdout, continue loop</td></tr>
<tr><td><code>Exit</code></td><td>Shell should exit</td><td>Print “Goodbye!”, break loop</td></tr>
<tr><td><code>Help(String)</code></td><td>Help text to display</td><td>Print to stdout, continue loop</td></tr>
<tr><td><code>Empty</code></td><td>Empty input (no-op)</td><td>Continue loop silently</td></tr>
<tr><td><code>Error(String)</code></td><td>Error occurred</td><td>Print to stderr, continue loop</td></tr>
</tbody></table>
</div>
<h2 id="repl-loop-implementation"><a class="header" href="#repl-loop-implementation">REPL Loop Implementation</a></h2>
<p>The shell implements a Read-Eval-Print Loop (REPL) using the <code>rustyline</code> crate
for readline functionality. Here is the complete control flow:</p>
<pre class="mermaid">flowchart TD
    A[Start run] --&gt; B[Create Editor]
    B --&gt; C[Load history file]
    C --&gt; D[Set max history size]
    D --&gt; E[Set confirmation handler if checkpoint available]
    E --&gt; F[Print version banner]
    F --&gt; G[readline with prompt]
    G --&gt; H{Input result?}
    H --&gt;|Ok line| I{Line empty?}
    I --&gt;|No| J[Add to history]
    I --&gt;|Yes| G
    J --&gt; K[execute command]
    K --&gt; L[process_result]
    L --&gt; M{LoopAction?}
    M --&gt;|Continue| G
    M --&gt;|Exit| N[Save history]
    H --&gt;|Ctrl+C| O[Print ^C]
    O --&gt; G
    H --&gt;|Ctrl+D EOF| P[Print Goodbye!]
    P --&gt; N
    H --&gt;|Error| Q[Print error]
    Q --&gt; N
    N --&gt; R[End]
</pre>
<h3 id="initialization-sequence"><a class="header" href="#initialization-sequence">Initialization Sequence</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn run(&amp;mut self) -&gt; Result&lt;(), ShellError&gt; {
    // 1. Create rustyline editor
    let editor: Editor&lt;(), DefaultHistory&gt; =
        DefaultEditor::new().map_err(|e| ShellError::Init(e.to_string()))?;
    let editor = Arc::new(Mutex::new(editor));

    // 2. Load existing history
    {
        let mut ed = editor.lock();
        if let Some(ref path) = self.config.history_file {
            let _ = ed.load_history(path);
        }
        ed.history_mut()
            .set_max_len(self.config.history_size)
            .map_err(|e| ShellError::Init(e.to_string()))?;
    }

    // 3. Set up confirmation handler for destructive operations
    {
        let router = self.router.read();
        if router.has_checkpoint() {
            let handler = Arc::new(ShellConfirmationHandler::new(Arc::clone(&amp;editor)));
            drop(router);
            let router = self.router.write();
            if let Err(e) = router.set_confirmation_handler(handler) {
                eprintln!("Warning: Failed to set confirmation handler: {e}");
            }
        }
    }

    println!("Neumann Database Shell v{}", Self::version());
    println!("Type 'help' for available commands.\n");

    // 4. Main REPL loop
    loop {
        let readline_result = {
            let mut ed = editor.lock();
            ed.readline(&amp;self.config.prompt)
        };

        match readline_result {
            Ok(line) =&gt; {
                if !line.trim().is_empty() {
                    let mut ed = editor.lock();
                    let _ = ed.add_history_entry(line.trim());
                }
                if Self::process_result(&amp;self.execute(&amp;line)) == LoopAction::Exit {
                    break;
                }
            },
            Err(ReadlineError::Interrupted) =&gt; println!("^C"),
            Err(ReadlineError::Eof) =&gt; {
                println!("Goodbye!");
                break;
            },
            Err(err) =&gt; {
                eprintln!("Error: {err}");
                break;
            },
        }
    }

    // 5. Save history on exit
    if let Some(ref path) = self.config.history_file {
        let mut ed = editor.lock();
        let _ = ed.save_history(path);
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="command-execution-flow"><a class="header" href="#command-execution-flow">Command Execution Flow</a></h3>
<pre class="mermaid">flowchart TD
    A[execute input] --&gt; B{Trim empty?}
    B --&gt;|Yes| C[Return Empty]
    B --&gt;|No| D[Convert to lowercase]
    D --&gt; E{Built-in command?}
    E --&gt;|exit/quit/\q| F[Return Exit]
    E --&gt;|help/\h/\?| G[Return Help]
    E --&gt;|tables/\dt| H[list_tables]
    E --&gt;|clear/\c| I[Return ANSI clear]
    E --&gt;|wal status| J[handle_wal_status]
    E --&gt;|wal truncate| K[handle_wal_truncate]
    E --&gt;|No match| L{Prefix match?}
    L --&gt;|save compressed| M[handle_save_compressed]
    L --&gt;|save| N[handle_save]
    L --&gt;|load| O[handle_load]
    L --&gt;|vault init| P[handle_vault_init]
    L --&gt;|vault identity| Q[handle_vault_identity]
    L --&gt;|cache init| R[handle_cache_init]
    L --&gt;|cluster connect| S[handle_cluster_connect]
    L --&gt;|cluster disconnect| T[handle_cluster_disconnect]
    L --&gt;|None| U[router.execute_parsed]
    U --&gt; V{Result?}
    V --&gt;|Ok| W{is_write_command?}
    W --&gt;|Yes| X{WAL active?}
    X --&gt;|Yes| Y[wal.append]
    Y --&gt; Z[Return Output]
    X --&gt;|No| Z
    W --&gt;|No| Z
    V --&gt;|Err| AA[Return Error]
</pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="shell-creation"><a class="header" href="#shell-creation">Shell Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neumann_shell::{Shell, ShellConfig};

// Default configuration
let shell = Shell::new();

// Custom configuration
let config = ShellConfig {
    history_file: Some("/custom/path/.neumann_history".into()),
    history_size: 500,
    prompt: "neumann&gt; ".to_string(),
};
let shell = Shell::with_config(config);
<span class="boring">}</span></code></pre></pre>
<h3 id="running-the-repl"><a class="header" href="#running-the-repl">Running the REPL</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>shell.run()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="programmatic-execution"><a class="header" href="#programmatic-execution">Programmatic Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neumann_shell::CommandResult;

match shell.execute("SELECT * FROM users") {
    CommandResult::Output(text) =&gt; println!("{}", text),
    CommandResult::Error(err) =&gt; eprintln!("Error: {}", err),
    CommandResult::Exit =&gt; println!("Goodbye!"),
    CommandResult::Help(text) =&gt; println!("{}", text),
    CommandResult::Empty =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<h3 id="direct-router-access"><a class="header" href="#direct-router-access">Direct Router Access</a></h3>
<p>The shell provides thread-safe access to the underlying Query Router:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Read-only access
let router_guard = shell.router();
let tables = router_guard.list_tables();

// Mutable access
let mut router_guard = shell.router_mut();
router_guard.init_vault(&amp;key)?;

// Get Arc clone for shared ownership
let router_arc = shell.router_arc();
<span class="boring">}</span></code></pre></pre>
<h2 id="built-in-commands"><a class="header" href="#built-in-commands">Built-in Commands</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Aliases</th><th>Description</th></tr></thead><tbody>
<tr><td><code>help</code></td><td><code>\h</code>, <code>\?</code></td><td>Show help message</td></tr>
<tr><td><code>exit</code></td><td><code>quit</code>, <code>\q</code></td><td>Exit the shell</td></tr>
<tr><td><code>tables</code></td><td><code>\dt</code></td><td>List all tables</td></tr>
<tr><td><code>clear</code></td><td><code>\c</code></td><td>Clear the screen (ANSI escape: <code>\x1B[2J\x1B[H</code>)</td></tr>
<tr><td><code>save 'path'</code></td><td>—</td><td>Save database snapshot to file</td></tr>
<tr><td><code>save compressed 'path'</code></td><td>—</td><td>Save compressed snapshot (int8 quantization)</td></tr>
<tr><td><code>load 'path'</code></td><td>—</td><td>Load database snapshot from file (auto-detects format)</td></tr>
<tr><td><code>wal status</code></td><td>—</td><td>Show write-ahead log status</td></tr>
<tr><td><code>wal truncate</code></td><td>—</td><td>Clear the write-ahead log</td></tr>
<tr><td><code>vault init</code></td><td>—</td><td>Initialize vault from <code>NEUMANN_VAULT_KEY</code> environment variable</td></tr>
<tr><td><code>vault identity 'name'</code></td><td>—</td><td>Set current identity for vault access control</td></tr>
<tr><td><code>cache init</code></td><td>—</td><td>Initialize semantic cache with default configuration</td></tr>
<tr><td><code>cluster connect</code></td><td>—</td><td>Connect to cluster with specified node addresses</td></tr>
<tr><td><code>cluster disconnect</code></td><td>—</td><td>Disconnect from cluster</td></tr>
</tbody></table>
</div>
<h3 id="command-parsing-details"><a class="header" href="#command-parsing-details">Command Parsing Details</a></h3>
<p>All built-in commands are case-insensitive. The shell first converts input to
lowercase before matching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lower = trimmed.to_lowercase();
match lower.as_str() {
    "exit" | "quit" | "\\q" =&gt; return CommandResult::Exit,
    "help" | "\\h" | "\\?" =&gt; return CommandResult::Help(Self::help_text()),
    "tables" | "\\dt" =&gt; return self.list_tables(),
    "clear" | "\\c" =&gt; return CommandResult::Output("\x1B[2J\x1B[H".to_string()),
    "wal status" =&gt; return self.handle_wal_status(),
    "wal truncate" =&gt; return self.handle_wal_truncate(),
    _ =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<h3 id="path-extraction"><a class="header" href="#path-extraction">Path Extraction</a></h3>
<p>The <code>extract_path</code> function handles both quoted and unquoted paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn extract_path(input: &amp;str, command: &amp;str) -&gt; Option&lt;String&gt; {
    let rest = input[command.len()..].trim();
    if rest.is_empty() {
        return None;
    }

    // Handle quoted path (single or double quotes)
    if (rest.starts_with('\'') &amp;&amp; rest.ends_with('\''))
        || (rest.starts_with('"') &amp;&amp; rest.ends_with('"'))
    {
        if rest.len() &gt; 2 {
            return Some(rest[1..rest.len() - 1].to_string());
        }
        return None;
    }

    // Handle unquoted path
    Some(rest.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Examples:</strong></p>
<ul>
<li><code>save 'foo.bin'</code> -&gt; <code>Some("foo.bin")</code></li>
<li><code>LOAD "bar.bin"</code> -&gt; <code>Some("bar.bin")</code></li>
<li><code>save /path/to/file.bin</code> -&gt; <code>Some("/path/to/file.bin")</code></li>
<li><code>save ''</code> -&gt; <code>None</code></li>
<li><code>save</code> -&gt; <code>None</code></li>
</ul>
<h2 id="query-support"><a class="header" href="#query-support">Query Support</a></h2>
<p>The shell supports all query types from the Query Router:</p>
<h3 id="relational-sql"><a class="header" href="#relational-sql">Relational (SQL)</a></h3>
<pre><code class="language-sql">CREATE TABLE users (id INT, name TEXT, email TEXT)
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com')
SELECT * FROM users WHERE id = 1
UPDATE users SET name = 'Bob' WHERE id = 1
DELETE FROM users WHERE id = 1
DROP TABLE users
</code></pre>
<h3 id="graph"><a class="header" href="#graph">Graph</a></h3>
<pre><code class="language-sql">NODE CREATE person {name: 'Alice', age: 30}
NODE LIST [label]
NODE GET id
EDGE CREATE node1 -&gt; node2 : label [{props}]
EDGE LIST [type]
EDGE GET id
NEIGHBORS node_id OUTGOING|INCOMING|BOTH [: label]
PATH node1 -&gt; node2 [LIMIT n]
</code></pre>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<pre><code class="language-sql">EMBED STORE 'key' [vector values]
EMBED GET 'key'
EMBED DELETE 'key'
SIMILAR 'key' [COSINE|EUCLIDEAN|DOT_PRODUCT] LIMIT n
</code></pre>
<h3 id="unified-cross-engine"><a class="header" href="#unified-cross-engine">Unified (Cross-Engine)</a></h3>
<pre><code class="language-sql">FIND NODE [label] [WHERE condition] [LIMIT n]
FIND EDGE [type] [WHERE condition] [LIMIT n]
</code></pre>
<h3 id="blob-storage"><a class="header" href="#blob-storage">Blob Storage</a></h3>
<pre><code class="language-sql">BLOB PUT 'path' [CHUNK size] [TAGS 'a','b'] [FOR 'entity']
BLOB GET 'id' TO 'path'
BLOB DELETE 'id'
BLOB INFO 'id'
BLOB LINK 'id' TO 'entity'
BLOB UNLINK 'id' FROM 'entity'
BLOBS
BLOBS FOR 'entity'
BLOBS BY TAG 'tag'
</code></pre>
<h3 id="vault-secrets"><a class="header" href="#vault-secrets">Vault (Secrets)</a></h3>
<pre><code class="language-sql">VAULT INIT
VAULT IDENTITY 'node:name'
VAULT SET 'key' 'value'
VAULT GET 'key'
VAULT DELETE 'key'
VAULT LIST 'pattern'
VAULT ROTATE 'key' 'new'
VAULT GRANT 'entity' ON 'key'
VAULT REVOKE 'entity' ON 'key'
</code></pre>
<h3 id="cache-llm-responses"><a class="header" href="#cache-llm-responses">Cache (LLM Responses)</a></h3>
<pre><code class="language-sql">CACHE INIT
CACHE STATS
CACHE CLEAR
CACHE EVICT [n]
CACHE GET 'key'
CACHE PUT 'key' 'value'
</code></pre>
<h3 id="checkpoints-rollback"><a class="header" href="#checkpoints-rollback">Checkpoints (Rollback)</a></h3>
<pre><code class="language-sql">CHECKPOINT
CHECKPOINT 'name'
CHECKPOINTS
CHECKPOINTS LIMIT n
ROLLBACK TO 'name-or-id'
</code></pre>
<h2 id="write-ahead-log-wal"><a class="header" href="#write-ahead-log-wal">Write-Ahead Log (WAL)</a></h2>
<p>The shell includes a write-ahead log for crash recovery. When enabled, all write
commands are logged to a file that can be replayed after loading a snapshot.</p>
<h3 id="wal-data-structure"><a class="header" href="#wal-data-structure">WAL Data Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Wal {
    file: File,    // Open file handle for appending
    path: PathBuf, // Path to WAL file (derived from snapshot: data.bin -&gt; data.log)
}

impl Wal {
    fn open_append(path: &amp;Path) -&gt; std::io::Result&lt;Self&gt;;
    fn append(&amp;mut self, cmd: &amp;str) -&gt; std::io::Result&lt;()&gt;;  // Writes line + flush
    fn truncate(&amp;mut self) -&gt; std::io::Result&lt;()&gt;;           // Recreates empty file
    fn path(&amp;self) -&gt; &amp;Path;
    fn size(&amp;self) -&gt; std::io::Result&lt;u64&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="wal-file-format"><a class="header" href="#wal-file-format">WAL File Format</a></h3>
<p>The WAL is a simple text file with one command per line. Each command is written
verbatim followed by a newline and an immediate flush:</p>
<pre><code class="language-sql">INSERT INTO users VALUES (1, 'Alice')
NODE CREATE person {name: 'Bob'}
EMBED STORE 'doc1' [0.1, 0.2, 0.3]
</code></pre>
<p><strong>Format details:</strong></p>
<ul>
<li>Line-delimited plain text</li>
<li>UTF-8 encoded</li>
<li>Each line is the exact command string</li>
<li>Flushed immediately after each write for durability</li>
<li>Empty lines are skipped during replay</li>
</ul>
<h3 id="wal-lifecycle"><a class="header" href="#wal-lifecycle">WAL Lifecycle</a></h3>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; Inactive: Shell created
    Inactive --&gt; Active: LOAD 'snapshot.bin'
    Active --&gt; Active: Write command logged
    Active --&gt; Active: Read command (no log)
    Active --&gt; Empty: SAVE 'snapshot.bin'
    Empty --&gt; Active: Write command
    Active --&gt; Empty: WAL TRUNCATE
    Active --&gt; [*]: Shell exits
</pre>
<h3 id="write-command-detection"><a class="header" href="#write-command-detection">Write Command Detection</a></h3>
<p>The <code>is_write_command</code> function determines which commands should be logged to
the WAL:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_write_command(cmd: &amp;str) -&gt; bool {
    let upper = cmd.to_uppercase();
    let first_word = upper.split_whitespace().next().unwrap_or("");

    match first_word {
        "INSERT" | "UPDATE" | "DELETE" | "CREATE" | "DROP" =&gt; true,
        "NODE" =&gt; !upper.contains("NODE GET"),
        "EDGE" =&gt; !upper.contains("EDGE GET"),
        "EMBED" =&gt; upper.contains("EMBED STORE") || upper.contains("EMBED DELETE"),
        "VAULT" =&gt; {
            upper.contains("VAULT SET")
                || upper.contains("VAULT DELETE")
                || upper.contains("VAULT ROTATE")
                || upper.contains("VAULT GRANT")
                || upper.contains("VAULT REVOKE")
        },
        "CACHE" =&gt; upper.contains("CACHE CLEAR"),
        "BLOB" =&gt; {
            upper.contains("BLOB PUT")
                || upper.contains("BLOB DELETE")
                || upper.contains("BLOB LINK")
                || upper.contains("BLOB UNLINK")
                || upper.contains("BLOB TAG")
                || upper.contains("BLOB UNTAG")
                || upper.contains("BLOB GC")
                || upper.contains("BLOB REPAIR")
                || upper.contains("BLOB META SET")
        },
        _ =&gt; false,
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Write commands logged to WAL:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Commands</th></tr></thead><tbody>
<tr><td>Relational</td><td><code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE</code>, <code>DROP</code></td></tr>
<tr><td>Graph</td><td><code>NODE CREATE</code>, <code>NODE DELETE</code>, <code>EDGE CREATE</code>, <code>EDGE DELETE</code></td></tr>
<tr><td>Vector</td><td><code>EMBED STORE</code>, <code>EMBED DELETE</code></td></tr>
<tr><td>Vault</td><td><code>VAULT SET</code>, <code>VAULT DELETE</code>, <code>VAULT ROTATE</code>, <code>VAULT GRANT</code>, <code>VAULT REVOKE</code></td></tr>
<tr><td>Cache</td><td><code>CACHE CLEAR</code></td></tr>
<tr><td>Blob</td><td><code>BLOB PUT</code>, <code>BLOB DELETE</code>, <code>BLOB LINK</code>, <code>BLOB UNLINK</code>, <code>BLOB TAG</code>, <code>BLOB UNTAG</code>, <code>BLOB GC</code>, <code>BLOB REPAIR</code>, <code>BLOB META SET</code></td></tr>
</tbody></table>
</div>
<h3 id="wal-replay-algorithm"><a class="header" href="#wal-replay-algorithm">WAL Replay Algorithm</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn replay_wal(&amp;self, wal_path: &amp;Path) -&gt; Result&lt;usize, String&gt; {
    let file = File::open(wal_path).map_err(|e| format!("Failed to open WAL: {e}"))?;
    let reader = BufReader::new(file);

    let mut count = 0;
    for (line_num, line) in reader.lines().enumerate() {
        let cmd = line.map_err(|e| format!("Failed to read WAL line {}: {e}", line_num + 1))?;
        let cmd = cmd.trim();

        if cmd.is_empty() {
            continue;  // Skip empty lines
        }

        let result = self.router.read().execute_parsed(cmd);
        if let Err(e) = result {
            return Err(format!("WAL replay failed at line {}: {e}", line_num + 1));
        }
        count += 1;
    }

    Ok(count)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-session"><a class="header" href="#example-session">Example Session</a></h3>
<pre><code class="language-sql">&gt; LOAD 'data.bin'
Loaded snapshot from: data.bin

&gt; INSERT INTO users VALUES (1, 'Alice')
1 row affected

&gt; -- If the shell crashes here, the INSERT is saved in data.log

&gt; -- On next load, the WAL is automatically replayed:
&gt; LOAD 'data.bin'
Loaded snapshot from: data.bin
Replayed 1 commands from WAL

&gt; WAL STATUS
WAL enabled
  Path: data.log
  Size: 42 bytes

&gt; SAVE 'data.bin'
Saved snapshot to: data.bin

&gt; WAL STATUS
WAL enabled
  Path: data.log
  Size: 0 bytes
</code></pre>
<p><strong>WAL Behavior Summary:</strong></p>
<ul>
<li>WAL is activated after <code>LOAD</code> (stored as <code>&lt;snapshot&gt;.log</code>)</li>
<li>All write commands (INSERT, UPDATE, DELETE, NODE CREATE, etc.) are logged</li>
<li>On subsequent <code>LOAD</code>, the snapshot is loaded first, then WAL is replayed</li>
<li><code>SAVE</code> truncates the WAL (snapshot now contains all data)</li>
<li><code>WAL TRUNCATE</code> manually clears the log without saving</li>
</ul>
<h2 id="persistence-commands"><a class="header" href="#persistence-commands">Persistence Commands</a></h2>
<h3 id="save-and-load"><a class="header" href="#save-and-load">Save and Load</a></h3>
<pre><code class="language-sql">&gt; CREATE TABLE users (id INT, name TEXT)
OK

&gt; INSERT INTO users VALUES (1, 'Alice')
1 row affected

&gt; SAVE 'backup.bin'
Saved snapshot to: backup.bin

&gt; SAVE COMPRESSED 'backup_compressed.bin'
Saved compressed snapshot to: backup_compressed.bin

&gt; LOAD 'backup.bin'
Loaded snapshot from: backup.bin
</code></pre>
<h3 id="auto-detection-of-embedding-dimension"><a class="header" href="#auto-detection-of-embedding-dimension">Auto-Detection of Embedding Dimension</a></h3>
<p>For compressed snapshots, the shell auto-detects the embedding dimension by
sampling stored vectors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn detect_embedding_dimension(store: &amp;TensorStore) -&gt; usize {
    // Sample vectors to find dimension
    let keys = store.scan("");
    for key in keys.iter().take(100) {
        if let Ok(tensor) = store.get(key) {
            for field in tensor.keys() {
                match tensor.get(field) {
                    Some(TensorValue::Vector(v)) =&gt; return v.len(),
                    Some(TensorValue::Sparse(s)) =&gt; return s.dimension(),
                    _ =&gt; {},
                }
            }
        }
    }

    // Default to standard BERT dimension if no vectors found
    tensor_compress::CompressionDefaults::STANDARD  // 768
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Compression Options:</strong></p>
<ul>
<li><code>SAVE</code>: Uncompressed bincode format</li>
<li><code>SAVE COMPRESSED</code>: Uses int8 quantization (4x smaller), delta encoding, and
RLE</li>
<li><code>LOAD</code>: Auto-detects format (works with both compressed and uncompressed)</li>
</ul>
<h2 id="output-formatting"><a class="header" href="#output-formatting">Output Formatting</a></h2>
<p>The shell converts <code>QueryResult</code> variants into human-readable strings through
the <code>format_result</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn format_result(result: &amp;QueryResult) -&gt; String {
    match result {
        QueryResult::Empty =&gt; "OK".to_string(),
        QueryResult::Value(s) =&gt; s.clone(),
        QueryResult::Count(n) =&gt; format_count(*n),
        QueryResult::Ids(ids) =&gt; format_ids(ids),
        QueryResult::Rows(rows) =&gt; format_rows(rows),
        QueryResult::Nodes(nodes) =&gt; format_nodes(nodes),
        QueryResult::Edges(edges) =&gt; format_edges(edges),
        QueryResult::Path(path) =&gt; format_path(path),
        QueryResult::Similar(results) =&gt; format_similar(results),
        QueryResult::Unified(unified) =&gt; unified.description.clone(),
        QueryResult::TableList(tables) =&gt; format_table_list(tables),
        QueryResult::Blob(data) =&gt; format_blob(data),
        QueryResult::ArtifactInfo(info) =&gt; format_artifact_info(info),
        QueryResult::ArtifactList(ids) =&gt; format_artifact_list(ids),
        QueryResult::BlobStats(stats) =&gt; format_blob_stats(stats),
        QueryResult::CheckpointList(checkpoints) =&gt; format_checkpoint_list(checkpoints),
        QueryResult::Chain(chain) =&gt; format_chain_result(chain),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="table-formatting-algorithm-ascii-tables"><a class="header" href="#table-formatting-algorithm-ascii-tables">Table Formatting Algorithm (ASCII Tables)</a></h3>
<p>The <code>format_rows</code> function implements dynamic column width calculation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn format_rows(rows: &amp;[Row]) -&gt; String {
    if rows.is_empty() {
        return "(0 rows)".to_string();
    }

    // Get column names from first row
    let columns: Vec&lt;&amp;String&gt; = rows[0].values.iter().map(|(k, _)| k).collect();
    if columns.is_empty() {
        return "(0 rows)".to_string();
    }

    // Convert rows to string values
    let string_rows: Vec&lt;Vec&lt;String&gt;&gt; = rows
        .iter()
        .map(|row| {
            columns
                .iter()
                .map(|col| row.get(col).map(|v| format!("{v:?}")).unwrap_or_default())
                .collect()
        })
        .collect();

    // Calculate column widths (max of header and all cell widths)
    let mut widths: Vec&lt;usize&gt; = columns.iter().map(|c| c.len()).collect();
    for row in &amp;string_rows {
        for (i, cell) in row.iter().enumerate() {
            if i &lt; widths.len() {
                widths[i] = widths[i].max(cell.len());
            }
        }
    }

    // Build output with header, separator, and data rows
    let mut output = String::new();

    // Header
    let header: Vec&lt;String&gt; = columns
        .iter()
        .zip(&amp;widths)
        .map(|(col, &amp;w)| format!("{col:w$}"))
        .collect();
    output.push_str(&amp;header.join(" | "));
    output.push('\n');

    // Separator
    let sep: Vec&lt;String&gt; = widths.iter().map(|&amp;w| "-".repeat(w)).collect();
    output.push_str(&amp;sep.join("-+-"));
    output.push('\n');

    // Data rows
    for row in &amp;string_rows {
        let formatted: Vec&lt;String&gt; = row
            .iter()
            .zip(&amp;widths)
            .map(|(cell, &amp;w)| format!("{cell:w$}"))
            .collect();
        output.push_str(&amp;formatted.join(" | "));
        output.push('\n');
    }

    let _ = write!(output, "({} rows)", rows.len());
    output
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Output example:</strong></p>
<pre><code class="language-text">name  | age | email
------+-----+------------------
Alice | 30  | alice@example.com
Bob   | 25  | bob@example.com
(2 rows)
</code></pre>
<h3 id="node-formatting"><a class="header" href="#node-formatting">Node Formatting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn format_nodes(nodes: &amp;[NodeResult]) -&gt; String {
    if nodes.is_empty() {
        "(0 nodes)".to_string()
    } else {
        let lines: Vec&lt;String&gt; = nodes
            .iter()
            .map(|n| {
                let props: Vec&lt;String&gt; = n
                    .properties
                    .iter()
                    .map(|(k, v)| format!("{k}: {v}"))
                    .collect();
                if props.is_empty() {
                    format!("  [{}] {} {{}}", n.id, n.label)
                } else {
                    format!("  [{}] {} {{{}}}", n.id, n.label, props.join(", "))
                }
            })
            .collect();
        format!("Nodes:\n{}\n({} nodes)", lines.join("\n"), nodes.len())
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Output example:</strong></p>
<pre><code class="language-text">Nodes:
  [1] person {name: Alice, age: 30}
  [2] person {name: Bob, age: 25}
(2 nodes)
</code></pre>
<h3 id="edge-formatting"><a class="header" href="#edge-formatting">Edge Formatting</a></h3>
<pre><code class="language-text">Edges:
  [1] 1 -&gt; 2 : knows
(1 edges)
</code></pre>
<h3 id="path-formatting"><a class="header" href="#path-formatting">Path Formatting</a></h3>
<pre><code class="language-text">Path: 1 -&gt; 3 -&gt; 5 -&gt; 7
</code></pre>
<h3 id="similar-embeddings-formatting"><a class="header" href="#similar-embeddings-formatting">Similar Embeddings Formatting</a></h3>
<pre><code class="language-text">Similar:
  1. doc1 (similarity: 0.9800)
  2. doc2 (similarity: 0.9500)
</code></pre>
<h3 id="blob-formatting"><a class="header" href="#blob-formatting">Blob Formatting</a></h3>
<p>Binary data handling with size threshold:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn format_blob(data: &amp;[u8]) -&gt; String {
    let size = data.len();
    if size &lt;= 256 {
        // Try to display as UTF-8 if valid
        if let Ok(s) = std::str::from_utf8(data) {
            if s.chars().all(|c| !c.is_control() || c == '\n' || c == '\t') {
                return s.to_string();
            }
        }
    }
    // Show summary for binary/large data
    format!("&lt;binary data: {size} bytes&gt;")
}
<span class="boring">}</span></code></pre></pre>
<h3 id="timestamp-formatting"><a class="header" href="#timestamp-formatting">Timestamp Formatting</a></h3>
<p>Relative time formatting for better readability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn format_timestamp(unix_secs: u64) -&gt; String {
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_secs())
        .unwrap_or(0);

    if unix_secs == 0 {
        return "unknown".to_string();
    }

    let diff = now.saturating_sub(unix_secs);

    if diff &lt; 60 {
        format!("{diff}s ago")
    } else if diff &lt; 3600 {
        let mins = diff / 60;
        format!("{mins}m ago")
    } else if diff &lt; 86400 {
        let hours = diff / 3600;
        format!("{hours}h ago")
    } else {
        let days = diff / 86400;
        format!("{days}d ago")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="destructive-operation-confirmation"><a class="header" href="#destructive-operation-confirmation">Destructive Operation Confirmation</a></h2>
<p>The shell integrates with the checkpoint system to provide interactive
confirmation for destructive operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ShellConfirmationHandler {
    editor: Arc&lt;Mutex&lt;Editor&lt;(), DefaultHistory&gt;&gt;&gt;,
}

impl ConfirmationHandler for ShellConfirmationHandler {
    fn confirm(&amp;self, op: &amp;DestructiveOp, preview: &amp;OperationPreview) -&gt; bool {
        let prompt = format_confirmation_prompt(op, preview);

        // Print the warning with sample data
        println!("\n{prompt}");

        // Ask for confirmation using readline
        let mut editor = self.editor.lock();
        editor
            .readline("Type 'yes' to proceed: ")
            .is_ok_and(|input| input.trim().eq_ignore_ascii_case("yes"))
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Supported destructive operations:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Warning Message</th></tr></thead><tbody>
<tr><td><code>Delete</code></td><td><code>WARNING: About to delete N row(s) from table 'name'</code></td></tr>
<tr><td><code>DropTable</code></td><td><code>WARNING: About to drop table 'name' with N row(s)</code></td></tr>
<tr><td><code>DropIndex</code></td><td><code>WARNING: About to drop index on 'column' in table 'name'</code></td></tr>
<tr><td><code>NodeDelete</code></td><td><code>WARNING: About to delete node N and M connected edge(s)</code></td></tr>
<tr><td><code>EmbedDelete</code></td><td><code>WARNING: About to delete embedding 'key'</code></td></tr>
<tr><td><code>VaultDelete</code></td><td><code>WARNING: About to delete vault secret 'key'</code></td></tr>
<tr><td><code>BlobDelete</code></td><td><code>WARNING: About to delete blob 'id' (size)</code></td></tr>
<tr><td><code>CacheClear</code></td><td><code>WARNING: About to clear cache with N entries</code></td></tr>
</tbody></table>
</div>
<h2 id="keyboard-shortcuts"><a class="header" href="#keyboard-shortcuts">Keyboard Shortcuts</a></h2>
<p>Provided by rustyline:</p>
<div class="table-wrapper"><table><thead><tr><th>Shortcut</th><th>Action</th></tr></thead><tbody>
<tr><td>Up/Down</td><td>Navigate history</td></tr>
<tr><td>Ctrl+C</td><td>Cancel current input (prints <code>^C</code>, continues loop)</td></tr>
<tr><td>Ctrl+D</td><td>Exit shell (EOF)</td></tr>
<tr><td>Ctrl+L</td><td>Clear screen</td></tr>
<tr><td>Ctrl+A</td><td>Move to start of line</td></tr>
<tr><td>Ctrl+E</td><td>Move to end of line</td></tr>
<tr><td>Ctrl+W</td><td>Delete word backward</td></tr>
<tr><td>Ctrl+U</td><td>Delete to start of line</td></tr>
</tbody></table>
</div>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Error Type</th><th>Example</th><th>Output Stream</th></tr></thead><tbody>
<tr><td>Parse error</td><td><code>Error: unexpected token 'FORM' at position 12</code></td><td>stderr</td></tr>
<tr><td>Table not found</td><td><code>Error: table 'users' not found</code></td><td>stderr</td></tr>
<tr><td>Invalid query</td><td><code>Error: unsupported operation</code></td><td>stderr</td></tr>
<tr><td>WAL write failure</td><td><code>Command succeeded but WAL write failed: ...</code></td><td>Returned as Error</td></tr>
<tr><td>WAL replay failure</td><td><code>WAL replay failed at line N: ...</code></td><td>Returned as Error</td></tr>
</tbody></table>
</div>
<p>Errors are printed to stderr and do not exit the shell. The <code>process_result</code>
function routes output appropriately:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn process_result(result: &amp;CommandResult) -&gt; LoopAction {
    match result {
        CommandResult::Output(text) | CommandResult::Help(text) =&gt; {
            println!("{text}");
            LoopAction::Continue
        },
        CommandResult::Error(text) =&gt; {
            eprintln!("{text}");
            LoopAction::Continue
        },
        CommandResult::Exit =&gt; {
            println!("Goodbye!");
            LoopAction::Exit
        },
        CommandResult::Empty =&gt; LoopAction::Continue,
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cluster-connectivity"><a class="header" href="#cluster-connectivity">Cluster Connectivity</a></h2>
<h3 id="connect-command-syntax"><a class="header" href="#connect-command-syntax">Connect Command Syntax</a></h3>
<pre><code class="language-text">CLUSTER CONNECT 'node_id@bind_addr' ['peer_id@peer_addr', ...]
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-sql">&gt; CLUSTER CONNECT 'node1@127.0.0.1:8001' 'node2@127.0.0.1:8002'
Cluster initialized: node1 @ 127.0.0.1:8001 with 1 peer(s)
</code></pre>
<h3 id="address-parsing"><a class="header" href="#address-parsing">Address Parsing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn parse_node_address(s: &amp;str) -&gt; Result&lt;(String, SocketAddr), String&gt; {
    let parts: Vec&lt;&amp;str&gt; = s.splitn(2, '@').collect();
    if parts.len() != 2 {
        return Err("Expected format 'node_id@host:port'".to_string());
    }

    let node_id = parts[0].to_string();
    let addr: SocketAddr = parts[1]
        .parse()
        .map_err(|e| format!("Invalid address '{}': {}", parts[1], e))?;

    Ok((node_id, addr))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cluster-query-execution"><a class="header" href="#cluster-query-execution">Cluster Query Execution</a></h3>
<p>The shell wraps the router for distributed query execution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RouterExecutor(Arc&lt;RwLock&lt;QueryRouter&gt;&gt;);

impl QueryExecutor for RouterExecutor {
    fn execute(&amp;self, query: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
        let router = self.0.read();
        router.execute_for_cluster(query)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time</th></tr></thead><tbody>
<tr><td>Empty input</td><td>2.3 ns</td></tr>
<tr><td>Help command</td><td>43 ns</td></tr>
<tr><td>SELECT (100 rows)</td><td>17.8 us</td></tr>
<tr><td>Format 1000 rows</td><td>267 us</td></tr>
</tbody></table>
</div>
<p>The shell adds negligible overhead to query execution.</p>
<h2 id="edge-cases-and-gotchas"><a class="header" href="#edge-cases-and-gotchas">Edge Cases and Gotchas</a></h2>
<ol>
<li>
<p><strong>Empty quoted paths</strong>: <code>save ''</code> returns an error, not an empty path.</p>
</li>
<li>
<p><strong>WAL not active by default</strong>: The WAL only becomes active after <code>LOAD</code>. New
shells have no WAL.</p>
</li>
<li>
<p><strong>Case sensitivity</strong>: Built-in commands are case-insensitive, but query
strings preserve case for data.</p>
</li>
<li>
<p><strong>History persistence</strong>: History is only saved when the shell exits normally
(not on crash).</p>
</li>
<li>
<p><strong>ANSI codes</strong>: The <code>clear</code> command outputs ANSI escape sequences
(<code>\x1B[2J\x1B[H</code>), which may not work on all terminals.</p>
</li>
<li>
<p><strong>Confirmation handler</strong>: Only active if checkpoint module is available when
shell starts.</p>
</li>
<li>
<p><strong>WAL replay stops on first error</strong>: If any command fails during replay, the
entire replay stops.</p>
</li>
<li>
<p><strong>Missing columns</strong>: When formatting rows with inconsistent columns, missing
values show as empty strings.</p>
</li>
<li>
<p><strong>Binary blob display</strong>: Blobs over 256 bytes or with control characters show
as <code>&lt;binary data: N bytes&gt;</code>.</p>
</li>
<li>
<p><strong>Timestamp overflow</strong>: Very old timestamps (before 1970) or 0 display as
“unknown”.</p>
</li>
</ol>
<h2 id="user-experience-tips"><a class="header" href="#user-experience-tips">User Experience Tips</a></h2>
<ol>
<li>
<p><strong>Use compressed snapshots for large datasets</strong>: <code>SAVE COMPRESSED</code> reduces
file size by ~4x with minimal precision loss.</p>
</li>
<li>
<p><strong>Check WAL status before critical operations</strong>: Run <code>WAL STATUS</code> to verify
recovery capability.</p>
</li>
<li>
<p><strong>Use tab completion</strong>: Rustyline provides filename completion in some
contexts.</p>
</li>
<li>
<p><strong>Ctrl+C is safe</strong>: It only cancels the current line, not the entire session.</p>
</li>
<li>
<p><strong>History survives sessions</strong>: Previous commands are available across shell
restarts.</p>
</li>
<li>
<p><strong>For scripts, use programmatic API</strong>: <code>shell.execute()</code> returns structured
results for automation.</p>
</li>
<li>
<p><strong>Cluster connect before distributed operations</strong>: Ensure <code>CLUSTER CONNECT</code>
succeeds before running distributed transactions.</p>
</li>
</ol>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Crate</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>query_router</code></td><td>Query execution</td></tr>
<tr><td><code>relational_engine</code></td><td>Row type for formatting</td></tr>
<tr><td><code>tensor_store</code></td><td>Snapshot persistence (save/load)</td></tr>
<tr><td><code>tensor_compress</code></td><td>Compressed snapshot support</td></tr>
<tr><td><code>tensor_checkpoint</code></td><td>Checkpoint confirmation handling</td></tr>
<tr><td><code>tensor_chain</code></td><td>Cluster query executor trait</td></tr>
<tr><td><code>rustyline</code></td><td>Readline functionality (history, shortcuts, Ctrl+C)</td></tr>
<tr><td><code>parking_lot</code></td><td>Mutex and RwLock for thread-safe router access</td></tr>
<tr><td><code>base64</code></td><td>Vault key decoding</td></tr>
</tbody></table>
</div>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<ul>
<li><strong>query_router</strong>: The Query Router executes all queries. The shell delegates
all query parsing and execution to this module.</li>
<li><strong>tensor_store</strong>: Provides the underlying storage layer and snapshot
functionality.</li>
<li><strong>tensor_compress</strong>: Handles compressed snapshot format with int8
quantization.</li>
<li><strong>tensor_checkpoint</strong>: Provides checkpoint/rollback functionality with
confirmation prompts.</li>
<li><strong>tensor_chain</strong>: Provides cluster connectivity and distributed transaction
support.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/query-router.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/neumann-server.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/query-router.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/neumann-server.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
