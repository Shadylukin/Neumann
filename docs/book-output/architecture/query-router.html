<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Query Router - Neumann</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Unified tensor-based runtime for relational, graph, and vector data">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Neumann</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Shadylukin/Neumann/edit/main/docs/book/src/architecture/query-router.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="query-router"><a class="header" href="#query-router">Query Router</a></h1>
<p>Query Router is the unified query execution layer for Neumann. It parses shell
commands, routes them to appropriate engines, and combines results. All query
types (relational, graph, vector, unified) flow through the router, which
provides a single entry point for the entire system.</p>
<p>The router supports both synchronous and asynchronous execution, optional result
caching, and distributed query execution when cluster mode is enabled.</p>
<h2 id="key-types"><a class="header" href="#key-types">Key Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>QueryRouter</code></td><td>Main router orchestrating queries across all engines</td></tr>
<tr><td><code>QueryResult</code></td><td>Unified result enum for all query types</td></tr>
<tr><td><code>RouterError</code></td><td>Error types for query routing failures</td></tr>
<tr><td><code>NodeResult</code></td><td>Graph node result with id, label, properties</td></tr>
<tr><td><code>EdgeResult</code></td><td>Graph edge result with id, from, to, label</td></tr>
<tr><td><code>SimilarResult</code></td><td>Vector similarity result with key and score</td></tr>
<tr><td><code>UnifiedResult</code></td><td>Cross-engine query result with description and items</td></tr>
<tr><td><code>ChainResult</code></td><td>Blockchain operation results</td></tr>
<tr><td><code>QueryPlanner</code></td><td>Plans distributed query execution across shards</td></tr>
<tr><td><code>ResultMerger</code></td><td>Merges results from multiple shards</td></tr>
<tr><td><code>ShardResult</code></td><td>Result from a single shard with timing and error info</td></tr>
<tr><td><code>DistributedQueryConfig</code></td><td>Configuration for distributed execution</td></tr>
<tr><td><code>DistributedQueryStats</code></td><td>Statistics tracking for distributed queries</td></tr>
<tr><td><code>FilterCondition</code></td><td>Re-exported from vector_engine for programmatic filter building</td></tr>
<tr><td><code>FilterValue</code></td><td>Re-exported from vector_engine for filter values</td></tr>
<tr><td><code>FilterStrategy</code></td><td>Re-exported from vector_engine for search strategy</td></tr>
<tr><td><code>FilteredSearchConfig</code></td><td>Re-exported from vector_engine for filtered search config</td></tr>
</tbody></table>
</div>
<h3 id="queryresult-variants"><a class="header" href="#queryresult-variants">QueryResult Variants</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Variant</th><th>Description</th><th>Typical Source</th></tr></thead><tbody>
<tr><td><code>Empty</code></td><td>No result (CREATE, INSERT)</td><td>DDL, writes</td></tr>
<tr><td><code>Value(String)</code></td><td>Single value result</td><td>Scalar queries, DESCRIBE</td></tr>
<tr><td><code>Count(usize)</code></td><td>Count of affected rows/nodes/edges</td><td>UPDATE, DELETE</td></tr>
<tr><td><code>Ids(Vec&lt;u64&gt;)</code></td><td>List of IDs</td><td>INSERT</td></tr>
<tr><td><code>Rows(Vec&lt;Row&gt;)</code></td><td>Relational query results</td><td>SELECT</td></tr>
<tr><td><code>Nodes(Vec&lt;NodeResult&gt;)</code></td><td>Graph node results</td><td>NODE queries</td></tr>
<tr><td><code>Edges(Vec&lt;EdgeResult&gt;)</code></td><td>Graph edge results</td><td>EDGE queries</td></tr>
<tr><td><code>Path(Vec&lt;u64&gt;)</code></td><td>Graph traversal path</td><td>PATH queries</td></tr>
<tr><td><code>Similar(Vec&lt;SimilarResult&gt;)</code></td><td>Vector similarity results</td><td>SIMILAR queries</td></tr>
<tr><td><code>Unified(UnifiedResult)</code></td><td>Cross-engine query results</td><td>FIND queries</td></tr>
<tr><td><code>TableList(Vec&lt;String&gt;)</code></td><td>List of table names</td><td>SHOW TABLES</td></tr>
<tr><td><code>Blob(Vec&lt;u8&gt;)</code></td><td>Blob data bytes</td><td>BLOB GET</td></tr>
<tr><td><code>ArtifactInfo(ArtifactInfoResult)</code></td><td>Blob artifact metadata</td><td>BLOB INFO</td></tr>
<tr><td><code>ArtifactList(Vec&lt;String&gt;)</code></td><td>List of artifact IDs</td><td>BLOBS LIST</td></tr>
<tr><td><code>BlobStats(BlobStatsResult)</code></td><td>Blob storage statistics</td><td>BLOB STATS</td></tr>
<tr><td><code>CheckpointList(Vec&lt;CheckpointInfo&gt;)</code></td><td>List of checkpoints</td><td>CHECKPOINTS</td></tr>
<tr><td><code>Chain(ChainResult)</code></td><td>Chain operation result</td><td>CHAIN queries</td></tr>
</tbody></table>
</div>
<h3 id="routererror-types"><a class="header" href="#routererror-types">RouterError Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Error</th><th>Cause</th><th>Recovery</th></tr></thead><tbody>
<tr><td><code>ParseError</code></td><td>Invalid query syntax</td><td>Fix query syntax</td></tr>
<tr><td><code>UnknownCommand</code></td><td>Unknown command or keyword</td><td>Check command spelling</td></tr>
<tr><td><code>RelationalError</code></td><td>Error from relational engine</td><td>Check table/column names</td></tr>
<tr><td><code>GraphError</code></td><td>Error from graph engine</td><td>Verify node/edge IDs</td></tr>
<tr><td><code>VectorError</code></td><td>Error from vector engine</td><td>Check embedding dimensions</td></tr>
<tr><td><code>VaultError</code></td><td>Error from vault</td><td>Verify permissions</td></tr>
<tr><td><code>CacheError</code></td><td>Error from cache</td><td>Check cache configuration</td></tr>
<tr><td><code>BlobError</code></td><td>Error from blob storage</td><td>Verify artifact exists</td></tr>
<tr><td><code>CheckpointError</code></td><td>Error from checkpoint system</td><td>Check blob store initialized</td></tr>
<tr><td><code>ChainError</code></td><td>Error from chain system</td><td>Verify chain initialized</td></tr>
<tr><td><code>InvalidArgument</code></td><td>Invalid argument value</td><td>Check argument types</td></tr>
<tr><td><code>MissingArgument</code></td><td>Missing required argument</td><td>Provide required args</td></tr>
<tr><td><code>TypeMismatch</code></td><td>Type mismatch in query</td><td>Check value types</td></tr>
<tr><td><code>AuthenticationRequired</code></td><td>Vault operations require identity</td><td>Call <code>SET IDENTITY</code> first</td></tr>
</tbody></table>
</div>
<h3 id="error-propagation"><a class="header" href="#error-propagation">Error Propagation</a></h3>
<p>The router implements <code>From</code> traits to convert engine-specific errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Errors from underlying engines are automatically converted
impl From&lt;RelationalError&gt; for RouterError {
    fn from(e: RelationalError) -&gt; Self {
        RouterError::RelationalError(e.to_string())
    }
}

impl From&lt;GraphError&gt; for RouterError { ... }
impl From&lt;VectorError&gt; for RouterError { ... }
impl From&lt;VaultError&gt; for RouterError { ... }
impl From&lt;CacheError&gt; for RouterError { ... }
impl From&lt;BlobError&gt; for RouterError { ... }
impl From&lt;CheckpointError&gt; for RouterError { ... }
impl From&lt;ChainError&gt; for RouterError { ... }
impl From&lt;UnifiedError&gt; for RouterError { ... }
<span class="boring">}</span></code></pre></pre>
<p>This allows using the <code>?</code> operator throughout execution methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exec_select(&amp;self, select: &amp;SelectStmt) -&gt; Result&lt;QueryResult&gt; {
    // RelationalError automatically converts to RouterError
    let rows = self.relational.select_columnar(table_name, condition, options)?;
    Ok(QueryResult::Rows(rows))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre class="mermaid">graph TB
    subgraph QueryRouter
        Execute[execute_parsed]
        ExecuteAsync[execute_parsed_async]
        Distributed[try_execute_distributed]
        Cache[Query Cache]
        Statement[execute_statement]
        StatementAsync[execute_statement_async]
    end

    Execute --&gt; Distributed
    ExecuteAsync --&gt; StatementAsync
    Distributed --&gt;|cluster active| ScatterGather[Scatter-Gather]
    Distributed --&gt;|local| Cache
    Cache --&gt;|cache hit| Return[Return Result]
    Cache --&gt;|cache miss| Statement

    Statement --&gt; Relational[RelationalEngine]
    Statement --&gt; Graph[GraphEngine]
    Statement --&gt; Vector[VectorEngine]
    Statement --&gt; Vault[Vault]
    Statement --&gt; CacheOps[Cache Operations]
    Statement --&gt; Blob[BlobStore]
    Statement --&gt; Checkpoint[CheckpointManager]
    Statement --&gt; Chain[TensorChain]
    Statement --&gt; Cluster[ClusterOrchestrator]

    subgraph Engines
        Relational
        Graph
        Vector
    end

    subgraph Optional Services
        Vault
        CacheOps
        Blob
        Checkpoint
        Chain
        Cluster
    end

    Relational --&gt; Store[TensorStore]
    Graph --&gt; Store
    Vector --&gt; Store
</pre>
<h3 id="internal-router-structure"><a class="header" href="#internal-router-structure">Internal Router Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QueryRouter {
    // Core engines (always initialized)
    relational: Arc&lt;RelationalEngine&gt;,
    graph: Arc&lt;GraphEngine&gt;,
    vector: Arc&lt;VectorEngine&gt;,

    // Unified engine for cross-engine queries (lazily initialized)
    unified: Option&lt;UnifiedEngine&gt;,

    // Optional services (require explicit initialization)
    vault: Option&lt;Arc&lt;Vault&gt;&gt;,
    cache: Option&lt;Arc&lt;Cache&gt;&gt;,
    blob: Option&lt;Arc&lt;tokio::sync::Mutex&lt;BlobStore&gt;&gt;&gt;,
    blob_runtime: Option&lt;Arc&lt;Runtime&gt;&gt;,
    checkpoint: Option&lt;Arc&lt;tokio::sync::Mutex&lt;CheckpointManager&gt;&gt;&gt;,
    chain: Option&lt;Arc&lt;TensorChain&gt;&gt;,

    // Cluster mode
    cluster: Option&lt;Arc&lt;ClusterOrchestrator&gt;&gt;,
    cluster_runtime: Option&lt;Arc&lt;Runtime&gt;&gt;,
    distributed_planner: Option&lt;Arc&lt;QueryPlanner&gt;&gt;,
    distributed_config: DistributedQueryConfig,
    local_shard_id: ShardId,

    // Authentication state
    current_identity: Option&lt;String&gt;,

    // Vector index for fast similarity search
    hnsw_index: Option&lt;(HNSWIndex, Vec&lt;String&gt;)&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use query_router::QueryRouter;
use tensor_store::TensorStore;

// Create with independent engines
let router = QueryRouter::new();

// Create with existing engines
let router = QueryRouter::with_engines(relational, graph, vector);

// Create with shared storage (enables unified entities)
let store = TensorStore::new();
let router = QueryRouter::with_shared_store(store);
<span class="boring">}</span></code></pre></pre>
<h3 id="constructor-comparison"><a class="header" href="#constructor-comparison">Constructor Comparison</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Constructor</th><th>UnifiedEngine</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>new()</code></td><td>No</td><td>Simple single-engine queries</td></tr>
<tr><td><code>with_engines(...)</code></td><td>No</td><td>Custom engine configuration</td></tr>
<tr><td><code>with_shared_store(...)</code></td><td>Yes</td><td>Cross-engine unified queries</td></tr>
</tbody></table>
</div>
<h3 id="shared-store-benefits"><a class="header" href="#shared-store-benefits">Shared Store Benefits</a></h3>
<p>When using <code>with_shared_store()</code>, all engines share the same underlying
<code>TensorStore</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn with_shared_store(store: TensorStore) -&gt; Self {
    let relational = Arc::new(RelationalEngine::with_store(store.clone()));
    let graph = Arc::new(GraphEngine::with_store(store.clone()));
    let vector = Arc::new(VectorEngine::with_store(store.clone()));
    let unified = UnifiedEngine::with_engines(
        store,
        Arc::clone(&amp;relational),
        Arc::clone(&amp;graph),
        Arc::clone(&amp;vector),
    );
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>This enables:</p>
<ul>
<li>Cross-engine queries via <code>UnifiedEngine</code></li>
<li>Entity-level operations spanning all modalities</li>
<li>Consistent view of data across engines</li>
</ul>
<h2 id="query-execution"><a class="header" href="#query-execution">Query Execution</a></h2>
<h3 id="execution-methods"><a class="header" href="#execution-methods">Execution Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Parser</th><th>Async</th><th>Distributed</th><th>Cache</th></tr></thead><tbody>
<tr><td><code>execute(command)</code></td><td>Regex (legacy)</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td><code>execute_parsed(command)</code></td><td>AST</td><td>No</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>execute_parsed_async(command)</code></td><td>AST</td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td><code>execute_statement(stmt)</code></td><td>Pre-parsed</td><td>No</td><td>No</td><td>No</td></tr>
<tr><td><code>execute_statement_async(stmt)</code></td><td>Pre-parsed</td><td>Yes</td><td>No</td><td>No</td></tr>
</tbody></table>
</div>
<h3 id="execution-flow"><a class="header" href="#execution-flow">Execution Flow</a></h3>
<pre class="mermaid">flowchart TD
    A[execute_parsed] --&gt; B{Cluster Active?}
    B --&gt;|Yes| C[try_execute_distributed]
    B --&gt;|No| D[Parse Command]

    C --&gt; E{Plan Type}
    E --&gt;|Local| D
    E --&gt;|Remote| F[execute_on_shard]
    E --&gt;|ScatterGather| G[execute_scatter_gather]

    D --&gt; H{Cacheable?}
    H --&gt;|Yes| I{Cache Hit?}
    H --&gt;|No| J[execute_statement]

    I --&gt;|Yes| K[Return Cached]
    I --&gt;|No| J

    J --&gt; L[Engine Dispatch]
    L --&gt; M{Write Op?}
    M --&gt;|Yes| N[Invalidate Cache]
    M --&gt;|No| O[Cache Result]

    O --&gt; P[Return Result]
    N --&gt; P
    K --&gt; P
    F --&gt; P
    G --&gt; P
</pre>
<h3 id="detailed-execution-steps"><a class="header" href="#detailed-execution-steps">Detailed Execution Steps</a></h3>
<ol>
<li><strong>Distributed Check</strong>: If cluster is active, <code>try_execute_distributed</code> plans
query execution</li>
<li><strong>Parse</strong>: Convert command string to AST via <code>neumann_parser</code></li>
<li><strong>Cache Check</strong>: For cacheable queries (<code>SELECT</code>, <code>SIMILAR</code>, <code>NEIGHBORS</code>,
<code>PATH</code>), check cache first</li>
<li><strong>Execute</strong>: Dispatch to appropriate engine based on <code>StatementKind</code></li>
<li><strong>Cache Update</strong>: Store result for cacheable queries (as JSON via serde)</li>
<li><strong>Invalidate</strong>: Clear entire cache on write operations (INSERT, UPDATE,
DELETE, DDL)</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Synchronous execution
let result = router.execute_parsed("SELECT * FROM users")?;

// Async execution
let result = router.execute_parsed_async("SELECT * FROM users").await?;

// Concurrent queries
let (users, posts, similar) = tokio::join!(
    router.execute_parsed_async("SELECT * FROM users"),
    router.execute_parsed_async("SELECT * FROM posts"),
    router.execute_parsed_async("SIMILAR 'doc:1' LIMIT 10"),
);
<span class="boring">}</span></code></pre></pre>
<h3 id="cache-key-generation"><a class="header" href="#cache-key-generation">Cache Key Generation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cache_key_for_query(command: &amp;str) -&gt; String {
    format!("query:{}", command.trim().to_lowercase())
}
<span class="boring">}</span></code></pre></pre>
<p>This normalizes queries for cache lookup by trimming whitespace and lowercasing.</p>
<h2 id="statement-routing"><a class="header" href="#statement-routing">Statement Routing</a></h2>
<p>The router dispatches statements based on their <code>StatementKind</code>:</p>
<pre class="mermaid">flowchart LR
    subgraph StatementKind
        SQL[Select/Insert/Update/Delete]
        DDL[CreateTable/DropTable/CreateIndex/DropIndex]
        Graph[Node/Edge/Neighbors/Path]
        Vector[Embed/Similar]
        Unified[Find/Entity]
        Services[Vault/Cache/Blob/Checkpoint/Chain/Cluster]
    end

    SQL --&gt; RE[RelationalEngine]
    DDL --&gt; RE
    Graph --&gt; GE[GraphEngine]
    Vector --&gt; VE[VectorEngine]
    Unified --&gt; UE[UnifiedEngine]
    Services --&gt; Svc[Optional Services]
</pre>
<h3 id="complete-statement-routing-table"><a class="header" href="#complete-statement-routing-table">Complete Statement Routing Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Statement Type</th><th>Engine</th><th>Handler Method</th><th>Operations</th></tr></thead><tbody>
<tr><td><code>Select</code></td><td>Relational</td><td><code>exec_select</code></td><td>Table queries with WHERE, JOIN, GROUP BY, ORDER BY</td></tr>
<tr><td><code>Insert</code></td><td>Relational</td><td><code>exec_insert</code></td><td>Single/multi-row insert, INSERT…SELECT</td></tr>
<tr><td><code>Update</code></td><td>Relational</td><td><code>exec_update</code></td><td>Row updates with conditions</td></tr>
<tr><td><code>Delete</code></td><td>Relational</td><td><code>exec_delete</code></td><td>Row deletion with protection</td></tr>
<tr><td><code>CreateTable</code></td><td>Relational</td><td><code>exec_create_table</code></td><td>Table DDL</td></tr>
<tr><td><code>DropTable</code></td><td>Relational</td><td>inline</td><td>Table removal with protection</td></tr>
<tr><td><code>CreateIndex</code></td><td>Relational</td><td>inline</td><td>Index creation</td></tr>
<tr><td><code>DropIndex</code></td><td>Relational</td><td>inline</td><td>Index removal with protection</td></tr>
<tr><td><code>ShowTables</code></td><td>Relational</td><td>inline</td><td>List tables</td></tr>
<tr><td><code>Describe</code></td><td>Multiple</td><td><code>exec_describe</code></td><td>Schema/node/edge info</td></tr>
<tr><td><code>Node</code></td><td>Graph</td><td><code>exec_node</code></td><td>CREATE/GET/DELETE/LIST/UPDATE</td></tr>
<tr><td><code>Edge</code></td><td>Graph</td><td><code>exec_edge</code></td><td>CREATE/GET/DELETE/LIST/UPDATE</td></tr>
<tr><td><code>Neighbors</code></td><td>Graph</td><td><code>exec_neighbors</code></td><td>Neighbor traversal</td></tr>
<tr><td><code>Path</code></td><td>Graph</td><td><code>exec_path</code></td><td>Path finding</td></tr>
<tr><td><code>Embed</code></td><td>Vector</td><td><code>exec_embed</code></td><td>Embedding storage, batch, delete</td></tr>
<tr><td><code>Similar</code></td><td>Vector</td><td><code>exec_similar</code></td><td>k-NN search</td></tr>
<tr><td><code>ShowEmbeddings</code></td><td>Vector</td><td>inline</td><td>List embedding keys</td></tr>
<tr><td><code>CountEmbeddings</code></td><td>Vector</td><td>inline</td><td>Count embeddings</td></tr>
<tr><td><code>Find</code></td><td>Unified</td><td><code>exec_find</code></td><td>Cross-engine queries</td></tr>
<tr><td><code>Entity</code></td><td>Unified</td><td><code>exec_entity</code></td><td>Entity CRUD</td></tr>
<tr><td><code>Vault</code></td><td>Vault</td><td><code>exec_vault</code></td><td>Secret management</td></tr>
<tr><td><code>Cache</code></td><td>Cache</td><td><code>exec_cache</code></td><td>LLM response cache</td></tr>
<tr><td><code>Blob</code></td><td>BlobStore</td><td><code>exec_blob</code></td><td>Artifact operations</td></tr>
<tr><td><code>Blobs</code></td><td>BlobStore</td><td><code>exec_blobs</code></td><td>Artifact listing</td></tr>
<tr><td><code>Checkpoint</code></td><td>Checkpoint</td><td><code>exec_checkpoint</code></td><td>Create snapshot</td></tr>
<tr><td><code>Rollback</code></td><td>Checkpoint</td><td><code>exec_rollback</code></td><td>Restore snapshot</td></tr>
<tr><td><code>Checkpoints</code></td><td>Checkpoint</td><td><code>exec_checkpoints</code></td><td>List snapshots</td></tr>
<tr><td><code>Chain</code></td><td>TensorChain</td><td><code>exec_chain</code></td><td>Blockchain operations</td></tr>
<tr><td><code>Cluster</code></td><td>Orchestrator</td><td><code>exec_cluster</code></td><td>Cluster management</td></tr>
<tr><td><code>Empty</code></td><td>—</td><td>inline</td><td>No-op</td></tr>
</tbody></table>
</div>
<h3 id="statement-handler-pattern"><a class="header" href="#statement-handler-pattern">Statement Handler Pattern</a></h3>
<p>Each handler follows a consistent pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exec_&lt;statement&gt;(&amp;self, stmt: &amp;&lt;Statement&gt;Stmt) -&gt; Result&lt;QueryResult&gt; {
    // 1. Validate/extract parameters
    let param = self.eval_string_expr(&amp;stmt.field)?;

    // 2. Check service availability (for optional services)
    let service = self.service.as_ref()
        .ok_or_else(|| RouterError::ServiceError("Service not initialized".to_string()))?;

    // 3. For destructive ops, check protection
    if is_destructive {
        match self.protect_destructive_op(...)? {
            ProtectedOpResult::Cancelled =&gt; return Err(...),
            ProtectedOpResult::Proceed =&gt; {},
        }
    }

    // 4. Execute operation
    let result = service.operation(...)?;

    // 5. Convert to QueryResult
    Ok(QueryResult::Variant(result))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="supported-queries"><a class="header" href="#supported-queries">Supported Queries</a></h2>
<h3 id="relational-operations"><a class="header" href="#relational-operations">Relational Operations</a></h3>
<pre><code class="language-sql">-- DDL
CREATE TABLE users (id INT, name VARCHAR(100), email VARCHAR(255))
DROP TABLE users

-- DML
INSERT INTO users (id, name, email) VALUES (1, 'Alice', 'alice@example.com')
INSERT INTO users SELECT * FROM temp_users
UPDATE users SET name = 'Bob' WHERE id = 1
DELETE FROM users WHERE id = 1

-- Queries
SELECT * FROM users WHERE id = 1
SELECT id, name FROM users ORDER BY name ASC LIMIT 10 OFFSET 5
SELECT COUNT(*), AVG(age) FROM users WHERE active = true GROUP BY dept HAVING COUNT(*) &gt; 5

-- JOINs
SELECT * FROM users u INNER JOIN orders o ON u.id = o.user_id
SELECT * FROM users u LEFT JOIN profiles p ON u.id = p.user_id
SELECT * FROM a CROSS JOIN b
SELECT * FROM a NATURAL JOIN b
</code></pre>
<h3 id="aggregate-functions"><a class="header" href="#aggregate-functions">Aggregate Functions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Description</th><th>Null Handling</th></tr></thead><tbody>
<tr><td><code>COUNT(*)</code></td><td>Count all rows</td><td>Counts nulls</td></tr>
<tr><td><code>COUNT(col)</code></td><td>Count non-null values</td><td>Excludes nulls</td></tr>
<tr><td><code>SUM(col)</code></td><td>Sum numeric values</td><td>Skips nulls</td></tr>
<tr><td><code>AVG(col)</code></td><td>Average numeric values</td><td>Skips nulls, returns NULL if no values</td></tr>
<tr><td><code>MIN(col)</code></td><td>Minimum value</td><td>Skips nulls</td></tr>
<tr><td><code>MAX(col)</code></td><td>Maximum value</td><td>Skips nulls</td></tr>
</tbody></table>
</div>
<h3 id="graph-operations"><a class="header" href="#graph-operations">Graph Operations</a></h3>
<pre><code class="language-sql">-- Node operations
NODE CREATE person {name: 'Alice', age: 30}
NODE GET 123
NODE DELETE 123
NODE LIST person LIMIT 100
NODE UPDATE 123 {name: 'Alice Smith'}

-- Edge operations
EDGE CREATE person:1 friend person:2 {since: 2020}
EDGE GET 456
EDGE DELETE 456
EDGE LIST friend LIMIT 50

-- Traversals
NEIGHBORS person:1 friend OUTGOING
NEIGHBORS 123 * BOTH
PATH person:1 TO person:5 VIA friend
</code></pre>
<h3 id="vector-operations"><a class="header" href="#vector-operations">Vector Operations</a></h3>
<pre><code class="language-sql">-- Single embedding
EMBED doc1 [0.1, 0.2, 0.3, 0.4]
EMBED DELETE doc1

-- Batch embedding
EMBED BATCH [('key1', [0.1, 0.2]), ('key2', [0.3, 0.4])]

-- Similarity search
SIMILAR 'doc1' LIMIT 5
SIMILAR 'doc1' LIMIT 5 EUCLIDEAN
SIMILAR [0.1, 0.2, 0.3] LIMIT 10 COSINE

-- Listing
SHOW EMBEDDINGS LIMIT 100
COUNT EMBEDDINGS
</code></pre>
<h3 id="distance-metrics"><a class="header" href="#distance-metrics">Distance Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Description</th><th>Use Case</th><th>Formula</th></tr></thead><tbody>
<tr><td><code>COSINE</code></td><td>Cosine similarity (default)</td><td>Semantic similarity</td><td><code>1 - (a.b) / (‖a‖ * ‖b‖)</code></td></tr>
<tr><td><code>EUCLIDEAN</code></td><td>Euclidean distance (L2)</td><td>Spatial distance</td><td>sqrt(sum((a[i] - b[i])^2))</td></tr>
<tr><td><code>DOT_PRODUCT</code></td><td>Dot product</td><td>Magnitude-aware similarity</td><td>sum(a[i] * b[i])</td></tr>
</tbody></table>
</div>
<h3 id="unified-entity-operations"><a class="header" href="#unified-entity-operations">Unified Entity Operations</a></h3>
<pre><code class="language-sql">-- Create entity with all modalities
ENTITY CREATE 'user:1' {name: 'Alice'} EMBEDDING [0.1, 0.2, 0.3]

-- Connect entities
ENTITY CONNECT 'user:1' -&gt; 'doc:1' : authored

-- Combined similarity + graph search
SIMILAR 'query:key' CONNECTED TO 'hub:entity' LIMIT 10
</code></pre>
<h2 id="cross-engine-queries"><a class="header" href="#cross-engine-queries">Cross-Engine Queries</a></h2>
<p>Cross-engine queries combine graph relationships with vector similarity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let store = TensorStore::new();
let mut router = QueryRouter::with_shared_store(store);

// Set up entities with embeddings
router.vector().set_entity_embedding("user:1", vec![0.1, 0.2, 0.3])?;
router.vector().set_entity_embedding("user:2", vec![0.15, 0.25, 0.35])?;

// Connect via graph edges
router.connect_entities("user:1", "user:2", "follows")?;

// Build HNSW index for O(log n) similarity search
router.build_vector_index()?;

// Find neighbors sorted by similarity
let results = router.find_neighbors_by_similarity("user:1", &amp;query_vec, 10)?;

// Find similar AND connected entities
let results = router.find_similar_connected("user:1", "user:2", 5)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="cross-engine-methods"><a class="header" href="#cross-engine-methods">Cross-Engine Methods</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th><th>Complexity</th></tr></thead><tbody>
<tr><td><code>build_vector_index()</code></td><td>Build HNSW index for O(log n) search</td><td>O(n log n)</td></tr>
<tr><td><code>connect_entities(from, to, type)</code></td><td>Add graph edge between entities</td><td>O(1)</td></tr>
<tr><td><code>find_neighbors_by_similarity(key, query, k)</code></td><td>Neighbors sorted by vector similarity</td><td>O(k * log n) with HNSW</td></tr>
<tr><td><code>find_similar_connected(query, connected_to, k)</code></td><td>Similar AND connected entities</td><td>O(k * log n) + O(neighbors)</td></tr>
<tr><td><code>create_unified_entity(key, fields, embedding)</code></td><td>Create entity with all modalities</td><td>O(1)</td></tr>
</tbody></table>
</div>
<h3 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h3>
<p>The <code>find_similar_connected</code> method combines vector and graph operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_similar_connected(
    &amp;self,
    query_key: &amp;str,
    connected_to: &amp;str,
    top_k: usize,
) -&gt; Result&lt;Vec&lt;UnifiedItem&gt;&gt; {
    let query_embedding = self.vector.get_entity_embedding(query_key)?;

    // Use HNSW index if available, otherwise brute-force
    let similar = if let Some((ref index, ref keys)) = self.hnsw_index {
        self.vector.search_with_hnsw(index, keys, &amp;query_embedding, top_k * 2)?
    } else {
        self.vector.search_entities(&amp;query_embedding, top_k * 2)?
    };

    // Get graph neighbors of connected_to entity
    let connected_neighbors: HashSet&lt;String&gt; = self.graph
        .get_entity_neighbors(connected_to)
        .unwrap_or_default()
        .into_iter()
        .collect();

    // Filter to entities that are both similar AND connected
    let items: Vec&lt;UnifiedItem&gt; = similar
        .into_iter()
        .filter(|s| connected_neighbors.contains(&amp;s.key))
        .take(top_k)
        .map(|s| UnifiedItem::new("vector+graph", &amp;s.key).with_score(s.score))
        .collect();

    Ok(items)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="optional-services"><a class="header" href="#optional-services">Optional Services</a></h2>
<p>Services are lazily initialized and can be enabled as needed:</p>
<pre class="mermaid">flowchart TD
    subgraph Initialization Order
        A[QueryRouter::new] --&gt; B[Core Engines Ready]
        B --&gt; C{Need Vault?}
        C --&gt;|Yes| D[init_vault]
        B --&gt; E{Need Cache?}
        E --&gt;|Yes| F[init_cache]
        B --&gt; G{Need Blob?}
        G --&gt;|Yes| H[init_blob]
        H --&gt; I{Need Checkpoint?}
        I --&gt;|Yes| J[init_checkpoint]
        B --&gt; K{Need Chain?}
        K --&gt;|Yes| L[init_chain]
        B --&gt; M{Need Cluster?}
        M --&gt;|Yes| N[init_cluster]
    end

    style J fill:#ffcccc
    note[Checkpoint requires Blob]
</pre>
<h3 id="vault"><a class="header" href="#vault">Vault</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize with master key
router.init_vault(master_key)?;

// Or auto-initialize from NEUMANN_VAULT_KEY env var
router.ensure_vault()?;

// Set identity for access control
router.set_identity("user:alice");
<span class="boring">}</span></code></pre></pre>
<p>Vault requires authentication for all operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exec_vault(&amp;self, stmt: &amp;VaultStmt) -&gt; Result&lt;QueryResult&gt; {
    let vault = self.vault.as_ref()
        .ok_or_else(|| RouterError::VaultError("Vault not initialized".to_string()))?;

    // SECURITY: Require explicit authentication
    let identity = self.require_identity()?;

    match &amp;stmt.operation {
        VaultOp::Get { key } =&gt; {
            let value = vault.get(identity, &amp;key)?;
            Ok(QueryResult::Value(value))
        },
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cache"><a class="header" href="#cache">Cache</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Default configuration
router.init_cache();

// Custom configuration
router.init_cache_with_config(CacheConfig::default())?;

// Auto-initialize
router.ensure_cache();
<span class="boring">}</span></code></pre></pre>
<p>Cache operations are available through queries:</p>
<pre><code class="language-sql">CACHE INIT
CACHE STATS
CACHE CLEAR
CACHE EVICT 100
CACHE GET 'key'
CACHE PUT 'key' 'value'
CACHE SEMANTIC GET 'query' THRESHOLD 0.9
CACHE SEMANTIC PUT 'query' 'response' [0.1, 0.2, 0.3]
</code></pre>
<h3 id="blob-storage"><a class="header" href="#blob-storage">Blob Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize blob store
router.init_blob()?;
router.start_blob()?;  // Start GC

// Graceful shutdown
router.shutdown_blob()?;
<span class="boring">}</span></code></pre></pre>
<p>Blob operations use async execution internally:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exec_blob(&amp;self, stmt: &amp;BlobStmt) -&gt; Result&lt;QueryResult&gt; {
    let blob = self.blob.as_ref()
        .ok_or_else(|| RouterError::BlobError("Blob store not initialized".to_string()))?;
    let runtime = self.blob_runtime.as_ref()
        .ok_or_else(|| RouterError::BlobError("Blob runtime not initialized".to_string()))?;

    match &amp;stmt.operation {
        BlobOp::Put { filename, data, ... } =&gt; {
            let artifact_id = runtime.block_on(async {
                let blob_guard = blob.lock().await;
                blob_guard.put(&amp;filename, &amp;data, options).await
            })?;
            Ok(QueryResult::Value(artifact_id))
        },
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="checkpoint"><a class="header" href="#checkpoint">Checkpoint</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Requires blob storage
router.init_blob()?;
router.init_checkpoint()?;

// Set confirmation handler for destructive ops
router.set_confirmation_handler(handler)?;
<span class="boring">}</span></code></pre></pre>
<p>Checkpoint provides automatic protection for destructive operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn protect_destructive_op(
    &amp;self,
    command: &amp;str,
    op: DestructiveOp,
    sample_data: Vec&lt;String&gt;,
) -&gt; Result&lt;ProtectedOpResult&gt; {
    let Some(checkpoint) = self.checkpoint.as_ref() else {
        return Ok(ProtectedOpResult::Proceed);
    };

    runtime.block_on(async {
        let cp = checkpoint.lock().await;

        if !cp.auto_checkpoint_enabled() {
            return Ok(ProtectedOpResult::Proceed);
        }

        let preview = cp.generate_preview(&amp;op, sample_data);

        if !cp.request_confirmation(&amp;op, &amp;preview) {
            return Ok(ProtectedOpResult::Cancelled);
        }

        // Create auto-checkpoint before operation
        cp.create_auto(command, op, preview, store).await?;

        Ok(ProtectedOpResult::Proceed)
    })
}
<span class="boring">}</span></code></pre></pre>
<p>Protected operations include:</p>
<ul>
<li><code>DELETE</code> (relational rows)</li>
<li><code>DROP TABLE</code></li>
<li><code>DROP INDEX</code></li>
<li><code>NODE DELETE</code></li>
<li><code>EMBED DELETE</code></li>
<li><code>VAULT DELETE</code></li>
<li><code>BLOB DELETE</code></li>
<li><code>CACHE CLEAR</code></li>
</ul>
<h3 id="chain"><a class="header" href="#chain">Chain</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize tensor chain
router.init_chain("node_1")?;

// Auto-initialize with default node ID
router.ensure_chain()?;
<span class="boring">}</span></code></pre></pre>
<p>Chain operations available through queries:</p>
<pre><code class="language-sql">CHAIN BEGIN
CHAIN COMMIT
CHAIN ROLLBACK 100
CHAIN HISTORY 'key'
CHAIN HEIGHT
CHAIN TIP
CHAIN BLOCK 42
CHAIN VERIFY
CHAIN SHOW CODEBOOK GLOBAL
CHAIN SHOW CODEBOOK LOCAL 'domain'
CHAIN ANALYZE TRANSITIONS
</code></pre>
<h3 id="cluster"><a class="header" href="#cluster">Cluster</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize cluster mode
router.init_cluster("node_1", bind_addr, &amp;peers)?;

// Check cluster status
if router.is_cluster_active() {
    // Distributed queries enabled
}

// Graceful shutdown
router.shutdown_cluster()?;
<span class="boring">}</span></code></pre></pre>
<p>Cluster initialization creates:</p>
<ol>
<li><code>ClusterOrchestrator</code> for Raft consensus</li>
<li><code>ConsistentHashPartitioner</code> for key-based routing</li>
<li><code>QueryPlanner</code> for distributed execution</li>
</ol>
<h2 id="distributed-query-execution"><a class="header" href="#distributed-query-execution">Distributed Query Execution</a></h2>
<p>When cluster mode is active, queries are automatically distributed:</p>
<pre class="mermaid">flowchart TD
    A[Query] --&gt; B[QueryPlanner]
    B --&gt; C{classify_query}

    C --&gt;|GET key| D{partition key}
    D --&gt;|Local| E[QueryPlan::Local]
    D --&gt;|Remote| F[QueryPlan::Remote]

    C --&gt;|SIMILAR| G[QueryPlan::ScatterGather]
    C --&gt;|SELECT *| G
    C --&gt;|COUNT| H[QueryPlan::ScatterGather + Aggregate]
    C --&gt;|Unknown| E

    F --&gt; I[execute_on_shard]
    G --&gt; J[execute_scatter_gather]
    H --&gt; J

    J --&gt; K[ResultMerger::merge]
    K --&gt; L[QueryResult]
</pre>
<h3 id="query-classification"><a class="header" href="#query-classification">Query Classification</a></h3>
<p>The <code>QueryPlanner</code> classifies queries based on text pattern matching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn classify_query(&amp;self, query: &amp;str) -&gt; QueryType {
    let query_upper = query.to_uppercase();

    // Point lookups
    if query_upper.starts_with("GET ")
       || query_upper.starts_with("NODE GET ")
       || query_upper.starts_with("ENTITY GET ") {
        if let Some(key) = self.extract_key(query) {
            return QueryType::PointLookup { key };
        }
    }

    // Similarity search
    if query_upper.starts_with("SIMILAR ") {
        let k = self.extract_top_k(query).unwrap_or(10);
        return QueryType::SimilaritySearch { k };
    }

    // Table scans with aggregates
    if query_upper.starts_with("SELECT ") {
        if query_upper.contains("COUNT(") {
            return QueryType::Aggregate { func: AggregateFunction::Count };
        }
        if query_upper.contains("SUM(") {
            return QueryType::Aggregate { func: AggregateFunction::Sum };
        }
        return QueryType::TableScan;
    }

    QueryType::Unknown
}
<span class="boring">}</span></code></pre></pre>
<h3 id="query-plans"><a class="header" href="#query-plans">Query Plans</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Plan</th><th>When Used</th><th>Example</th><th>Shards Contacted</th></tr></thead><tbody>
<tr><td><code>Local</code></td><td>Point lookups on local shard</td><td><code>GET user:1</code> (local key)</td><td>1</td></tr>
<tr><td><code>Remote</code></td><td>Point lookups on remote shard</td><td><code>GET user:2</code> (remote key)</td><td>1</td></tr>
<tr><td><code>ScatterGather</code></td><td>Full scans, aggregates, similarity</td><td><code>SELECT *</code>, <code>SIMILAR</code>, <code>COUNT</code></td><td>All</td></tr>
</tbody></table>
</div>
<h3 id="merge-strategies"><a class="header" href="#merge-strategies">Merge Strategies</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Strategy</th><th>Description</th><th>Use Case</th><th>Algorithm</th></tr></thead><tbody>
<tr><td><code>Union</code></td><td>Combine all results</td><td>SELECT, NODE queries</td><td>Concatenate rows/nodes/edges</td></tr>
<tr><td><code>TopK(k)</code></td><td>Keep top K by score</td><td>SIMILAR queries</td><td>Sort by score desc, truncate</td></tr>
<tr><td><code>Aggregate(func)</code></td><td>SUM, COUNT, AVG, MAX, MIN</td><td>Aggregate queries</td><td>Combine partial aggregates</td></tr>
<tr><td><code>FirstNonEmpty</code></td><td>First result found</td><td>Point lookups</td><td>Short-circuit on first result</td></tr>
<tr><td><code>Concat</code></td><td>Concatenate in order</td><td>Ordered results</td><td>Same as Union</td></tr>
</tbody></table>
</div>
<h3 id="result-merger-implementation"><a class="header" href="#result-merger-implementation">Result Merger Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ResultMerger {
    pub fn merge(results: Vec&lt;ShardResult&gt;, strategy: &amp;MergeStrategy) -&gt; Result&lt;QueryResult&gt; {
        // Filter out errors if not fail-fast
        let successful: Vec&lt;_&gt; = results.into_iter()
            .filter(|r| r.error.is_none())
            .collect();

        if successful.is_empty() {
            return Ok(QueryResult::Empty);
        }

        match strategy {
            MergeStrategy::Union =&gt; Self::merge_union(successful),
            MergeStrategy::TopK(k) =&gt; Self::merge_top_k(successful, *k),
            MergeStrategy::Aggregate(func) =&gt; Self::merge_aggregate(successful, *func),
            MergeStrategy::FirstNonEmpty =&gt; Self::merge_first_non_empty(successful),
            MergeStrategy::Concat =&gt; Self::merge_concat(successful),
        }
    }

    fn merge_top_k(results: Vec&lt;ShardResult&gt;, k: usize) -&gt; Result&lt;QueryResult&gt; {
        let mut all_similar: Vec&lt;SimilarResult&gt; = Vec::new();

        for shard_result in results {
            if let QueryResult::Similar(similar) = shard_result.result {
                all_similar.extend(similar);
            }
        }

        // Sort by score descending
        all_similar.sort_by(|a, b|
            b.score.partial_cmp(&amp;a.score).unwrap_or(std::cmp::Ordering::Equal)
        );

        // Take top K
        all_similar.truncate(k);

        Ok(QueryResult::Similar(all_similar))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="distributed-query-configuration"><a class="header" href="#distributed-query-configuration">Distributed Query Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DistributedQueryConfig {
    /// Maximum concurrent shard queries (default: 10)
    pub max_concurrent: usize,
    /// Query timeout per shard in milliseconds (default: 5000)
    pub shard_timeout_ms: u64,
    /// Retry count for failed shards (default: 2)
    pub retry_count: usize,
    /// Whether to fail fast on first shard error (default: false)
    pub fail_fast: bool,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="semantic-routing"><a class="header" href="#semantic-routing">Semantic Routing</a></h3>
<p>For embedding-aware routing, use <code>plan_with_embedding</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn plan_with_embedding(&amp;self, query: &amp;str, embedding: &amp;[f32]) -&gt; QueryPlan {
    // Get semantically relevant shards
    let relevant_shards = self.shards_for_embedding(embedding);

    if relevant_shards.is_empty() {
        return self.plan(query);  // Fallback to all shards
    }

    // Route similarity search to relevant shards only
    match self.classify_query(query) {
        QueryType::SimilaritySearch { k } =&gt; QueryPlan::ScatterGather {
            shards: relevant_shards,
            query: query.to_string(),
            merge: MergeStrategy::TopK(k),
        },
        _ =&gt; self.plan(query),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Complexity</th><th>Notes</th></tr></thead><tbody>
<tr><td>Parse</td><td>O(n)</td><td>n = query length</td></tr>
<tr><td>SELECT</td><td>O(m)</td><td>m = rows in table</td></tr>
<tr><td>SELECT with index</td><td>O(log m + k)</td><td>k = matching rows</td></tr>
<tr><td>INSERT</td><td>O(1)</td><td>Single row insert</td></tr>
<tr><td>NODE</td><td>O(1)</td><td>Single node create</td></tr>
<tr><td>EDGE</td><td>O(1)</td><td>Single edge create</td></tr>
<tr><td>PATH</td><td>O(V+E)</td><td>BFS traversal</td></tr>
<tr><td>SIMILAR (brute-force)</td><td>O(n*d)</td><td>n = embeddings, d = dimensions</td></tr>
<tr><td>SIMILAR (HNSW)</td><td>O(log n * d)</td><td>After <code>build_vector_index()</code></td></tr>
<tr><td><code>find_similar_connected</code></td><td>O(log n) or O(n)</td><td>Uses HNSW if index built</td></tr>
<tr><td>Distributed query</td><td>O(query) / shards</td><td>Parallelized across shards</td></tr>
<tr><td>Result merge (Union)</td><td>O(total results)</td><td>Linear in combined size</td></tr>
<tr><td>Result merge (TopK)</td><td>O(n log k)</td><td>Sort + truncate</td></tr>
</tbody></table>
</div>
<h3 id="hnsw-index-performance"><a class="header" href="#hnsw-index-performance">HNSW Index Performance</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Entities</th><th>Brute-force</th><th>With HNSW</th><th>Speedup</th></tr></thead><tbody>
<tr><td>200</td><td>4.17s</td><td>9.3us</td><td>448,000x</td></tr>
</tbody></table>
</div>
<h3 id="distributed-query-overhead"><a class="header" href="#distributed-query-overhead">Distributed Query Overhead</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Overhead</th></tr></thead><tbody>
<tr><td>Query planning</td><td>~1-5 us</td></tr>
<tr><td>Network round-trip</td><td>~1-10 ms (depends on network)</td></tr>
<tr><td>Result serialization</td><td>~10-100 us (depends on result size)</td></tr>
<tr><td>Result merging</td><td>~1-10 us (TopK), O(n) for Union</td></tr>
</tbody></table>
</div>
<h2 id="query-caching"><a class="header" href="#query-caching">Query Caching</a></h2>
<p>Cacheable statements are automatically cached when a cache is configured:</p>
<ul>
<li><strong>Cacheable</strong>: <code>SELECT</code>, <code>SIMILAR</code>, <code>NEIGHBORS</code>, <code>PATH</code></li>
<li><strong>Write operations</strong>: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, DDL invalidate cache</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_cacheable_statement(stmt: &amp;Statement) -&gt; bool {
    matches!(&amp;stmt.kind,
        StatementKind::Select(_)
        | StatementKind::Similar(_)
        | StatementKind::Neighbors(_)
        | StatementKind::Path(_)
    )
}

fn is_write_statement(stmt: &amp;Statement) -&gt; bool {
    matches!(&amp;stmt.kind,
        StatementKind::Insert(_)
        | StatementKind::Update(_)
        | StatementKind::Delete(_)
        | StatementKind::CreateTable(_)
        | StatementKind::DropTable(_)
        | StatementKind::CreateIndex(_)
        | StatementKind::DropIndex(_)
    )
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cache-usage-example"><a class="header" href="#cache-usage-example">Cache Usage Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable caching
router.init_cache();

// First call executes and caches (JSON serialization)
let result1 = router.execute_parsed("SELECT * FROM users")?;

// Second call returns cached result (JSON deserialization)
let result2 = router.execute_parsed("SELECT * FROM users")?;

// Write operations invalidate entire cache
router.execute_parsed("INSERT INTO users VALUES (2, 'Bob')")?;
// Cache is now empty
<span class="boring">}</span></code></pre></pre>
<h3 id="cache-gotchas"><a class="header" href="#cache-gotchas">Cache Gotchas</a></h3>
<ol>
<li><strong>Full cache invalidation</strong>: Any write operation clears the entire cache. No
table-level tracking.</li>
<li><strong>Case sensitivity</strong>: Cache keys are lowercased, so <code>SELECT</code> and <code>select</code> hit
the same entry.</li>
<li><strong>Whitespace normalization</strong>: Queries are trimmed but not fully normalized.</li>
<li><strong>No TTL</strong>: Cached entries persist until invalidated by writes or explicit
<code>CACHE CLEAR</code>.</li>
</ol>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="service-initialization-order"><a class="header" href="#service-initialization-order">Service Initialization Order</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize in dependency order
let mut router = QueryRouter::with_shared_store(store);

// Optional services (no dependencies)
router.init_vault(key)?;
router.init_cache();

// Blob first (required for checkpoint)
router.init_blob()?;
router.start_blob()?;

// Checkpoint depends on blob
router.init_checkpoint()?;
router.set_confirmation_handler(handler)?;

// Chain is independent
router.init_chain("node_1")?;

// Cluster is independent but typically last
router.init_cluster("node_1", addr, &amp;peers)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="identity-management"><a class="header" href="#identity-management">Identity Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Always set identity before vault operations
router.set_identity("user:alice");

// Check authentication status
if !router.is_authenticated() {
    return Err("Authentication required");
}

// Identity persists across queries
router.execute_parsed("VAULT GET 'secret'")?;  // Uses alice's identity
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match router.execute_parsed(query) {
    Ok(result) =&gt; handle_result(result),
    Err(RouterError::ParseError(msg)) =&gt; println!("Invalid query: {}", msg),
    Err(RouterError::AuthenticationRequired) =&gt; println!("Please run SET IDENTITY first"),
    Err(RouterError::RelationalError(msg)) if msg.contains("not found") =&gt; {
        println!("Table not found");
    },
    Err(e) =&gt; println!("Error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="async-vs-sync"><a class="header" href="#async-vs-sync">Async vs Sync</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use sync for simple scripts
let result = router.execute_parsed("SELECT * FROM users")?;

// Use async for concurrent operations
async fn parallel_queries(router: &amp;QueryRouter) -&gt; Result&lt;()&gt; {
    let (users, orders) = tokio::join!(
        router.execute_parsed_async("SELECT * FROM users"),
        router.execute_parsed_async("SELECT * FROM orders"),
    );
    // Both queries execute concurrently
    Ok(())
}

// Note: async execution doesn't support distributed routing yet
<span class="boring">}</span></code></pre></pre>
<h3 id="building-vector-index"><a class="header" href="#building-vector-index">Building Vector Index</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Build index after loading embeddings
for (key, embedding) in embeddings {
    router.vector().set_entity_embedding(&amp;key, embedding)?;
}

// Build HNSW index for fast similarity search
router.build_vector_index()?;

// Now SIMILAR queries use O(log n) search
let results = router.execute_parsed("SIMILAR 'query' LIMIT 10")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="related-modules"><a class="header" href="#related-modules">Related Modules</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Relationship</th></tr></thead><tbody>
<tr><td><a href="tensor-store.html">Tensor Store</a></td><td>Underlying storage layer</td></tr>
<tr><td><a href="relational-engine.html">Relational Engine</a></td><td>Table operations</td></tr>
<tr><td><a href="graph-engine.html">Graph Engine</a></td><td>Node/edge operations</td></tr>
<tr><td><a href="vector-engine.html">Vector Engine</a></td><td>Embedding operations</td></tr>
<tr><td><a href="tensor-unified.html">Tensor Unified</a></td><td>Cross-engine queries</td></tr>
<tr><td><a href="neumann-parser.html">Neumann Parser</a></td><td>Query parsing</td></tr>
<tr><td><a href="tensor-vault.html">Tensor Vault</a></td><td>Secret storage</td></tr>
<tr><td><a href="tensor-cache.html">Tensor Cache</a></td><td>LLM response caching</td></tr>
<tr><td><a href="tensor-blob.html">Tensor Blob</a></td><td>Artifact storage</td></tr>
<tr><td><a href="tensor-checkpoint.html">Tensor Checkpoint</a></td><td>Snapshots</td></tr>
<tr><td><a href="tensor-chain.html">Tensor Chain</a></td><td>Blockchain</td></tr>
<tr><td><a href="neumann-shell.html">Neumann Shell</a></td><td>CLI interface</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/neumann-parser.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/neumann-shell.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/neumann-parser.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/neumann-shell.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
